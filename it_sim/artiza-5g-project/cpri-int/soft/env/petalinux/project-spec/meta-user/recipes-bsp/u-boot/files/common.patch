--- a/common/35G_common.h	1970-01-01 09:00:00.000000000 +0900
+++ b/common/35G_common.h	2018-06-04 10:48:59.331317600 +0900
@@ -0,0 +1,499 @@
+/*
+ * (C) Copyright 2000-2009
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __35G_COMMON_H_
+#define __35G_COMMON_H_	1
+
+#include <common.h>
+
+/*!
+ * @name 共通型定義
+ * @note 
+ * @{
+ */
+typedef		int								INT;
+typedef		short							SHORT;	
+typedef		char							CHAR;
+typedef		float							FLOAT;
+typedef		double							DL;
+typedef		unsigned long long int			ULLINT;
+typedef		void							VOID;
+typedef		unsigned long					ULONG;
+typedef		unsigned int					UINT;
+typedef		unsigned short					USHORT;
+typedef		unsigned char					UCHAR;
+
+/*****************************************
+ * デバッグ用マクロ定義
+ */
+extern int dbgSW;
+#if 0
+#define	DBGLOG_ON				dbgSW=1;DBGLOG_FMT("\n--DBGLOG--START --\n");
+#define	DBGLOG_OFF			    DBGLOG_FMT("\n--DBGLOG--STOP --\n");dbgSW=0;
+#define	DBGLOG_FMT(fmt, ...)	if(dbgSW==1)printf("[%s:%s](%d) " fmt, __FILE__,__func__,__LINE__, ## __VA_ARGS__)
+#else
+#define DBGLOG_ON
+#define	DBGLOG_OFF
+#define	DBGLOG_FMT(fmt, ...)
+#endif
+
+extern unsigned int _f_boot_reg_read( unsigned long adr, const char *filename, const char *funcname, int lineno );
+extern void _f_boot_reg_write(unsigned long adr, unsigned int writedata, const char *filename, const char *funcname, int lineno );
+extern void _f_boot_reg_write8(unsigned long adr, unsigned char writedata, const char *filename, const char *funcname, int lineno );
+extern int _f_boot_eeprom_read(unsigned int offset, char *dat, const char *filename, const char *funcname, int lineno  );
+extern int _f_boot_eeprom_write(unsigned int offset, unsigned char wdat, const char *filename, const char *funcname, int lineno ) ;
+extern int _f_boot_cpld_read(unsigned int offset, char *dat, const char *filename, const char *funcname, int lineno  );
+extern int _f_boot_cpld_write(unsigned int offset, unsigned char wdat, const char *filename, const char *funcname, int lineno ) ;
+
+/* デバイスアクセス関数マクロ(ログ取得用にパラメータを付加	*/
+#define	f_boot_reg_read(adr)							_f_boot_reg_read(adr,__FILE__,__func__,__LINE__)
+#define	f_boot_reg_write(adr,dat)						_f_boot_reg_write(adr,dat,__FILE__,__func__,__LINE__)
+#define	f_boot_reg_write8(adr,dat)						_f_boot_reg_write8(adr,dat,__FILE__,__func__,__LINE__)
+#define	f_boot_eeprom_read(offset,dat)					_f_boot_eeprom_read(offset,dat,__FILE__,__func__,__LINE__)
+#define	f_boot_eeprom_write(offset,dat)					_f_boot_eeprom_write(offset,dat,__FILE__,__func__,__LINE__)
+#define	f_boot_cpld_read(offset,dat)					_f_boot_cpld_read(offset,dat,__FILE__,__func__,__LINE__)
+#define	f_boot_cpld_write(offset,dat)					_f_boot_cpld_write(offset,dat,__FILE__,__func__,__LINE__)
+
+#define D_BOOT_OK						0
+#define D_BOOT_NG						1
+
+/*************/
+/* SLC/1CHIP */
+/*************/
+
+/* REG */
+#define D_CPLD_REG_RSTFAC_1CHIP				0x61000032	/* リセット要因表示(1CHIP)			*/
+#define D_CPLD_REG_RSTFAC_SLC					0x61000090	/* リセット要因表示(SLC)			*/
+
+#define D_CPLD_REG_SELF_RST_CTRL_SLC			0x61000006	/* 自律リセット制御(SLC)				*/
+
+#define D_CPLD_REG_SELF_RST_CTRL_RST2_SLC		0x0002		/* RST2：CPRIリンク起動中にファイル更新が発生した際に、本ビットを”1”設定し自律リセット実行する。
+ 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	   ＊RST2はFPGA　Reconfigを伴うリセット。FPGAファイルを更新した場合は、本リセットを実行しない限り、FPGA回路は更新されない。*/
+ 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	   
+#define D_CPLD_REG_SELF_RST_CTRL_1CHIP			0x61000006	/* 自律リセット制御(1CHIP)				*/
+#define D_CPLD_REG_SELF_RST_CTRL_RST2_1CHIP	0x0002		/* RST2: FPGAファイル更新がある場合、本BITに’1’設定する。
+																ハードはりコンフィグモードに入る
+																(ZYNQ FPGAおよびKintex FPGAのコンフィグを伴うリセット)
+															   RST1: 未使用 (ファームのみの更新の場合、本BITに’1’設定する。FPGAリコンフィグを実施しない。)	*/
+#define	D_LED_REG_BUSY_1CHIP				0x6100003e	/* カードLED制御 (BSY) */
+#define	D_LED_REG_BUSY_LED_BSY_1CHIP		0x0002		/* LED_BSY[1:0] 00 : 消灯、	01 : 点灯、	10 : 点灯(周期0)*/
+#define	D_LED_REG_BUSY_SLC					0x600002f4	/* カードLED制御 (BSY) */
+#define	D_LED_REG_BUSY_LED_BSY_SLC			0x0001		/* LED_BSY:BSY時点灯設定 	00 : 消灯 / 01 : 点灯 / 10 : 点灯(周期0) / 11 : 点灯(周期1) */
+
+#define CPLD_WDT_CTL_1CHIP					0x610000B0	/* WDT制御 */
+#define CPLD_WDT_CTL_WDTC_1CHIP			0x0200		/* WDTC:WDTカウンタクリア	*/
+#define CPLD_WDT_CTL_WDTST_1CHIP			0x0100		/* WDTST:WDT更新			*/
+#define CPLD_WDT_CTL_WDTCNT_MSK_1CHIP		0x00ff		/* WDTCNT:WDTカウンタ		*/
+
+#define CPLD_WDT_MASK_1CHIP				0x610000B4	/* WDT停止マスク		*/
+#define CPLD_WDT_MASK_1CHIP_WDTMASK		0x8000		/* WDT停止マスク[bit0]		*/
+
+#define CPLD_WDT_CTL_SLC					0x6000010A	/* WDT制御 */
+#define CPLD_WDT_CTL_WDTC_SLC				0x0200		/* WDTC:WDTカウンタクリア	*/
+#define CPLD_WDT_CTL_WDTST_SLC			    0x0100		/* WDTST:WDT更新			*/
+#define CPLD_WDT_CTL_WDTCNT_MSK_SLC		    0x00ff		/* WDTCNT:WDTカウンタ		*/
+
+
+/* Zynq SLCR REBOOT_STATUS[0xf8000258] リセット要因ビット定義	*/
+#define	D_ZYNC_SLCR_REBOOT_STATUS_POR			0x00400000		/* bit22: Power ON Reset */
+#define	D_ZYNQ_SLCR_REBOOT_STATUS_POR_MASK		0x007F0000		/* bit22-16: Power ON との比較用 */
+#define	D_ZYNC_SLCR_REBOOT_STATUS_SRST_B		0x00200000		/* bit21: Software Reset */ 
+#define	D_ZYNQ_SLCR_REBOOT_STATUS_DBG_RST		0x00100000		/* bit20: Debug Reset(Not use)*/
+#define	D_ZYNQ_SLCR_REBOOT_STATUS_SLC_RST		0x00080000		/* bit19: SLC soft reset*/
+#define	D_ZYNQ_SLCR_REBOOT_STATUS_AWST1_RST		0x00040000		/* bit18: */
+#define	D_ZYNQ_SLCR_REBOOT_STATUS_AWST0_RST		0x00020000		/* bit17: */
+#define	D_ZYNQ_SLCR_REBOOT_STATUS_SWDT_RST		0x00010000		/* bit16: */
+#define	D_ZYNQ_SLCR_REBOOT_STATUS_CLEAR_MASK	0x007F0000		/* bit22-16:*/
+#define	D_ZYNQ_SLCR_REBOOT_STATUS_REBOOT_STATE	0xfe000000		/* bit31-25:*/
+
+/* REBOT_STATE領域設定値 */
+#define	D_REBOOT_STATE_BOOT_BUSY				0x80000000		/* bit31=1		*/
+#define	D_REBOOT_STATE_ROLLBACK					0x02000000		/* bit30:25=000001	*/
+#define	D_REBOOT_STATE_WDT						0x04000000		/* bit30:25=000010	*/
+#define	D_REBOOT_STATE_SRST						0x20000000		/* bit30:25=010000	*/
+#define	D_REBOOT_STATE_SOFT_RST					0x08000000		/* bit30:25=000100	*/
+#define D_REBOOT_STATE_MASK						0x27000000		/* bit30:25=010111 */
+#define D_REBOOT_STATE_L1_RST					0x20000000		/* bit29=1		*/
+
+
+//RRH-007 boot alpha)miyazaki ppcEOL chg end
+/* RRH-001 boot alpha)nakajima add start */
+/* MIO バンク */
+#define D_BOOT_MIO_DATA0_OUT		0xE000A040
+#define D_BOOT_MIO_DATA1_OUT		0xE000A044
+#define D_BOOT_MIO_DATA2_OUT		0xE000A048
+#define D_BOOT_MIO_DATA3_OUT		0xE000A04C
+#define D_BOOT_MIO_DATA0_IN			0xE000A060
+#define D_BOOT_MIO_DATA1_IN			0xE000A064
+#define D_BOOT_MIO_DATA2_IN			0xE000A068
+#define D_BOOT_MIO_DATA3_IN			0xE000A06C
+//RRH-007 boot alpha)miyazaki ppcEOL del
+#define D_BOOT_SELECT_START_SIDE	0x00000020
+#define D_BOOT_EEPROM_PROTECT		0x00001000	
+#define D_BOOT_START_SIDE_TXFPGA	0x00010000
+#define D_BOOT_START_SIDE			0x00000200
+
+/* MIO/EMIO BaseAddress  */
+/* 5G-DU PROTO STRAT */
+//#define D_BOOT_GPIO_BASEADD		0xE000A000
+#define D_BOOT_GPIO_BASEADD		0xFF0A0000
+
+#define D_BOOT_PL_RESET			0x0000002C
+#define D_BOOT_DIR				0x00000344
+#define D_BOOT_OEN				0x00000348
+#define D_BOOT_EEP_WRI_PROTECT	0x00000044		/* EEPROM WRITE PROTECT Addr	*/
+/* 5G-DU PROTO END */
+// MIO
+#define D_BOOT_DIRM_0			0x00000204
+#define D_BOOT_OEN_0			0x00000208
+#define D_BOOT_INT_EN_0			0x00000210
+#define D_BOOT_INT_DIS_0		0x00000214
+#define D_BOOT_INT_STATUS_0		0x00000218
+#define D_BOOT_INT_TYPE_0		0x0000021C
+#define D_BOOT_INT_POLARITY_0	0x00000220
+#define D_BOOT_INT_ON_ANY_0		0x00000224
+#define D_BOOT_DIRM_1			0x00000244
+#define D_BOOT_DATA_1			0x00000044
+#define D_BOOT_OEN_1			0x00000248
+#define D_BOOT_INT_TYPE_1		0x0000025C
+#define D_BOOT_INT_POLARITY_1	0x00000260
+#define D_BOOT_INT_ON_ANY_1		0x00000264
+#define D_BOOT_INT_EN_1			0x00000250
+#define D_BOOT_INT_DIS_1		0x00000254
+#define D_BOOT_INT_STAT_1		0x00000258
+
+// EMIO
+#define D_BOOT_DIRM_2			0x00000284
+#define D_BOOT_OEN_2			0x00000288
+#define D_BOOT_INT_EN_2			0x00000290
+#define D_BOOT_INT_DIS_2		0x00000294
+#define D_BOOT_INT_STAT_2		0x00000298
+#define D_BOOT_INT_TYPE_2		0x0000029C
+#define D_BOOT_INT_POLARITY_2	0x000002A0
+#define D_BOOT_INT_ANY_2		0x000002A4
+#define D_BOOT_DIRM_3			0x000002C4
+#define D_BOOT_OEN_3			0x000002C8
+#define D_BOOT_INT_EN_3			0x000002D0
+#define D_BOOT_INT_DIS_3		0x000002D4
+#define D_BOOT_INT_STAT_3		0x000002D8
+#define D_BOOT_INT_TYPE_3		0x000002DC
+#define D_BOOT_INT_POL_3		0x000002E0
+#define D_BOOT_INT_ON_ANY_3		0x000002E4
+
+/* MIO/EMIO 設定値  */
+// MIO
+#define D_BOOT_NUM_DATA_0			0xFFFFFFFF
+#define D_BOOT_NUM_DIRM_0			0x00000080
+#define D_BOOT_NUM_OEN_0			0x00000080
+#define D_BOOT_NUM_INT_TYPE_0		0x80000000
+#define D_BOOT_NUM_INT_POLARITY_0	0x80000000
+#define D_BOOT_NUM_INT_ON_ANY_0		0x00000000
+#define D_BOOT_NUM_INT_STATUS_0		0xFFFFFFFF
+#define D_BOOT_NUM_INT_EN_0			0x80000000
+#define D_BOOT_NUM_INT_DIS_0		0x7FFFFFFF
+#define D_BOOT_NUM_DATA_1			0xFFFFFFFF
+#define D_BOOT_NUM_DIRM_1			0x00001020	//RRH-007 boot alpha)samejid ppcEOL chg
+#define D_BOOT_NUM_OEN_1			0x00001020	//RRH-007 boot alpha)samejid ppcEOL chg
+#define D_BOOT_NUM_INT_TYPE_1		0x0000000F
+#define D_BOOT_NUM_INT_POLARITY_1	0x0000000F
+#define D_BOOT_NUM_INT_ON_ANY_1		0x00000000
+#define D_BOOT_NUM_INT_STAT_1		0xFFFFFFFF
+#define D_BOOT_NUM_INT_EN_1			0x0000000F
+#define D_BOOT_NUM_INT_DIS_1		0x003FFFF0
+
+// EMIO
+#define D_BOOT_NUM_DIRM_2			0x00000000
+#define D_BOOT_NUM_OEN_2			0x00000000
+#define D_BOOT_NUM_INT_TYPE_2		0x00000010
+#define D_BOOT_NUM_INT_POLARITY_2	0x00000010
+#define D_BOOT_NUM_INT_ANY_2		0x00000000
+#define D_BOOT_NUM_INT_STAT_2		0xFFFFFFFF
+#define D_BOOT_NUM_INT_EN_2			0x00000010
+#define D_BOOT_NUM_INT_DIS_2		0xFFFFFFEF
+#define D_BOOT_NUM_DATA_3			0x00000000
+#define D_BOOT_NUM_DIRM_3			0x3FF00000 //RRH-007 boot alpha)samejid ppcEOL chg
+#define D_BOOT_NUM_OEN_3			0x3FF00000 //RRH-007 boot alpha)samejid ppcEOL chg
+#define D_BOOT_NUM_INT_TYPE_3		0x00000008
+#define D_BOOT_NUM_INT_POLARITY_3	0x00000008
+#define D_BOOT_NUM_INT_ANY_3		0x00000000
+#define D_BOOT_NUM_INT_STAT_3		0xFFFFFFFF
+#define D_BOOT_NUM_INT_EN_3			0x00000008
+#define D_BOOT_NUM_INT_DIS_3		0xFFFFFFF7
+/* RRH-001 boot alpha)nakajima add end */
+
+// SLCR
+#define ZYNQ_SLCR_SLCR_LOCK    (0xF8000004)
+#define ZYNQ_SLCR_SLCR_UNLOCK  (0xF8000008)
+#define ZYNQ_SLCR_SPI_CLK_CTRL (0xF8000158)
+#define ZYNQ_SLCR_PSS_RST_CTRL (0xF8000200)
+/* 5G-DU PROTO START */
+//#define ZYNQ_SLCR_FPGA_RST_CTRL	(0xF8000240)
+#define ZYNQ_SLCR_FPGA_RST_CTRL	(0xFF0A0054)
+/* 5G-DU PROTO END */
+#define ZYNQ_SLCR_A9_CPU_RST_CTRL (0xF8000244)
+#define ZYNQ_SLCR_REBOOT_STATUS (0xF8000258)
+#define ZYNQ_SLCR_LVL_SHFTR_EN (0xF8000900)
+/* 5G-DU PROTO START */
+//#define ZYNQ_SLCR_FPGA_RST_NUM	(0x0000000E)
+#define ZYNQ_SLCR_FPGA_RST_NUM	(0x80000000)
+/* 5G-DU PROTO END */
+#define ZYNQ_SLCR_LQSPI_CLK_CTRL   (0xF800014C)
+// SPI
+#define ZYNQ_SPI0_OFFSET       (0xE0006000)
+#define ZYNQ_SPI1_OFFSET       (0xE0007000)
+
+/*	FLASH EOL対応 add start	*/
+// QSPI
+#define CPU_QSPI_SRR           (0x40020040)
+#define CPU_QSPI_SPICR         (0x40020060)
+#define CPU_QSPI_SPISSR        (0x40020070)
+/*	FLASH EOL対応 add end	*/
+
+#define ZYNQ_SPI_CONFIG        (0x00000000)
+#define ZYNQ_SPI_INTR_STATUS   (0x00000004)
+#define ZYNQ_SPI_INTRPT_EN     (0x00000008)
+#define ZYNQ_SPI_EN            (0x00000014)
+#define ZYNQ_SPI_TX_DATA       (0x0000001C)
+#define ZYNQ_SPI_RX_DATA       (0x00000020)
+
+// SWDT
+#define ZYNQ_SWDT_MODE         (0xF8005000)
+#define ZYNQ_SWDT_CONTROL      (0xF8005004)
+#define ZYNQ_SWDT_RESTART      (0xF8005008)
+#define ZYNQ_SWDT_STATUS       (0xF800500C)
+#define ZYNQ_SWDT_MODE_ZKEY    (0x00ABC000)
+
+
+// DEVCFG
+#define ZYNQ_DEVCFG_CTRL       (0xF8007000)
+#define ZYNQ_DEVCFG_INT_STS    (0xF800700C)
+#define ZYNQ_DEVCFG_STATUS     (0xF8007014)
+#define ZYNQ_DEVCFG_MCTRL      (0xF8007080)
+#define ZYNQ_DEVCFG_DMA_SRC_ADDR   (0xF8007018)
+#define ZYNQ_DEVCFG_DMA_DST_ADDR   (0xF800701C)
+#define ZYNQ_DEVCFG_DMA_SRC_LEN    (0xF8007020)
+#define ZYNQ_DEVCFG_DMA_DEST_LEN   (0xF8007024)
+
+// QSPI
+#define ZYNQ_QSPI_CONFIG_REG       (0xE000D000)
+#define ZYNQ_QSPI_EN_REG           (0xE000D014)
+#define ZYNQ_QSPI_LQSPI_CFG        (0xE000D0A0)
+//RRH-007 boot alpha)miyazaki ppcEOL add start
+#define ZYNQ_QSPI_LQSPI_CFG_UPAGE  (0x10000000)
+#define ZYNQ_QSPI_INTR_STATUS_REG  (0xE000D004)
+#define ZYNQ_QSPI_TXD0             (0xE000D01C)
+#define ZYNQ_QSPI_RX_DATA_REG      (0xE000D020)
+//RRH-007 boot alpha)miyazaki ppcEOL add end
+#define ZYNQ_QSPI_0014             (0xFF0F0014)
+#define ZYNQ_QSPI_0100             (0xFF0F0100)
+#define ZYNQ_QSPI_0104             (0xFF0F0104)
+#define ZYNQ_QSPI_0114             (0xFF0F0114)
+#define ZYNQ_QSPI_0120             (0xFF0F0120)
+#define ZYNQ_QSPI_0140             (0xFF0F0140)
+#define ZYNQ_QSPI_0144             (0xFF0F0144)
+
+#define SLCR_UNLOCK_CODE  (0x0000DF0D)
+#define SLCR_LOCK_CODE    (0x0000767B)
+
+#define LVL_SHFTR_PLOFF   (0x0000000A)
+#define LVL_SHFTR_PLON    (0x0000000F)
+
+// DEVCFG_CTRL bit
+#define PCFG_PROG_B_BIT   (0x40000000)
+#define PCFG_POR_CNT_4K_BIT   (0x20000000)
+#define PCAP_PR_BIT       (0x08000000)
+#define PCAP_MODE_BIT     (0x04000000)
+
+// DEVCFG_INT_STS bit
+#define PCFG_DONE_INT_BIT   (0x00000004)
+// DEVCFG_INT_STS bit
+#define D_P_DONE_INT_BIT   (0x00001000)
+// DEVCFG_INT_STS bit
+#define PL_CONFIG_CHECK_BIT   (PCFG_DONE_INT_BIT | D_P_DONE_INT_BIT)
+
+// DEVCFG_STATUS bit
+#define PSS_CFG_RESET_B_BIT   (0x00000020)
+#define PCFG_INIT_BIT     (0x00000010)
+
+// DEVCFG_MCTRL bit
+#define PCFG_POR_B_BIT        (0x00000100)
+#define INT_PCAP_LPBK_BIT     (0x00000010)
+
+
+
+// QSPI_CONFIG_REG bit
+#define MAN_START_EN_BIT      (0x00008000)
+#define MANUAL_CS_BIT         (0x00004000)
+#define PCS_BIT               (0x00000400)
+#define CLK_PH_BIT            (0x00000004)
+#define CLK_POL_BIT           (0x00000002)
+
+// QSPI_EN_REG bit
+#define SPI_EN_BIT            (0x00000001)
+
+// QSPI_LQSPI_CFG micron設定?
+#define SET_MICRON_READ_0                 (0x80000003)
+#define SET_MICRON_READ_1                 (0x90000003)
+#define SET_MICRON_QUAD_OUT_FAST_READ_0   (0xC000016B)
+#define SET_MICRON_QUAD_OUT_FAST_READ_1   (0xC000016B)
+
+/*	FLASH EOL対応 add start	*/
+// QSPI Manufacture ID
+#define QSPI_MICRON_ID                 (0x20)
+#define QSPI_MACRONIX_ID               (0xC2)
+/*	FLASH EOL対応 add end	*/
+
+// PL config(仮)
+#define PL_SRC_ADDR       (0xFC100000)
+#define PL_DST_ADDR       (0xFFFFFFFF)
+#define PL_DATA_LEN       (0x00280000)
+
+/* 5G-DU PROTO START */
+// LLB FPGA
+#define LLB_CTB_CFG       (0xA0000600) //TRX FPGAコンフィグレーション
+
+#define CTB_CFG_CFGSIDE   (0x00000002) //TRX FPGA Config 面選択
+#define CTB_CFG_CFGSTRT   (0x00000001) //TRX FPGA Config 開始
+
+/* 5G-DU PROTO END */
+
+ int cmd_spif_read(unsigned long bus, unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len);
+ int cmd_spif_write(unsigned long bus, unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len);
+ int cmd_spif_erase(unsigned long bus, unsigned long cs, unsigned long add, unsigned long len);
+ int cmd_spif_cmp(unsigned long add1, unsigned long add2, unsigned long len);
+ int cmd_spif_swap(unsigned long add1, unsigned long add2, unsigned long len);
+ int cmd_spif_copy(unsigned long add1, unsigned long add2, unsigned long len);
+//RRH-007 boot alpha)miyazaki ppcEOL chg start
+extern int do_spi_flash_probe_rrh_ext(unsigned int cs);
+extern INT zynq_rrh_start (int set_no, UINT side);
+//RRH-007 boot alpha)miyazaki ppcEOL chg start
+extern void zynq_qspi_liner (unsigned long set_no);
+extern int cmd_rrh_fc (ulong cp_param[]);
+extern int cmd_rrh_fe (ulong cp_param[]);
+/* RRH-001 boot alpha)nakajima add start */
+extern int init_QSPI_SPI_clock(void);
+extern void zynq_qspi_io(void);
+/* RRH-001 boot alpha)nakajima add end */
+extern int cmd_plqspif_read( unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len);
+extern int cmd_plqspif_write(unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len);
+extern int cmd_plqspif_erase(unsigned long cs, unsigned long add, unsigned long len);
+extern int rrh_eeprom_write( unsigned long addr, unsigned char byte);
+extern int rrh_eeprom_read2( unsigned long addr, unsigned long length);
+extern int rrh_eeprom_read( unsigned long addr, unsigned long length);
+extern int rrh_cpld_write( unsigned long addr, unsigned char byte);
+extern int rrh_cpld_read( unsigned long addr, unsigned long length);
+extern int rrh_pl_qspi_read( unsigned long addr, unsigned long length);
+extern int rrh_pl_qspi_erase( unsigned long addr, unsigned long length);
+extern unsigned long rrh_flash_addr(unsigned long param_top , unsigned long eep_read_data);
+/*	FLASH EOL対応 add start	*/
+extern int cmd_rrh_wtst(void);
+extern unsigned int qspiFlashId;
+//extern void f_boot_flag_status_reg_read();
+/*	FLASH EOL対応 add end	*/
+extern int cmd_rrh_ver(void);
+extern int cmd_rrh_reset(int kind);
+
+//#endif	/* RRH_DPDC */
+
+
+//EXTERNED
+//20130329sami extern void kddi2g_rrh_start(void);
+extern void apd_init(void);
+extern void REG_initialize(void);
+
+//TXVATT
+extern void Fn_TxVATTset(unsigned short antnum, unsigned long setval);
+
+//RXVATT
+extern void Fn_RxVATTset(unsigned short antnum, unsigned long setval);
+
+//RxVGA
+extern void Fn_RxVGAset(void);
+//FBADC
+extern void set_FBADC(void);	//20130328sami voidが抜けていた warning対策
+extern int Fn_FBADCWRITE(unsigned short fbadd, unsigned short fbdata, unsigned short setno);
+extern unsigned long Fn_FBADCREAD(unsigned short fbadd, unsigned short setno);
+//FWDAC
+extern void Fn_FwDACset(void);
+extern void Fn_FwDACsetInd(unsigned long antnum, unsigned long ad, unsigned long dt);
+extern unsigned long Fn_FwDACreadInd(unsigned long antnum, unsigned long ad);
+//RXADC
+extern void set_RXADC(unsigned short setno);
+extern unsigned long Fn_RXADC_read(unsigned long ad, unsigned short setno);
+extern void Fn_RXADC_write(unsigned short rxadd, unsigned short rxdata, unsigned short setno);
+extern int Fn_RXADCWRITE(unsigned short rxadd, unsigned short rxdata, unsigned short setno);
+//TXPLL　RXPLL
+extern void Fn_TxPLLset(void);
+extern void Fn_TxPLL_write(int br, unsigned long add, unsigned long data);
+extern void Fn_FBPLLset(void);
+extern void Fn_FBPLL_write(int br, unsigned long add, unsigned long data);
+extern void Fn_RxPLLset(void);
+extern void Fn_RxPLL_write(int br, unsigned long add, unsigned long data);
+//PA-DAC
+extern void Fn_PAVGset(unsigned short antnum, unsigned short setval);
+extern void Fn_InitPAbias(unsigned short antnum);
+extern void Fn_SetPA(void);
+extern void Fn_InitPaVGAset(void);	// 20130314sami
+
+//PG-DAC
+extern void Fn_PGDAC_set(void);
+extern void Fn_PGDAC_PaON_Set(int br);
+extern void Fn_PGVGset(int br, unsigned short setval);
+
+//I2C
+extern int CPUI2C_BusyCheck(void);
+extern int Fn_I2C_WRITE(unsigned short add, unsigned short data, unsigned short div,unsigned short bit_mode);
+extern int Fn_I2C_READ(unsigned short add, unsigned short* p_data,  unsigned short div,unsigned short bit_mode);
+extern int Fn_LTC_SelectWrite(unsigned short mode);
+extern int Fn_LTC_SelectRead(unsigned short mode,  unsigned short* p_data);
+extern int Fn_OPT_SelectRead(unsigned short mode);
+extern unsigned short Fn_RfPld_Read(unsigned short w_add);				 //20130327sami
+extern int Fn_RfPld_Write(unsigned short w_add, unsigned short setval); //20130327sami
+
+//E2P
+extern void Update_TX0param(void);
+extern void Update_TX1param(void);
+extern void Update_TX2param(void);		//20130408 kenji
+extern void Update_TX3param(void);		//20130408 kenji
+extern void Update_RXparam(void);		//20130408 kenji
+extern int Fn_SaveToEep(unsigned short st_ivcadd,unsigned short st_add,unsigned short len);
+extern unsigned short Fn_LoadFromEep(unsigned short st_add,unsigned short len,unsigned short addcrc);
+extern void Get_AddCrc(unsigned short dat, unsigned short* p_crc);
+extern void Init_TxParam(void);
+extern void Init_RxParam(void);
+extern void InitParam_DBG(void);	//DBG用
+
+extern int Fn_GPPO_E2PWrite(unsigned short w_add, unsigned short w_data);
+extern unsigned long Fn_GPPO_E2PRead(unsigned short w_add);
+extern void Fn_I2C_E2PWrite(unsigned short w_add, unsigned short setval);
+extern void Fn_I2C_E2PRead(unsigned short r_add);
+
+
+
+#define REG_08(n)   ((volatile unsigned char* )( n )) //08bit
+#define REG(n)      ((volatile unsigned short*)( n )) //16bit
+#define REG_16(n)   ((volatile unsigned short*)( n )) //16bit
+#define REG_32(n)   ((volatile unsigned int*  )( n )) //32bit
+#define REG_64(n)   ((volatile unsigned long* )( n )) //64bit
+
+#endif	/* __35G_COMMON_H_ */
--- a/common/Makefile	2018-03-12 18:09:01.306134225 +0900
+++ b/common/Makefile	2018-03-08 11:10:17.849535700 +0900
@@ -178,4 +178,10 @@ obj-y += command.o
 obj-y += s_record.o
 obj-y += xyzModem.o
 
+# rrh TP command
+obj-y += rrh_cmd_s3g.o
+obj-y += rrh_cmd_sf.o
+obj-y += rrh_cmd_spi.o
+obj-y += f_boot_dev_access.o
+
 CFLAGS_env_embedded.o := -Wa,--no-warn -DENV_CRC=$(shell tools/envcrc 2>/dev/null)
--- a/common/f_boot_dev_access.c	1970-01-01 09:00:00.000000000 +0900
+++ b/common/f_boot_dev_access.c	2018-04-10 17:38:41.046027600 +0900
@@ -0,0 +1,351 @@
+/*
+ * boot用デバイスアクセス用関数群
+ *
+ */
+#include "35G_common.h"
+
+
+/****************************************************************************************************/
+/*!
+ * @brief 関数機能概要:レジスタ読み込み処理
+ * @note  関数処理内容.
+ *       -# 指定アドレスのレジスタから値を読み込み返却する
+ *
+ * @param  unsigned int	adr			読み込みアドレス
+ *
+ * @return unsigned int				読み込みデータ
+ * @retval 
+ *
+ * @date 2015/04/10 RRH-001 boot alpha)miyazaki  Create
+ *
+ ****************************************************************************************************/
+unsigned int _f_boot_reg_read( unsigned long adr, const char *filename, const char *funcname, int lineno ) 
+{
+
+	unsigned int readdat;
+
+	readdat = *REG_32(adr) ;
+
+DBGLOG_FMT("*reg_read  adr:%08x readdata :%08x from [%s,%s](%d)\n", adr, readdat, filename, funcname, lineno ) ;
+	return readdat;
+}
+
+/****************************************************************************************************/
+/*!
+ * @brief 関数機能概要:レジスタ書き込み処理
+ * @note  関数処理内容.
+ *       -# 指定アドレスのレジスタへ値を書き込む
+ *
+ * @param  unsignd int		adr		書込み先アドレス
+ * @param  unsignd int		data	書込みデータ
+ *
+ * @return void
+ * @retval -
+ *
+ * @date 2015/04/10 RRH-001 boot alpha)miyazaki  Create
+ *
+ ****************************************************************************************************/
+void _f_boot_reg_write(unsigned long adr, unsigned int writedata, const char *filename, const char *funcname, int lineno ) {
+
+DBGLOG_FMT("*reg_write adr:%08x writedata:%08x from [%s,%s](%d)\n", adr, writedata,filename, funcname, lineno );
+	*REG_32(adr) = writedata ;
+}
+
+/****************************************************************************************************/
+/*!
+ * @brief 関数機能概要:レジスタ書き込み処理
+ * @note  関数処理内容.
+ *       -# 指定アドレスのレジスタへ値を書き込む(8bit版)
+ *
+ * @param  unsignd int		adr		書込み先アドレス
+ * @param  unsignd int		data	書込みデータ
+ *
+ * @return void
+ * @retval -
+ *
+ * @date 2015/04/10 RRH-001 boot alpha)miyazaki  Create
+ *
+ ****************************************************************************************************/
+void _f_boot_reg_write8(unsigned long adr, unsigned char writedata, const char *filename, const char *funcname, int lineno ) {
+
+DBGLOG_FMT("*reg_write8 adr:%08x writedata:%02x from [%s,%s](%d)\n", adr, writedata,filename, funcname, lineno );
+	*REG_08(adr) = writedata ;
+}
+
+
+
+/****************************************************************************************************/
+/*!
+ * @brief 関数機能概要:EEPROM I2Cページ計算
+ * @note  関数処理内容.
+ *       -# eepromのオフセットからi2cのchip指定を計算する。
+ *
+ * @param  unsigned int		offset		読み込み先頭アドレス
+ * @return char							読み込みデータ
+ * @retval 
+ *
+ * @date 2015/04/10 RRH-001 boot alpha)miyazaki  Create
+ *
+ ****************************************************************************************************/
+int calc_eep_page( unsigned int ioffset,  unsigned int *chip, unsigned int *ooffset ) {
+	if( ioffset >= 0x800 ) {
+		printf("Error: invalid address.\n");
+		return D_BOOT_NG ;
+	}
+	*chip = 0x50 + ( ioffset / 0x100 ) ;
+    *ooffset = ioffset - ( ( *chip - 0x50 )  * 0x100 );
+	return  D_BOOT_OK;
+
+}
+/****************************************************************************************************/
+/*!
+ * @brief 関数機能概要:E2P読み込み
+ * @note  関数処理内容.
+ *       -# E2Pからデータを読み込む
+ *
+ * @param  unsigned int		offset		読み込み先頭アドレス
+ * @return char							読み込みデータ
+ * @retval 
+ *
+ * @date 2015/04/10 RRH-001 boot alpha)miyazaki  Create
+ *
+ ****************************************************************************************************/
+int _f_boot_eeprom_read(unsigned int offset, char *dat, const char *filename, const char *funcname, int lineno  )	{
+	UCHAR			readdat[3];
+	unsigned int    tmp_chip, tmp_offset ;	
+	UCHAR			chip = 0x50;
+	extern int i2c_read(UCHAR dev, UINT addr, INT alen, UCHAR *data, INT length);
+
+DBGLOG_FMT("*eeprom_read offset:0x%x dat:0x%02x from %s:%s(%d)\n", offset, (unsigned int)dat, filename, funcname, lineno );
+
+	if( calc_eep_page( offset, &tmp_chip, &tmp_offset ) == D_BOOT_NG ) {
+		return D_BOOT_NG;
+	}
+	chip = (UCHAR)tmp_chip;
+
+DBGLOG_FMT("** i2c_read(%x,%x,1,%x,2)\n", chip, tmp_offset, (unsigned int)readdat ) ;
+
+	if( 0 != i2c_read(chip, tmp_offset, 1, readdat, 2)) {
+		printf("Error: i2c read error.\n");
+		return D_BOOT_NG;
+	}
+DBGLOG_FMT("readdat[0]:%x [1]:%x\n", readdat[0], readdat[1] ) ;
+
+	*dat = readdat[0] ;	
+
+	return D_BOOT_OK;
+}
+
+/****************************************************************************************************/
+/*!
+ * @brief 関数機能概要:E2P書込み
+ * @note  関数処理内容.
+ *       -# E2Pへデータを書き込む
+ *
+ * @param  unsigned int		offset		書込み先頭アドレス
+ * @param  char							書込みデータ
+ * @return void
+ * @retval 
+ *
+ * @date 2015/04/10 RRH-001 boot alpha)miyazaki  Create
+ *
+ ****************************************************************************************************/
+int  _f_boot_eeprom_write(unsigned int offset, unsigned char wdat, const char *filename, const char *funcname, int lineno )	{
+
+	unsigned  int tmp_chip;
+	unsigned  int woffset ;
+	unsigned  int ret,data ;
+	int			retcd = D_BOOT_OK;
+	extern int i2c_write(UCHAR dev, UINT addr, INT alen, UCHAR *data, INT length);
+
+DBGLOG_FMT("*eeprom_write offset:0x%x dat:0x%02x from %s:%s(%d)\n", offset, wdat&0xff, filename, funcname, lineno );
+
+	if( calc_eep_page( offset, &tmp_chip, &woffset ) == D_BOOT_NG ) {
+		return D_BOOT_NG;
+	}
+	/* EEPROM WriteProtect OFF*/
+	data = f_boot_reg_read(D_BOOT_GPIO_BASEADD + D_BOOT_EEP_WRI_PROTECT);
+	data &= ~D_BOOT_EEPROM_PROTECT;
+	f_boot_reg_write(D_BOOT_GPIO_BASEADD + D_BOOT_EEP_WRI_PROTECT, data);
+
+	DBGLOG_FMT("call i2c_write(%x, %x, 1, %x, 1 )\n", tmp_chip, woffset, wdat );
+	ret = i2c_write(tmp_chip, woffset, 1, &wdat, 1 ) ;
+	DBGLOG_FMT("i2c_write  ret:%d\n", ret ) ;
+	if( ret != 0 ) {
+		 retcd = D_BOOT_NG;
+	}
+
+	/* EEPROM WriteProtect ON*/
+	data = f_boot_reg_read(D_BOOT_GPIO_BASEADD + D_BOOT_EEP_WRI_PROTECT);
+	data |= D_BOOT_EEPROM_PROTECT;
+	f_boot_reg_write(D_BOOT_GPIO_BASEADD + D_BOOT_EEP_WRI_PROTECT, data);
+
+	return retcd;
+}
+
+#if 0
+
+/*
+ * Syntax:
+ *	i2c md {i2c_chip} {addr}{.0, .1, .2} {len}
+ */
+int rrh_eeprom_read(unsigned long param_top, unsigned long param_size)
+{
+	int				i;
+	int				line_top_pos	;	/* １行毎の先頭オフセット		*/
+	char			hexdmp[50] 	;
+	char			symdmp[20] 	;
+	char			cnvbuf[4]		;
+	char			readbuf[3]		;
+	int				read_pos		;
+	
+	/*
+	 * Print the lines.
+	 *
+	 * We buffer all read data, so we can make sure data is read only
+	 * once.
+	 */
+
+	DBGLOG_FMT("rrh_eeprom_read in  addr:%08x  length:%x(%d)\n", (UINT)param_top, (UINT)param_size, (int)param_size );
+
+	
+	/* 0x10 byte毎に読み込み、表示する */
+	/* addr : 読み込み開始アドレス */
+	/* length : 読み込みサイズ */
+	line_top_pos = ( param_top / 0x10 ) * 0x10 ;
+	read_pos	=	0;
+	DBGLOG_FMT("1st time line_top_pos : %08x\n", line_top_pos ) ;
+   	printf( "adr.  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f     0123456789abcdef\n" );
+	while(1) {
+
+		memset( hexdmp, 0, sizeof(hexdmp)) ;
+		memset( symdmp, 0, sizeof(symdmp)) ;
+		for( i = 0 ; i < 0x10 ; i++ ) {	/* １行分のサイズ	*/
+
+			if( ( line_top_pos + i ) < param_top ) {	/* 開始位置前の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " ");
+			}
+			else if( ( line_top_pos + i ) >= param_top + param_size ) {	/* 終了位置後の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " " );
+			}
+			else {		/* 以外*/
+			
+				/* EEPROMより１バイト読み込み */
+				if( f_boot_eeprom_read( param_top + read_pos, readbuf ) != D_BOOT_OK) {
+					break;
+				}
+
+
+				/* １６進表示変換		*/
+				sprintf( cnvbuf, "%02x ", (unsigned int)(readbuf[0]&0xff) ) ;
+				strcat( hexdmp, cnvbuf ) ;
+
+				/* ASCII表示変換(文字表示できる分のみASCII文字で表示	*/
+				if( readbuf[0] >= 0x20 && readbuf[0] <= 0x7e )  {
+					sprintf( cnvbuf, "%c", readbuf[0] );
+					strcat( symdmp, cnvbuf ) ;
+				}
+				else {
+					strcat( symdmp, "." ) ;	/* 表示不可能文字分 */
+				}
+				
+				read_pos++;
+			}
+		}
+		/* 表示 */
+		printf("%04x: %s  [%s]\n", line_top_pos, hexdmp, symdmp );
+		/* 次の為の更新 */
+		line_top_pos += 0x10 ;	/* */
+		
+		/* 終了判定 */
+		if( line_top_pos >= param_top + param_size || line_top_pos >= 0x800) {	/* 表示開始位置から表示サイズ分を超えた？ */
+			break;
+		}
+	
+	}
+	return 0;
+}
+
+
+/* Write (fill) memory
+ *
+ * Syntax:
+ *	i2c mw {i2c_chip} {addr}{.0, .1, .2} {data} [{count}]
+ */
+int rrh_eeprom_write( unsigned long addr,  unsigned char byte)
+{
+	int ret ;
+//	if (i2c_write(chip, addr, alen, &byte, 1) != 0)
+	ret = f_boot_eeprom_write(addr, byte ) ;
+	DBGLOG_FMT("f_boot_eeprom_write ret:%d\n", ret ) ;
+	if( ret != D_BOOT_OK )	{
+		puts ("Error writing the chip.\n");
+	}
+	return (D_BOOT_OK);
+}
+
+#endif
+
+/****************************************************************************************************/
+/*!
+ * @brief 関数機能概要:CPLD読み込み
+ * @note  関数処理内容.
+ *       -# CPLDからデータを読み込む
+ *
+ * @param  unsigned int		offset		読み込み先頭アドレス
+ * @return char							読み込みデータ
+ * @retval 
+ *
+ * @date 2018/04/01  KCN)kurosu  Create
+ *
+ ****************************************************************************************************/
+int _f_boot_cpld_read(unsigned int offset, char *dat, const char *filename, const char *funcname, int lineno  )	{
+	UCHAR			readdat[3];
+	UCHAR			chip = 0x70;
+	extern int i2c_read(UCHAR dev, UINT addr, INT alen, UCHAR *data, INT length);
+
+DBGLOG_FMT("*cpld_read offset:0x%x dat:0x%02x from %s:%s(%d)\n", offset, (unsigned int)dat, filename, funcname, lineno );
+	if( 0 != i2c_read(chip, offset, 1, readdat, 2)) {
+		printf("Error: i2c read error.\n");
+		return D_BOOT_NG;
+	}
+DBGLOG_FMT("readdat[0]:%x [1]:%x\n", readdat[0], readdat[1] ) ;
+
+	*dat = readdat[0] ;	
+
+	return D_BOOT_OK;
+}
+
+/****************************************************************************************************/
+/*!
+ * @brief 関数機能概要:CPLD書込み
+ * @note  関数処理内容.
+ *       -# CPLDへデータを書き込む
+ *
+ * @param  unsigned int		offset		書込み先頭アドレス
+ * @param  char							書込みデータ
+ * @return void
+ * @retval 
+ *
+ * @date 2018/04/01  KCN)kurosu  Create
+ *
+ ****************************************************************************************************/
+int  _f_boot_cpld_write(unsigned int offset, unsigned char wdat, const char *filename, const char *funcname, int lineno )	{
+
+	UCHAR		chip = 0x70;
+	unsigned  int  ret ;
+	int			retcd = D_BOOT_OK;
+	extern int i2c_write(UCHAR dev, UINT addr, INT alen, UCHAR *data, INT length);
+
+DBGLOG_FMT("*cpld_write offset:0x%x dat:0x%02x from %s:%s(%d)\n", offset, wdat&0xff, filename, funcname, lineno );
+	ret = i2c_write(chip, offset, 1, &wdat, 1 ) ;
+	DBGLOG_FMT("i2c_write  ret:%d\n", ret ) ;
+	if( ret != 0 ) {
+		printf("Error: i2c write error.\n");
+		retcd = D_BOOT_NG;
+	}
+	return retcd;
+}
+
--- a/common/main.c	2018-03-12 18:09:01.310134225 +0900
+++ b/common/main.c	2018-06-04 10:48:59.358509100 +0900
@@ -12,6 +12,9 @@
 #include <cli.h>
 #include <console.h>
 #include <version.h>
+#include "35G_common.h"
+
+extern int xilinx_fpga_cfg_done;
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -44,6 +47,8 @@ static void run_preboot_environment_comm
 void main_loop(void)
 {
 	const char *s;
+	char e2p;
+	UINT tmpVal;
 
 	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");
 
@@ -51,19 +56,66 @@ void main_loop(void)
 	setenv("ver", version_string);  /* set version variable */
 #endif /* CONFIG_VERSION_VARIABLE */
 
+	/* I2C CLK速度初期設定 TBD（Device Treeで対応予定)	*/
+
+	/* 装置種別判定 TBD	*/
+
+	/* GPIO初期設定	*/
+	f_boot_reg_write(D_BOOT_GPIO_BASEADD + D_BOOT_DIR, 	D_BOOT_NUM_DATA_0);
+	f_boot_reg_write(D_BOOT_GPIO_BASEADD + D_BOOT_OEN, 	D_BOOT_NUM_DATA_0);
+	
+	/* EEPROM writeプロテクト解除 */
+	tmpVal = f_boot_reg_read(D_BOOT_GPIO_BASEADD + D_BOOT_DIRM_1);
+	tmpVal |= 0x00001000;
+	f_boot_reg_write(D_BOOT_GPIO_BASEADD + D_BOOT_DIRM_1, 	tmpVal);
+	tmpVal = f_boot_reg_read(D_BOOT_GPIO_BASEADD + D_BOOT_OEN_1);
+	tmpVal |= 0x00001000;
+	f_boot_reg_write(D_BOOT_GPIO_BASEADD + D_BOOT_OEN_1, 	tmpVal);
+	
+	/* 起動面判定 TBD	*/
+
+	f_boot_eeprom_read(0x50,&e2p);
+
 	cli_init();
 
+	/* FPGA(PL)コンフィレーション 
+	   ３末はprebootコマンドで実行	*/
 	run_preboot_environment_command();
 
+	if(xilinx_fpga_cfg_done != 0){
+	/* FPGA起動OKの場合	*/
+	/* PLリセット解除	*/
+	//	f_boot_reg_write(ZYNQ_SLCR_FPGA_RST_CTRL, 	ZYNQ_SLCR_FPGA_RST_NUM );
+	
+		/* TRXボード有無確認 TBD	*/
+	
+		/* TRXボード無は何もしないで抜ける	*/
+
+#if 1
+		/* TRXボード有はTRX-FPGAのConfigを実施	*/
+		/* Config面は0固定とする*/
+		mdelay(100); /* 100ms wait */
+		tmpVal = f_boot_reg_read(LLB_CTB_CFG);
+		if(e2p == 0) {
+			tmpVal &= ~(CTB_CFG_CFGSIDE);
+		}
+		else{
+			tmpVal |= CTB_CFG_CFGSIDE ;
+		}
+		tmpVal |= CTB_CFG_CFGSTRT;
+		f_boot_reg_write(LLB_CTB_CFG, tmpVal);
+#endif
+
 #if defined(CONFIG_UPDATE_TFTP)
-	update_tftp(0UL, NULL, NULL);
+		update_tftp(0UL, NULL, NULL);
 #endif /* CONFIG_UPDATE_TFTP */
 
-	s = bootdelay_process();
-	if (cli_process_fdt(&s))
-		cli_secure_boot_cmd(s);
+		s = bootdelay_process();
+		if (cli_process_fdt(&s))
+			cli_secure_boot_cmd(s);
 
-	autoboot_command(s);
+		autoboot_command(s);
+	}
 
 	cli_loop();
 	panic("No CLI available");
--- a/common/rrh_cmd_s3g.c	1970-01-01 09:00:00.000000000 +0900
+++ b/common/rrh_cmd_s3g.c	2018-06-04 10:48:59.254198000 +0900
@@ -0,0 +1,548 @@
+#include <common.h>
+#include <command.h>
+#include <configs/zynq_zc70x.h>
+#include <environment.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <asm/byteorder.h>
+#include <version.h>
+
+#define RRH_DPDC 0
+
+#ifdef RRH_DPDC //---------------------------------------------
+#include <35G_common.h>
+
+#define DISP_LINE_LEN	16
+
+typedef union {
+    unsigned char c;
+    unsigned short w;
+    unsigned long l;
+    unsigned long long ll;
+} cfiword_t;
+
+
+#define CTP_CFG         (0xA0000600)
+
+
+//-----------------------------------------------------------------------
+// S3G用アクセスコマンド 呼び出し関数
+//-----------------------------------------------------------------------
+
+//RRH-007 boot alpha)miyazaki ppcEOL add add start
+void rrh_fc_usage(VOID) {
+	printf(	"\n"
+			"rrh - rrh     - RRH-DPDC\n"
+			"\n"
+			"\n"
+			"Usage:\n"
+			"rrh\n"
+			"  rrh -w      (add) (data)      : memory write\n"
+			"  rrh -r      (add)             : memory read\n"
+			"  rrh -psew   (add) (data)      : EEPROM write \n"
+			"  rrh -pser   (add) (size)      : EEPROM read  \n"
+			"  rrh -pserall                  : EEPROM All read\n"
+			"  rrh -pserr  (add) (size)      : EEPROM read 2\n"
+			"  rrh -cw     (add) (data)      : CPLD write   \n"
+			"  rrh -cr     (add) (size)      : CPLD read    \n"
+			"  rrh -wtst                     : write status regster\n"
+			"  rrh -ver                      : Version read \n"
+			"  rrh -reset                    : Reset \n"
+			"  rrh -fe     (cs) (add) (size) : flash erase  \n"
+			"  rrh -fc d (num) 0             : flash copy\n"
+			"           [num]  :  copy item . following the list number use.\n"
+			"\n"
+	);
+/* RRH-00Z boot alpha)miyazaki tddZynq chg start */
+	
+	printf(	
+			"     0  : Side#0 Boot(Primary)(PS/QSPI  0x00000000 - )\n"
+			"     1  : Side#1 Boot(Primary)(PS/QSPI  0x08000000 - )\n"
+			"     2  : Side#0 Boot(Backup) (PS/QSPI  0x00100000 - )\n"
+			"     3  : Side#1 Boot(Backup) (PS/QSPI  0x08100000 - )\n"
+
+			"     10 : Side#0 OS+FIRM      (PS/QSPI  0x04C00000 - )\n"
+			"     11 : Side#1 OS+FIRM      (PS/QSPI  0x0CC00000 - )\n"
+
+			"     30 : Side#0A Zynq(PL)FPGA(PS/QSPI  0x00400000 - )\n"
+			"     31 : Side#1A Zynq(PL)FPGA(PS/QSPI  0x08400000 - )\n"
+			"     32 : Side#0B Zynq(PL)FPGA(PS/QSPI  0x02800000 - )\n"
+			"     33 : Side#1B Zynq(PL)FPGA(PS/QSPI  0x0A800000 - )\n"
+
+			"     70 : Side#0 SlaveFPGA    (PL/QSPI  0x00000000 - )\n"
+			"     71 : Side#1 SlaveFPGA    (PL/QSPI  0x02000000 - )\n"
+			"     72 : Side#2 SlaveFPGA    (PL/QSPI  0x04000000 - )\n"
+			"     73 : Side#3 SlaveFPGA    (PL/QSPI  0x06000000 - )\n"
+
+			"     80 : Side#0 RFIC boot    (PS/QSPI  0x06800000 - )\n"
+			"     81 : Side#1 RFIC boot    (PS/QSPI  0x0E800000 - )\n"
+
+			"     90 : Side#0 RFIC ARM     (PS/QSPI  0x06900000 - )\n"
+			"     91 : Side#1 RFIC ARM     (PS/QSPI  0x0E900000 - )\n"
+	);
+/* RRH-00Z boot alpha)miyazaki tddZynq chg end */
+}
+//RRH-007 boot alpha)miyazaki ppcEOL add add end
+
+/*
+ * 
+ */
+enum	E_REG_ACCESS_BIT {
+	E_REG_ACCESS_wrong,		/* アクセス不可		*/
+	E_REG_ACCESS_16bit,		/* 16bitアクセス	*/
+	E_REG_ACCESS_32bit		/* 32bitアクセス	*/
+}		;
+
+
+int do_cmd_s3g ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) {
+
+    int rcode = 0;
+    unsigned long cp_param[3];
+    unsigned long add,data;
+	int i ;
+//    int br;
+//    unsigned long setval;
+//    unsigned long setval0;
+//    unsigned long setval1;
+//    unsigned long setval2;
+//    unsigned long setval3;
+//    unsigned long setval4;
+//	unsigned long* p_data;
+
+    ulong tmp[5];
+//    int rx_num;
+    int offset;
+//   unsigned short usdat;
+//    unsigned short setno;
+
+	
+/*	FLASH EOL対応 chg start	*/
+    if (argc < 2) {
+        printf ("arg shortage!\nUsage:\n");
+        rrh_fc_usage();
+/*	FLASH EOL対応 chg end	*/
+        return 1;
+    }
+
+    // パラメータ 暫定数値変換
+    offset = 2;
+    for(i=0 ; i<5 ; i++){
+        if(i < argc - offset ){
+            tmp[i] = simple_strtoull (argv[offset +i], NULL, 16);
+        }else{
+            tmp[i] = 0;
+        }
+    }
+
+    if (strcmp(argv[1], "-w") == 0) {
+/*	FLASH EOL対応 chg start	*/
+		if (argc < 4) {
+			printf ("arg shortage!\nUsage:\n");
+			rrh_fc_usage();
+			return 1;
+		}
+/*	FLASH EOL対応 chg end	*/
+        add  = tmp[0];
+        data = tmp[1];
+        f_boot_reg_write(add, data);
+    	printf ("rrh -w add:%x data:%x write finish!!!\n", (UINT)add, (UINT)data);
+
+    } else if (strcmp(argv[1], "-64w") == 0) {
+		if (argc < 4) {
+			printf ("arg shortage!\nUsage:\n");
+			rrh_fc_usage();
+			return 1;
+		}
+        add  = tmp[0];
+        data = tmp[1];
+        *((volatile unsigned long* )( add )) = data;
+    	printf ("rrh -64w add:%x data:%x write finish!!!\n", (UINT)add, (UINT)data);
+    }else if (strcmp(argv[1], "-64r") == 0) {
+		if (argc < 3) {
+			printf ("arg shortage!\nUsage:\n");
+			rrh_fc_usage();
+			return 1;
+		}
+        add  = tmp[0];
+		data = *((volatile unsigned long* )( add ));
+		printf("%016llx\n", (ULLINT)data );
+
+    }else if (strcmp(argv[1], "-r") == 0) {
+/*	FLASH EOL対応 chg start	*/
+		if (argc < 3) {
+			printf ("arg shortage!\nUsage:\n");
+			rrh_fc_usage();
+			return 1;
+		}
+/*	FLASH EOL対応 chg end	*/
+        add  = tmp[0];
+		data = f_boot_reg_read( add);
+		printf("%08x\n",(UINT)data );
+		
+//    }else if (strcmp(argv[1], "-plconfig") == 0) {
+//        data  = simple_strtoul (argv[2], NULL, 16);
+//RRH-007 boot alpha)miyazaki ppcEOL add start
+//        zynq_rrh_start(data,  0 );
+//RRH-007 boot alpha)miyazaki ppcEOL add end
+    }else
+//    if (strcmp(argv[1], "-qspi_l") == 0) {
+//        zynq_qspi_liner(tmp[0]);
+//    }else
+    if (strcmp(argv[1], "-psew") == 0) {   // I2C経由E2P Write
+/*	FLASH EOL対応 chg start	*/
+		if (argc < 4) {
+			printf ("arg shortage!\nUsage:\n");
+			rrh_fc_usage();
+/*	FLASH EOL対応 chg end	*/
+			return 1;
+		}
+    	/* EEPROM全エリア書き換え対応 */
+    	if (strcmp(argv[2], "all") == 0) {
+			printf ("EEPROM WRITE ADDR:0");
+    		for (add = 0x000; add<=0x7FF; add++) {
+    			if (rrh_eeprom_write(add, tmp[1])) {
+    				printf ("add:%x write error\n", (UINT)add);
+    				return 1;
+    			}
+    			if (((add+1)% 0x100)==0) {
+    				printf (" - %x", (UINT)add);
+    			}
+    		}
+    		printf ("rrh -psew all data:%x write finish!!!\n", (UINT)tmp[1]);
+    	}else
+    	{
+			rrh_eeprom_write(tmp[0], tmp[1]);
+    		printf ("rrh -psew add:%x data:%x write finish!!!\n", (UINT)tmp[0], (UINT)tmp[1]);
+    	}
+    }else
+    if (strcmp(argv[1], "-pser") == 0) {   // I2C経由E2P Read
+/*	FLASH EOL対応 chg start	*/
+		if( (argc < 4) | (tmp[1] < 1) ) {
+			tmp[1] = 1;
+/*	FLASH EOL対応 chg end	*/
+		}
+		rrh_eeprom_read( tmp[0], tmp[1]);
+		
+    }else
+    if (strcmp(argv[1], "-pserall") == 0) {   // I2C経由E2P Read All
+		rrh_eeprom_read( 0x0, 0x7FF);   // 先頭から最大長読み出し
+    }else
+    if (strcmp(argv[1], "-pserr") == 0) {   // I2C経由E2P Read 2{
+		if( (argc < 4) | (tmp[1] < 1) ) {
+			tmp[1] = 1;
+		}
+		rcode = rrh_eeprom_read2( tmp[0], tmp[1]);
+	}else
+	if (strcmp(argv[1], "-fladd") == 0) {   // I2C経由E2P Flash Addr{
+		if( (argc < 4) | (tmp[1] < 1) ) {
+			tmp[1] = 1;
+		}
+		rcode = rrh_flash_addr( tmp[0], tmp[1]);
+	}else
+    if (strcmp(argv[1], "-cw") == 0) {   // I2C経由CPLD Write
+		if (argc < 4) {
+			printf ("arg shortage!\nUsage:\n");
+			rrh_fc_usage();
+			return 1;
+		}
+		rrh_cpld_write(tmp[0], tmp[1]);
+    	printf ("rrh -cw add:%x data:%x write finish!!!\n", (UINT)tmp[0], (UINT)tmp[1]);
+    }else
+    if (strcmp(argv[1], "-cr") == 0) {   // I2C経由CPLD Read
+		if( (argc < 4) | (tmp[1] < 1) ) {
+			tmp[1] = 1;
+		}
+		rrh_cpld_read( tmp[0], tmp[1]);
+   }else
+    if (strcmp(argv[1], "-fe") == 0) {
+    	cp_param[0] = tmp[0];
+        cp_param[1] = tmp[1];
+        cp_param[2] = tmp[2];
+		if (argc != 5) {
+			printf ("Usage:\n");
+			rrh_fc_usage() ;
+			return 1;
+		}
+
+        cmd_rrh_fe(cp_param);
+   }else
+//   if (strcmp(argv[1], "-gpew") == 0) {   // 汎用ポート経由E2P Write
+//        add  = tmp[0];
+//        data  = tmp[1];
+//		rx_num = Fn_GPPO_E2PWrite(add,data);
+//		if(rx_num != 0)	return 1;
+//		printf("add %04x : %04x \n",add,data);
+//   }else
+//   if (strcmp(argv[1], "-gper") == 0) {   // 汎用ポート経由E2P Read
+//        add  = tmp[0];
+//		rx_num = Fn_GPPO_E2PRead(add);
+//		if(rx_num == 0xFFFFFFFF)	return 1;
+//		printf("add %04x : %04x \n",add,rx_num);		
+//   }else
+    if (strcmp(argv[1], "-fc") == 0) {
+
+    	cp_param[0] = tmp[0];
+        cp_param[1] = tmp[1];
+        cp_param[2] = tmp[2];
+
+		if (argc != 5) {
+//RRH-007 boot alpha)miyazaki ppcEOL add  start
+			printf ("Usage:\n");
+			rrh_fc_usage() ;
+//RRH-007 boot alpha)miyazaki ppcEOL add  end
+			return 1;
+		}
+    	
+        cmd_rrh_fc(cp_param);
+
+        return rcode;
+
+    }
+    else if (strcmp(argv[1], "-ver") == 0)
+    {
+		cmd_rrh_ver();
+/*	FLASH EOL対応 add start	*/
+    }
+    else if (strcmp(argv[1], "-wtst") == 0)
+    {
+		cmd_rrh_wtst();
+/*	FLASH EOL対応 add end	*/
+    }else
+    if (strcmp(argv[1], "-reset") == 0) {
+		if(strcmp(argv[2], "ps") == 0) {
+			cmd_rrh_reset(1);
+		}else{
+			cmd_rrh_reset(0);
+		}
+   }else
+    if (strcmp(argv[1], "-frpl") == 0) {   // PL側フラッシュRead
+		if( (argc < 4) | (tmp[1] < 1) ) {
+			tmp[1] = 1;
+		}
+		rrh_pl_qspi_read( tmp[0], tmp[1]);
+    }else
+    if (strcmp(argv[1], "-fepl") == 0) {   // PL側フラッシュErase
+		if(argc != 4) {
+			printf ("Usage:\n");
+			rrh_fc_usage() ;
+			return 1;
+		}
+		rrh_pl_qspi_erase( tmp[0], tmp[1]);
+    }else
+    {
+        printf("Parameter Error !!!\n");
+/*	FLASH EOL対応 add start	*/
+		rrh_fc_usage() ;
+/*	FLASH EOL対応 add end	*/
+    }
+
+    return rcode;
+}
+
+U_BOOT_CMD(
+    rrh /*入力コマンド*/ , 7 /* パラメータ数*/ , 0/* repeat対応 */ , do_cmd_s3g /* 呼び出し関数名 */,
+    "rrh     - RRH-DPDC",
+    "\n"
+    //------------------------------------------------------------------------------------------------
+    "  rrh -w      (add) (data)      : memory write \n"
+    "  rrh -r      (add)             : memory read  \n"
+    "  rrh -psew   (add) (data)      : EEPROM write \n"
+    "  rrh -pser   (add) (size)      : EEPROM read  \n"
+    "  rrh -pserall                  : EEPROM All read\n"
+    "  rrh -cw     (add) (data)      : CPLD write   \n"
+    "  rrh -cr     (add) (size)      : CPLD read    \n"
+    "  rrh -wtst                     : write status regster\n"
+    "  rrh -ver                      : Version read \n"
+    "  rrh -reset                    : Reset \n"
+    "  rrh -fe     (cs) (add) (size) : flash erase  \n"
+    "  rrh -fc d (num) 0             : flash copy   \n"
+    "           [num]  :  copy item . following the list number use. \n"
+	"     0  : Side#0 Boot(Primary)(PS/QSPI  0x00000000 - )\n"
+	"     1  : Side#1 Boot(Primary)(PS/QSPI  0x08000000 - )\n"
+	"     2  : Side#0 Boot(Backup) (PS/QSPI  0x00100000 - )\n"
+	"     3  : Side#1 Boot(Backup) (PS/QSPI  0x08100000 - )\n"
+
+	"     10 : Side#0 OS+FIRM      (PS/QSPI  0x04C00000 - )\n"
+	"     11 : Side#1 OS+FIRM      (PS/QSPI  0x0CC00000 - )\n"
+
+	"     30 : Side#0A Zynq(PL)FPGA(PS/QSPI  0x00400000 - )\n"
+	"     31 : Side#1A Zynq(PL)FPGA(PS/QSPI  0x08400000 - )\n"
+	"     32 : Side#0B Zynq(PL)FPGA(PS/QSPI  0x02800000 - )\n"
+	"     33 : Side#1B Zynq(PL)FPGA(PS/QSPI  0x0A800000 - )\n"
+
+	"     70 : Side#0 SlaveFPGA    (PL/QSPI  0x00000000 - )\n"
+	"     71 : Side#1 SlaveFPGA    (PL/QSPI  0x02000000 - )\n"
+	"     72 : Side#2 SlaveFPGA    (PL/QSPI  0x04000000 - )\n"
+	"     73 : Side#3 SlaveFPGA    (PL/QSPI  0x06000000 - )\n"
+
+	"     80 : Side#0 RFIC boot    (PS/QSPI  0x06800000 - )\n"
+	"     81 : Side#1 RFIC boot    (PS/QSPI  0x0E800000 - )\n"
+
+	"     90 : Side#0 RFIC ARM     (PS/QSPI  0x06900000 - )\n"
+	"     91 : Side#1 RFIC ARM     (PS/QSPI  0x0E900000 - )\n"
+
+);
+//--------------------------------------------------
+// Version DISP
+//--------------------------------------------------
+int cmd_rrh_ver (void)
+{
+	char read_buf[4];
+	unsigned int fpga_buf;
+	/* Bootバージョン？ */
+	printf("\nBoot:%s\n",version_string);
+	/* 装置種別 */
+	f_boot_eeprom_read( 0x040, &read_buf[0] );
+	printf("DU Device type      EEPROM 0x40:%x\n",(UINT)read_buf[0]);
+	/* 対応周波数帯 */
+	f_boot_eeprom_read( 0x041, &read_buf[0] );
+	printf("Supported Bandwidth EEPROM 0x41:%x\n",(UINT)read_buf[0]);
+	/* 起動面 */
+	f_boot_eeprom_read( 0x050, &read_buf[0] );
+	printf("Boot Face           EEPROM 0x50:%x\n",(UINT)read_buf[0]);
+	/* ボード */
+	f_boot_eeprom_read( 0x042, &read_buf[0] );
+	printf("Board version       EEPROM 0x42:%x\n",(UINT)read_buf[0]);
+	/* FPGA */
+	fpga_buf = f_boot_reg_read(0xA0000000);
+	printf("FPGA CTB  Version:%x Revison:%x\n",(fpga_buf >> 16),(fpga_buf & 0x0000FFFF));
+#if 0 // PUIe起動行わないので、表示しない
+	if ((f_boot_reg_read(CTP_CFG)&0x01000100) == 0x00000100) {
+		fpga_buf = f_boot_reg_read(0xB0000000);
+	} else {
+		fpga_buf = 0;
+	}
+	printf("FPGA CTX0 Version:%x Revison:%x\n",(fpga_buf >> 16),(fpga_buf & 0x0000FFFF));
+	if ((f_boot_reg_read(CTP_CFG)&0x02001000) == 0x00001000) {
+		fpga_buf = f_boot_reg_read(0xB2000000);
+	} else {
+		fpga_buf = 0;
+	}
+	printf("FPGA CTX1 Version:%x Revison:%x\n",(fpga_buf >> 16),(fpga_buf & 0x0000FFFF));
+	if ((f_boot_reg_read(CTP_CFG)&0x04010000) == 0x00010000) {
+		fpga_buf = f_boot_reg_read(0xB4000000);
+	} else {
+		fpga_buf = 0;
+	}
+	printf("FPGA CTX2 Version:%x Revison:%x\n",(fpga_buf >> 16),(fpga_buf & 0x0000FFFF));
+	if ((f_boot_reg_read(CTP_CFG)&0x08100000) == 0x00100000) {
+		fpga_buf = f_boot_reg_read(0xB6000000);
+	} else {
+		fpga_buf = 0;
+	}
+	printf("FPGA CTX3 Version:%x Revison:%x\n",(fpga_buf >> 16),(fpga_buf & 0x0000FFFF));
+#endif
+	/* CPLD */
+	f_boot_cpld_read( 0x00, &read_buf[0] );
+	f_boot_cpld_read( 0x01, &read_buf[1] );
+	printf("CPLD Version:%x Revison:%x\n",(UINT)read_buf[0],(UINT)read_buf[1]);
+	/* RFIC？ */
+	printf("RFIC:--.--\n");
+
+	return 0;
+}
+
+#if 0  //35G
+//-----------------------------------------------------------------------
+// S3G用リセットコマンド 関数
+//-----------------------------------------------------------------------
+int do_cmd_rst ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) {
+
+    int rcode = 0;
+//RRH-007 boot alpha)miyazaki ppcEOL chg start (mRRUより移植)
+
+    //B3 mod-s
+	ulong data,side;
+	
+	if (argc < 2) {
+		printf ("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+	
+	data = simple_strtoul (argv[1], NULL, 16);
+	
+	if(data == 0x0001) {
+		if(argc < 3){
+			printf ("Usage:\n%s\n", cmdtp->usage);
+			return 1;
+		}else{
+			side = simple_strtoul (argv[2], NULL, 16);
+			zynq_rrh_start(0,  (int)side);
+		}
+	}else{
+		/* FlashをBootの格納されている0面SS0に設定*/
+		QSPI0_select(0);//0面の Lower(SS0) に切り替え
+		//リセットするのでエラー判定無し
+		printf ("\n");
+		printf ("resetting ...\n");
+		printf ("\n");
+	
+		/* Wait 100ms */
+		udelay(100*1000);
+    //B3 mod-e
+//RRH-007 boot alpha)miyazaki ppcEOL chg end (mRRUより移植)
+
+		// SLCRレジスタ unlock
+		f_boot_reg_write(ZYNQ_SLCR_SLCR_UNLOCK, SLCR_UNLOCK_CODE);
+        // PS soft reset
+        f_boot_reg_write(ZYNQ_SLCR_PSS_RST_CTRL, 1);
+    }
+
+    return rcode;
+}
+
+
+U_BOOT_CMD(
+    rst /*入力コマンド*/ , 2 /* 最大パラメータ数*/ , 0/* repeat対応 */ , do_cmd_rst /* 呼び出し関数名 */,
+    "rst     - CPLD register reset set",
+    "\n"
+    "rst 1 : (PL-configuration)\n"
+    "rst 2 : (PS-reset)\n"
+);
+
+//-----------------------------------------------------------------------
+// 時間表示 関数
+//-----------------------------------------------------------------------
+int do_cmd_date ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) {
+
+    int rcode = 0;
+	unsigned long time_buf;
+	unsigned long day_buf;
+	unsigned long t_h;
+	unsigned long t_m;
+	unsigned long t_s;
+	unsigned long yer;
+	unsigned long mon;
+	unsigned long day;
+	
+
+	// 時間を読む
+	time_buf = f_boot_reg_read(FPGA_RTC1);
+	// 年月日を読む
+	day_buf = f_boot_reg_read(FPGA_RTC2);
+
+	t_h = (time_buf & 0xFF000000) >> 24 ;
+	t_m = (time_buf & 0x00FF0000) >> 16;
+	t_s = (time_buf & 0x0000FF00) >> 8;
+
+	yer = (day_buf & 0xFFFF0000) >> 16;
+	mon = (day_buf & 0x0000FF00) >> 8;
+	day = day_buf & 0x000000FF;
+	
+	printf("%04x/%02x/%02x %02x:%02x:%02x \n",(UINT)yer,(UINT)mon,(UINT)day,(UINT)t_h,(UINT)t_m,(UINT)t_s);
+
+    return rcode;
+}
+
+
+U_BOOT_CMD(
+    date /*入力コマンド*/ , 1 /* 最大パラメータ数*/ , 0/* repeat対応 */ , do_cmd_date /* 呼び出し関数名 */,
+    "output date",
+    "\n"
+	"date : (no param)\n"
+ 
+);
+#endif //35G
+
+#endif // RRH-DPDC -------------------------------------------------------
+
--- a/common/rrh_cmd_sf.c	1970-01-01 09:00:00.000000000 +0900
+++ b/common/rrh_cmd_sf.c	2018-04-10 17:38:41.030422600 +0900
@@ -0,0 +1,586 @@
+/*
+ * Command for accessing SPI flash.
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+#include <spi_flash.h>
+
+#include <asm/io.h>
+#include <command.h>
+#include <configs/zynq_zc70x.h>
+#include <i2c.h>
+
+#include <35G_common.h>
+
+#ifndef CONFIG_SF_DEFAULT_SPEED
+# define CONFIG_SF_DEFAULT_SPEED	1000000
+#endif
+#ifndef CONFIG_SF_DEFAULT_MODE
+# define CONFIG_SF_DEFAULT_MODE		SPI_MODE_3
+#endif
+#ifndef CONFIG_SF_DEFAULT_CS
+# define CONFIG_SF_DEFAULT_CS		0
+#endif
+#ifndef CONFIG_SF_DEFAULT_BUS
+# define CONFIG_SF_DEFAULT_BUS		2
+#endif
+
+#define DEFAULT_SDRAM_ADDR		0x02000000		/* TFTP */
+#define DEFAULT_SDRAMswap_ADDR	0x03000000		
+#define DEFAULT_FLASHread_ADDR	0x05000000
+#define DEFAULT_SDRAMcomp_ADDR	0x06000000
+
+static struct spi_flash *flash;
+
+//RRH-007 boot alpha)miyazaki ppcEOL add start
+//-------------------------------------------------
+// QSPI/SPI I/O mode clock setting
+//-------------------------------------------------
+int init_QSPI_SPI_IO_clock(void)
+{
+unsigned long buf;
+	debug("init_QSPI_SPI_IO_clock in\n");
+    // QSPIディセーブル
+	buf = f_boot_reg_read(ZYNQ_QSPI_EN_REG);
+    buf &= ~(SPI_EN_BIT);
+    f_boot_reg_write(ZYNQ_QSPI_EN_REG, buf);
+
+
+    // SLCRレジスタ unlock
+    f_boot_reg_write(ZYNQ_SLCR_SLCR_UNLOCK, SLCR_UNLOCK_CODE);
+    // QSPI
+    /* 7分周ではOS起動時にKernelPanicになる可能性があるため5分周に戻す */
+
+/* Dual_Band mod-s */
+    f_boot_reg_write(ZYNQ_SLCR_LQSPI_CLK_CTRL,	 0x00000701); // IOpll(1GHz) 7分周
+/* Dual_Band mod-e */
+    // SLCRレジスタ lock
+    f_boot_reg_write(ZYNQ_SLCR_SLCR_LOCK, SLCR_LOCK_CODE);
+
+
+    buf = f_boot_reg_read(ZYNQ_QSPI_CONFIG_REG);
+    buf &= ~(0x00000038); // BAUD_RATE_DIV clear(devide by 2)
+    buf |= (0x00000008); // BAUD_RATE_DIV clear(devide by 4)
+    f_boot_reg_write(ZYNQ_QSPI_CONFIG_REG, buf);
+
+	/*	コンフィギュレーションにIOモード設定	*/
+	buf = f_boot_reg_read(ZYNQ_QSPI_LQSPI_CFG);
+	buf &= ~(0xF0000000);
+	buf |= 0x40000000;
+	f_boot_reg_write(ZYNQ_QSPI_LQSPI_CFG, buf);
+
+    buf = f_boot_reg_read(0xE000D038);
+    buf &= ~(0x00000020); // LPBK mode解除
+    f_boot_reg_write(0xE000D038, buf);
+
+    // QSPIイネーブル
+    buf = f_boot_reg_read(ZYNQ_QSPI_EN_REG);
+    buf |= (SPI_EN_BIT);
+    f_boot_reg_write(ZYNQ_QSPI_EN_REG, buf);
+
+
+    return 0;
+}
+//RRH-007 boot alpha)miyazaki ppcEOL add  end
+
+static int do_spi_flash_probe_rrh(unsigned int cs)
+{
+	unsigned int bus = CONFIG_SF_DEFAULT_BUS;
+	unsigned int speed = 1000000 /* CONFIG_SF_DEFAULT_SPEED */;/* ppc対応 */
+	unsigned int mode = CONFIG_SF_DEFAULT_MODE;
+	struct spi_flash *new;
+
+	DBGLOG_FMT("do_spi_flash_probe_rrh in cs:%d\n", cs );
+	
+//RRH-007 boot alpha)miyazaki ppcEOL add add start
+    (void)init_QSPI_SPI_IO_clock();
+//RRH-007 boot alpha)miyazaki ppcEOL add add end
+    
+    DBGLOG_FMT("call spi_flash_probe start  (bus:%x cs:%x speed:%x mode:%x)\n", bus, cs, speed, mode) ;
+	new = spi_flash_probe(bus, cs, speed, mode);
+    DBGLOG_FMT("call spi_flash_probe end    new:%x\n", (unsigned int)new ) ;
+	if (!new) {
+		printf("Failed to initialize SPI flash at %u:%u\n", bus, cs);
+		return 1;
+	}
+
+	if (flash)
+		spi_flash_free(flash);
+	flash = new;
+
+	return 0;
+}
+//RRH-007 boot alpha)miyazaki ppcEOL add start (from mRU)
+int do_spi_flash_probe_rrh_ext(unsigned int cs)
+{
+	DBGLOG_FMT("do_spi_flash_probe_rrh_ext in   cs:%d\n", cs );
+    int ret;
+    ret = do_spi_flash_probe_rrh(cs);
+    return ret;
+}
+//RRH-007 boot alpha)miyazaki ppcEOL add　end  (from mRU)
+static int do_spi_flash_read_rrh(unsigned int addr, unsigned int offset, unsigned int len)
+{
+	void *buf;
+	int ret;
+
+	DBGLOG_FMT("do_spi_flash_read_rrh in  addr:%08x offset:%08x len:%x(%d)\n", 
+			   (unsigned int)addr, (unsigned int)offset, (unsigned int)len, (int)len );
+	
+	/* Consistency checking */
+	if (offset + len > flash->size) {
+		printf("ERROR: attempting past flash size (%x)\n", flash->size);
+		return 1;
+	}
+
+	buf = map_physmem(addr, len, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	DBGLOG_FMT("call spi_flash_read start [flash:%x offset:%x len:%x buf:%x]\n", 
+			   (unsigned int)flash,(UINT)offset, (UINT)len, (UINT)buf );
+	ret = spi_flash_read(flash, offset, len, buf);
+	DBGLOG_FMT("call spi_flash_read end   ret:%d\n", ret ) ;
+	
+
+	unmap_physmem(buf, len);
+
+	if (ret) {
+		printf("SPI flash failed\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int do_spi_flash_write_rrh(unsigned int addr, unsigned int offset, unsigned int len)
+{
+	void *buf;
+	int ret;
+
+	DBGLOG_FMT("do_spi_flash_write_rrh in  addr:%08x offset:%08x len:%x(%d)\n", (UINT)addr, (UINT)offset, (UINT)len,(int)len );
+	/* Consistency checking */
+	if (offset + len > flash->size) {
+		printf("ERROR: attempting past flash size (%#x)\n", flash->size);
+		return 1;
+	}
+
+	buf = map_physmem(addr, len, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	DBGLOG_FMT("call spi_flash_write start [flash:%x offset:%x len:%x buf:%x]\n", (UINT)flash, (UINT)offset, (UINT)len, (UINT)buf);
+	ret = spi_flash_write(flash, offset, len, buf);
+	DBGLOG_FMT("call spi_flash_write end  ret:%d [flash:%x offset:%x len:%x buf:%x]\n", ret, (UINT)flash, (UINT)offset, (UINT)len, (UINT)buf);
+
+	unmap_physmem(buf, len);
+
+	if (ret) {
+		printf("SPI flash failed\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+
+static int do_spi_flash_erase_rrh(unsigned long offset, unsigned long len)
+{
+	int ret;
+
+	/* Consistency checking */
+	if (offset + len > flash->size) {
+		printf("ERROR: attempting past flash size (%#x)\n", flash->size);
+		return 1;
+	}
+
+	DBGLOG_FMT("call spi_flash_erase start [flash:%x offset:%x len:%x]\n", (UINT)flash, (UINT)offset, (UINT)len );
+	ret = spi_flash_erase(flash, offset, len);
+	DBGLOG_FMT("call spi_flash_erase end   [flash:%x offset:%x len:%x]\n", (UINT)flash, (UINT)offset, (UINT)len );
+	if (ret) {
+		printf("SPI flash failed\n");
+		return 1;
+	}
+
+	return 0;
+}
+/****************************************************************************
+ * FLASHデータコピー (パラメータにより動作)
+ * --------------------------------------------------------------------------
+ * パラメータ(from,toなどの指定)
+ * 	d		tftpフラッシュ
+ * 	0-x		フラッシュ
+ * --------------------------------------------------------------------------
+ * 用途その１	フラッシュ書込み(＄４＝0）
+ *	元データtftp 	boot 0面書き込みの場合			rrh -fc d 0 0
+ *	元データtftp 	OS+APL 1面書き込みの場合		rrh -fc d 11 0
+ *	boot 0面から 	boot 1面書き込みの場合			rrh -fc 0 1 0
+ *	OS+APL0面から	OS+APL1面への書き込みの場合		rrh -fc 10 11 0
+ *													rrh -fc 0 d 0
+ *													rrh -fc 10 d 0
+ * 用途その２	フラッシュ比較(＄４＝0xC)
+ * 	tftpデータと	boot 1面とtftpデータ比較		rrh -fc d 1 c
+ * 	tftpデータと	OS+APL0面とtftpデータ比較		rrh -fc d 10 c
+ * 	boot0面と		boot1面比較						rrh -fc 0 1 c
+ * 	APL0面と		APL1面比較						rrh -fc 10 11 c
+ * 	
+ ******************************************************************************
+ */
+
+typedef struct {
+    int                 selno	;				/* 選択肢(16進数で上位から渡される)		*/
+	int					contype	;				/* QSPI接続種別(0:PS/1:PL)				*/
+	int					side	;				/* 面番号								*/
+	unsigned	int 	startadr;				/* 開始アドレス							*/
+	unsigned 	int 	size	;				/* サイズ								*/
+	unsigned	short	eep_ersflg_adr;			/* EEPROM XXXXイレースフラグアドレス	*/
+	unsigned	short	eep_cksumcalc_adr;		/* EEPROM XXXXチェックサム計算用サイズ(使用時はページ分を消して使用する)	*/
+	char				*desc	;				/* 表示用文字列							*/
+}_flashmap;
+
+
+_flashmap FlashMap[19] = {
+/*      sel   	con sid	start		size			desc */
+	{	0xd,	0,	0,	0x02000000, 0,				0xfff,	0xfff,	"Tftp Data    "		},
+	
+	{	0x0,	1,	0,	0x00000000,	1*1024*1024,	0xfff,	0xfff,	"Boot(Primary)"		},
+	{	0x1,	1,	1,	0x08000000,	1*1024*1024,	0xfff,	0xfff,	"Boot(Primary)"		},
+	{	0x2,	1,	0,	0x00100000,	1*1024*1024,	0xfff,	0xfff,	"Boot(Backup) "		},
+	{	0x3,	1,	1,	0x08100000,	1*1024*1024,	0xfff,	0xfff,	"Boot(Backup) "		},
+	
+	{	0x10,	1,	0,	0x04C00000,	20*1024*1024,	0x097,	0x076,	"OS+FIRM      "		},
+	{	0x11,	1,	1,	0x0CC00000,	20*1024*1024,	0x0d7,	0x0b6,	"OS+FIRM      "		},
+
+	{	0x30,	1,	0,	0x00400000,	36*1024*1024,	0x0a1,	0x08a,	"Zynq(PL)FPGA "		},
+	{	0x31,	1,	1,	0x08400000,	36*1024*1024,	0x0e1,	0x0ca,	"Zynq(PL)FPGA "		},
+	{	0x32,	1,	0,	0x02800000,	36*1024*1024,	0x0a3,	0x08e,	"Zynq(PL)FPGA "		},
+	{	0x33,	1,	1,	0x0A800000,	36*1024*1024,	0x0e3,	0x0ce,	"Zynq(PL)FPGA "		},
+
+	{	0x70,	2,	0,	0x00000000,	23*1024*1024,	0x099,	0x07a,	"SlaveFPGA    "		},
+	{	0x71,	2,	1,	0x02000000,	23*1024*1024,	0x0d9,	0x0ba,	"SlaveFPGA    "		},
+	{	0x72,	2,	2,	0x04000000,	23*1024*1024,	0x09b,	0x07e,	"SlaveFPGA    "		},
+	{	0x73,	2,	3,	0x06000000,	23*1024*1024,	0x0db,	0x0be,	"SlaveFPGA    "		},
+
+	{ 	0x80,	1,	0,	0x06800000,	1*1024*1024,	0x09d,	0x082,	"RFIC boot    "		},
+	{	0x81,	1,	1,	0x0E800000,	1*1024*1024,	0x0dd,	0x0c2,	"RFIC boot    "		},
+
+	{ 	0x90,	1,	0,	0x06900000,	1*1024*1024,	0x09f,	0x086,	"RFIC ARM     "		},
+	{	0x91,	1,	1,	0x0E900000,	1*1024*1024,	0x0df,	0x0c6,	"RFIC ARM     "		}
+};
+/**********************************************
+DL用Flashイレースフラグ(FIRM)
+	0x054	(84)	HEX	
+	0x055	(85)	HEX	下位1bit＝1でイレース済み
+DL用Flashイレースフラグ(FPGA)
+	0x056	(86)	HEX	※ZynqではKU-FPGA用で使用
+	0x057	(87)	HEX	下位1bit＝1でイレース済み
+DL用Flashイレースフラグ(RFICデバイス)
+	0x058	(88)	HEX	
+	0x059	(89)	HEX	下位1bit＝1でイレース済み
+DL用Flashイレースフラグ(PL FPGA)
+	0x05A	(90)	HEX	※A10では未使用、ZynqではPL-FPGA用で使用
+	0x05B	(91)	HEX	下位1bit＝1でイレース済み
+
+---
+チェックサム計算用サイズ(上位)MPUファームウェア FLASH 0面	
+	0x130	(304)	HEX	ソフト用(0000～FFFF)
+	0x131	(305)	HEX	
+チェックサム計算用サイズ(下位)MPUファームウェア FLASH 0面	
+    0x132	(306)	HEX	ソフト用(0000～FFFF)
+	0x133	(307)	HEX
+
+チェックサム計算用サイズ(上位)FPGA FLASH 0面	
+    0x134	(308)	HEX	ソフト用(0000～FFFF)
+	0x135	(309)	HEX	※ZynqではKU-FPGA用で使用
+チェックサム計算用サイズ(下位)FPGA FLASH 0面	
+    0x136	(310)	HEX	ソフト用(0000～FFFF)
+	0x137	(311)	HEX	※ZynqではKU-FPGA用で使用
+
+チェックサム計算用サイズ(上位)RFデバイス FLASH 0面	
+    0x138	(312)	HEX	ソフト用(0000～FFFF)
+	0x139	(313)	HEX	
+チェックサム計算用サイズ(下位)RFデバイス FLASH 0面	
+    0x13A	(314)	HEX	ソフト用(0000～FFFF)
+	0x13B	(315)	HEX	
+
+チェックサム計算用サイズ(上位)PL-FPGA FLASH 0面	
+	0x140	(320)	HEX	ソフト用(0000～FFFF)
+	0x141	(321)	HEX	※Zynq時のみ参照,PL-FPGA起動面
+チェックサム計算用サイズ(下位)PL-FPGA FLASH 0面
+	0x142	(322)	HEX	ソフト用(0000～FFFF)
+	0x143	(323)	HEX	※Zynq時のみ参照,PL-FPGA起動面
+
+チェックサム計算用サイズ(上位)MPUファームウェア FLASH 1面	
+	0x144	(324)	HEX	ソフト用(0000～FFFF)
+	0x145	(325)	HEX	
+チェックサム計算用サイズ(下位)MPUファームウェア FLASH 1面
+	0x146	(326)	HEX	ソフト用(0000～FFFF)
+	0x147	(327)	HEX	
+
+チェックサム計算用サイズ(上位)FPGA FLASH 1面	
+	0x148	(328)	HEX	ソフト用(0000～FFFF)
+	0x149	(329)	HEX	※ZynqではKU-FPGA用で使用
+チェックサム計算用サイズ(下位)FPGA FLASH 1面	
+	0x14A	(330)	HEX	ソフト用(0000～FFFF)
+	0x14B	(331)	HEX	※ZynqではKU-FPGA用で使用
+
+チェックサム計算用サイズ(上位)RFデバイス FLASH 1面	
+	0x14C	(332)	HEX	ソフト用(0000～FFFF)
+	0x14D	(333)	HEX	
+チェックサム計算用サイズ(下位)RFデバイス FLASH 1面	
+	0x14E	(334)	HEX	ソフト用(0000～FFFF)
+	0x14F	(335)	HEX	
+
+チェックサム計算用サイズ(上位)PL-FPGA FLASH 1面	
+	0x154	(340)	HEX	ソフト用(0000～FFFF)
+	0x155	(341)	HEX	※Zynq時のみ参照,PL-FPGA起動面
+チェックサム計算用サイズ(下位)PL-FPGA FLASH 1面	
+	0x156	(342)	HEX	ソフト用(0000～FFFF)
+	0x157	(343)	HEX	※Zynq時のみ参照,PL-FPGA起動面
+
+**********************************************/
+/* パラメータチェック	*/
+int	selnochk(unsigned long selno) {
+	unsigned long	seltblindex	;
+	for(seltblindex = 0 ; seltblindex < 19 ; seltblindex++) {
+		if( FlashMap[seltblindex].selno == selno ) {
+			return seltblindex;
+		}
+	}
+	return -1;
+	
+}
+int cmd_rrh_fc (ulong cp_param[]){
+
+    uchar eep_size[6];
+//RRH-007 boot alpha)miyazaki ppcEOL chg end
+	int	dataind1		=	-1;
+	int	dataind2		=	-1;
+	unsigned int	*tftp_dat_len	;
+	unsigned int data1_len;
+	unsigned long data1_adr;
+	unsigned int cmpind;
+	int ret;
+
+	/* data1 data2パラメータチェック */
+	if(( dataind1 = selnochk( cp_param[0] )) == -1  ) {
+		printf("Error: parameter error.(data no1)\n");
+		return 0;
+	}
+	if(( dataind2 = selnochk( cp_param[1] )) == -1 ) {
+		printf("Error: parameter error.(data no2)\n");
+		return 0;
+	}
+	if( dataind1 == dataind2 ) {	/* from to が一緒	*/
+		printf("Error: parameter error.(same data)\n");
+		return 0;
+	}
+	
+	if( cp_param[2] == 0 )	{	/* フラッシュ書き込み		*/
+
+		printf(" flash copy \n");
+
+		if( dataind1 == 0  )	{	/* from側がTFTP */
+			
+			if( dataind2 != 0 ) 	{	/* to側がTFTP以外	*/
+				
+				/* EEPROMフラッシュ書込み関連データ初期化 */
+				if( FlashMap[dataind2].eep_ersflg_adr != 0xfff )	{	/* EEPROM更新対象？	*/
+					f_boot_eeprom_write( FlashMap[dataind2].eep_ersflg_adr     , 0 )	;	/* イレースフラグ			*/
+					f_boot_eeprom_write( FlashMap[dataind2].eep_cksumcalc_adr+0, 0 )	;	/* チェックサム計算用サイズ	*/
+					f_boot_eeprom_write( FlashMap[dataind2].eep_cksumcalc_adr+1, 0 )	;	/* チェックサム計算用サイズ	*/
+					f_boot_eeprom_write( FlashMap[dataind2].eep_cksumcalc_adr+2, 0 )	;	/* チェックサム計算用サイズ	*/
+					f_boot_eeprom_write( FlashMap[dataind2].eep_cksumcalc_adr+3, 0 )	;	/* チェックサム計算用サイズ	*/
+				}
+				
+				/* TFTPデータを指定のフラッシュへ書き込み	*/
+				data1_adr 	= 	DEFAULT_SDRAM_ADDR			;	/* 読み込み元データ領域を指定	*/
+				tftp_dat_len=	(unsigned int *)(DEFAULT_SDRAM_ADDR - 0x10)	;	/* 0x10前にTFTPデータのサイズが入っている	*/
+				data1_len	=	*tftp_dat_len				;	/* 読み込み元サイズ				*/
+				if( data1_len > FlashMap[dataind2].size ) {	/* TFTP格納のデータサイズが実際の書き込み先サイズよりも大きい場合	*/
+					printf(" TFTP data size is too big than what write enables area.\n");
+					return 0;
+				}
+				
+	
+#if 0 // 今回不要
+				/* フラッシュ選択	*/
+				printf(" set - QSPI %d side.\n",FlashMap[dataind2].side);
+				if(FlashMap[dataind2].contype == 1 ) {		/* 書込み先がPS接続フラッシュ？	*/
+					ret = QSPI0_select( FlashMap[dataind2].side ) ;	/* 面指定	*/
+					if( ret < 0  )	{
+						printf("QSPI Flash Select NG(%d)\n", ret );
+						return 0;
+					}
+				}
+#endif // 今回不要
+				printf("%2x :        %-10s (0x%08x - )", 
+						FlashMap[dataind1].selno,
+						FlashMap[dataind1].desc,
+						FlashMap[dataind1].startadr
+				);
+				printf("--> \n");
+				printf("%2x : Side#%d %-10s (0x%08x - )", 
+						FlashMap[dataind2].selno,
+						FlashMap[dataind2].side,
+						FlashMap[dataind2].desc,
+						FlashMap[dataind2].startadr
+				);
+				printf("\n");
+		
+				/* フラッシュイレース	*/
+				printf("Erase : 0x%08x - 0x%08x \n", FlashMap[dataind2].startadr, (FlashMap[dataind2].startadr + (FlashMap[dataind2].size -1 )));
+				if( FlashMap[dataind2].contype == 1 ) {		/* 書込み先がPS接続フラッシュ？	*/
+					ret = do_spi_flash_probe_rrh( 0 ) ;		/* 消去前にprobe処理（QSPI0_select()先で実施していた）	*/
+					ret = do_spi_flash_erase_rrh( FlashMap[dataind2].startadr, FlashMap[dataind2].size) ;		/* 消去はフルサイズ	*/
+				}else{
+					ret = cmd_plqspif_erase( 0, FlashMap[dataind2].startadr, FlashMap[dataind2].size);			/* */
+				}
+				printf("Erase : ");
+				if(ret == 0)	{	/* 正常	*/
+					printf("OK\n");
+				}
+				else {
+					switch(ret) {
+					case 1:		printf("Error:Timeout\n");				break;
+					case 2:		printf("Error:Flash not erased.\n");	break;
+					default:	printf("Error:Other(%d)\n",ret);		break;
+					}
+					return 0;
+
+				}
+				printf("Read  : 0x%08x - 0x%08x \n", (unsigned int)FlashMap[dataind1].startadr,(unsigned int)(FlashMap[dataind1].startadr+*tftp_dat_len));
+				printf("Write : 0x%08x - 0x%08x \n", (unsigned int)FlashMap[dataind2].startadr,(unsigned int)(FlashMap[dataind2].startadr+*tftp_dat_len));
+				printf("\n");
+	
+				/* フラッシュ書き込み	*/
+				if( FlashMap[dataind2].contype == 1 ) {		/* 書込み先がPS接続フラッシュ？	*/
+					ret = do_spi_flash_write_rrh( data1_adr, FlashMap[dataind2].startadr, *tftp_dat_len );	/* 書込み時はtftpのサイズ	*/
+				}
+				else {
+					ret = cmd_plqspif_write( 0, data1_adr, FlashMap[dataind2].startadr, *tftp_dat_len);
+				}
+				printf("Write:");
+				if( ret == 0  ){	/* 正常	*/
+					printf("OK\n");
+				}
+				else {
+					switch(ret) {
+					case 1:		printf("Error:Timeout\n");				break;
+					case 2:		printf("Error:Flash not erased.\n");	break;
+					default:	printf("Error:Other\n");				break;
+					}
+					return 0;
+				}
+			
+				/* 確認　*/
+				/* 書込み確認の為、フラッシュからRAMへ読み込みTFTPバッファの内容と比較する */
+				printf("Verify:");
+				if( FlashMap[dataind2].contype == 1 ) {		/* 書込み先がPS接続フラッシュ？	*/
+					ret =  do_spi_flash_read_rrh( DEFAULT_SDRAMcomp_ADDR, FlashMap[dataind2].startadr, *tftp_dat_len);
+				}
+				else	{
+					ret  = cmd_plqspif_read(0, DEFAULT_SDRAMcomp_ADDR, FlashMap[dataind2].startadr, *tftp_dat_len );
+				}
+				if( ret != D_BOOT_OK )	{
+					printf("flash read error. \n");
+					return 0;
+				}
+				
+				
+				/* 比較 */
+				{
+				  char *writedat_adr;
+				  char *cmpdat_adr  ;
+				  writedat_adr = (char *)data1_adr;
+				  cmpdat_adr  = (char *) DEFAULT_SDRAMcomp_ADDR ;
+				  for( cmpind = 0 ; cmpind < *tftp_dat_len ; cmpind++ )	{
+					if( *( writedat_adr + cmpind)  != *( cmpdat_adr + cmpind ) )	{
+					  printf("compare error +0x%08x:%x - %x\n", cmpind, (*( writedat_adr + cmpind ) & 0xff), (*( cmpdat_adr + cmpind ) & 0xff ));
+					  return 0;
+					}
+				  }
+				}
+				printf("OK\n");
+				printf(" complete\n");
+				
+				/* 書込みサイズ保存	*/
+				if( FlashMap[dataind2].eep_cksumcalc_adr != 0xfff )	{	/* EEPROM更新対象？	*/
+					int	len;
+					DBGLOG_FMT("eeprom update size : %08x\n", *tftp_dat_len ) ;
+					for(len=0;len<6;len++)	{	/* サイズデータ(tftp_dat_len)を１６進数化	*/
+				        eep_size[len] = (( *tftp_dat_len >> (24 - (8*len))) & 0xFF);
+				    }
+					f_boot_eeprom_write( FlashMap[dataind2].eep_cksumcalc_adr+0, eep_size[0] )	;	/* チェックサム計算用サイズ	*/
+					f_boot_eeprom_write( FlashMap[dataind2].eep_cksumcalc_adr+1, eep_size[1] )	;	/* チェックサム計算用サイズ	*/
+					f_boot_eeprom_write( FlashMap[dataind2].eep_cksumcalc_adr+2, eep_size[2] )	;	/* チェックサム計算用サイズ	*/
+					f_boot_eeprom_write( FlashMap[dataind2].eep_cksumcalc_adr+3, eep_size[3] )	;	/* チェックサム計算用サイズ	*/
+				}
+				return 1;
+			}
+			else {
+				printf("not support now!\n");
+				return 0;
+			}
+		}
+		else if( dataind2 != 0 ) {	/* TO側がTFTP */	
+			printf("not support now.!\n");
+			return 0;
+		}
+		
+	}
+	return D_BOOT_OK;
+	  
+}
+
+int cmd_rrh_fe (ulong cp_param[]){
+
+	unsigned int adr = cp_param[1];
+	unsigned int len = cp_param[2];
+	int ret;
+
+	/* csは今回チェックしない */
+
+	/* アドレスチェック */
+	if((adr % 0x10000) > 0) {
+		printf("Error: parameter error.<addr is not 64K sector>\n");
+		return 0;
+	}
+
+	/* サイズチェック */
+	if((len % 0x10000) > 0) {
+		printf("Error: parameter error.<size is not 64K sector>\n");
+		return 0;
+	}
+
+	ret = do_spi_flash_probe_rrh( 0 ) ;			/* 消去実行前にprobe処理	*/
+	if(ret != 0) {
+		printf("Error: Probe fail(%d)\n",ret);
+		return 0;
+	}
+	printf("Erase : 0x%08x - 0x%08x \n", adr, (adr + (len - 1)));
+	ret = do_spi_flash_erase_rrh( adr, len ) ;	/* アドレスからサイズ分消去	*/
+	printf("Erase : ");
+	if(ret == 0)	{	/* 正常	*/
+		printf("OK\n");
+	} else {
+		switch(ret) {
+		case 1:		printf("Error:Timeout\n");				break;
+		case 2:		printf("Error:Flash not erased.\n");	break;
+		default:	printf("Error:Other(%d)\n",ret);		break;
+		}
+		return 0;
+	}
+	return D_BOOT_OK;
+}
+
+
--- a/common/rrh_cmd_spi.c	1970-01-01 09:00:00.000000000 +0900
+++ b/common/rrh_cmd_spi.c	2018-06-04 10:48:59.368414100 +0900
@@ -0,0 +1,1672 @@
+/* RRH-001 boot alpha)nakajima-h add start */
+#include <common.h>
+#include <command.h>
+//#include <setpll.h>
+//#include <asm/processor.h>
+//#include <ppc4xx.h>
+#include <configs/zynq_zc70x.h>
+#include <i2c.h>
+
+#include <35G_common.h>
+
+//#ifdef RRH_DPDC //---------------------------------------------
+
+//#define SPI_CONFIG_INIT       (0x00027C19)  // CSをディセーブルに
+#define SPI_CONFIG_INIT       (0x00027C19)  // CSをディセーブルに
+#define SPI_INTRPT_EN_INIT    (0x0000007F)  // 割り込みを有効に
+#define SPI_CONFIG_INIT_FAST    (0x00027C11)  // CSをディセーブルに(1/8)
+#define SPI_CONFIG_INIT_MID     (0x00027C19)  // CSをディセーブルに(1/16)
+#define SPI_CONFIG_INIT_SLOW    (0x00027C2D)  // CSをディセーブルに(1/64)(PHを変更)
+// PL QSPI
+//#define PL_QSPI_BASE             (0x40020000)  // base address
+#define PL_QSPI_BASE             (0xA0020000)  // base address
+#define PL_QSPI_RESET            (0x00000040)  // Software reset
+#define PL_QSPI_CNT              (0x00000060)  // control
+#define PL_QSPI_STATE            (0x00000064)  // status
+#define PL_QSPI_TX               (0x00000068)  // data transmit
+#define PL_QSPI_RX               (0x0000006C)  // data receive
+#define PL_QSPI_CS               (0x00000070)  // slave select
+//static unsigned long PLQSPI_SET = 1;
+/*	FLASH EOL対応 add start	*/
+//static unsigned long plQspiInfo;
+//unsigned int qspiFlashId = 0;
+/*	FLASH EOL対応 add end	*/
+
+//-----------------------------------------------------------------------
+// PS接続SPIアクセス初期化コマンド 
+//-----------------------------------------------------------------------
+VOID cmd_ps_spi_csend (unsigned long bus) {
+
+    unsigned long bus_offset;
+
+    DBGLOG_FMT("cmd_ps_spi_csend in ( bus:%x )\n", (unsigned int)bus );
+    
+    if(bus == 0) bus_offset = ZYNQ_SPI0_OFFSET;
+    else bus_offset = ZYNQ_SPI1_OFFSET;
+
+    //csディセーブル
+    f_boot_reg_write(bus_offset + ZYNQ_SPI_CONFIG, SPI_CONFIG_INIT);
+
+}
+
+
+//-----------------------------------------------------------------------
+// PS接続SPIアクセスクロック変更(0:slow,1:mid,2:fast)
+//-----------------------------------------------------------------------
+VOID cmd_ps_spi_fast (unsigned long bus, unsigned long fast) {
+
+    unsigned long bus_offset;
+    unsigned long spi_init=SPI_CONFIG_INIT;
+
+    DBGLOG_FMT("cmd_ps_spi_fast in ( bus:%x fast:%x )\n", (unsigned int)bus, (unsigned int)fast );
+
+    if(fast==2) spi_init = SPI_CONFIG_INIT_FAST;
+    else if(fast==1) spi_init = SPI_CONFIG_INIT_MID;
+    else spi_init = SPI_CONFIG_INIT_SLOW;
+
+    if(bus == 0) bus_offset = ZYNQ_SPI0_OFFSET;
+    else bus_offset = ZYNQ_SPI1_OFFSET;
+
+    //csディセーブル
+    f_boot_reg_write(bus_offset + ZYNQ_SPI_CONFIG, spi_init);
+}
+
+
+//-----------------------------------------------------------------------
+// PS接続SPIアクセス初期化コマンド 
+//-----------------------------------------------------------------------
+VOID cmd_ps_spi_ini (unsigned long bus) {
+
+    int cnt;
+    unsigned long data;
+    unsigned long bus_offset;
+
+    DBGLOG_FMT("cmd_ps_spi_ini in (bus:%x)\n", (unsigned int)bus);
+    
+    if(bus == 0) bus_offset = ZYNQ_SPI0_OFFSET;
+    else bus_offset = ZYNQ_SPI1_OFFSET;
+
+    f_boot_reg_write(bus_offset + ZYNQ_SPI_EN, 0);  // 一旦 SPI offに設定
+    f_boot_reg_write(bus_offset + ZYNQ_SPI_CONFIG, SPI_CONFIG_INIT);
+    f_boot_reg_write(bus_offset + ZYNQ_SPI_INTRPT_EN, SPI_INTRPT_EN_INIT);
+    f_boot_reg_write(bus_offset + ZYNQ_SPI_EN, 1);  // 初期設定終了後 SPI onに設定
+    // RX fifoを空になるまで読み出し
+    cnt = 0;
+DBGLOG_OFF
+    while((f_boot_reg_read(bus_offset + ZYNQ_SPI_INTR_STATUS) & 0x00000010) != 0) {
+        data = f_boot_reg_read(bus_offset + ZYNQ_SPI_RX_DATA);
+    	data += cnt; // warning対策
+        cnt += 1;
+        if (cnt >= 128) {
+            printf(" RX FIFO err \n");
+        	break;
+        }
+    }
+DBGLOG_ON
+    // TX fifoを空にしたいけど・・・
+}
+
+//-----------------------------------------------------------------------
+// PS接続SPIアクセスコマンド 
+// cs:0-2
+// dat_len:tx_datのデータ数(コマンド、アドレスも含む)
+// tx_dat:送信データの先頭アドレス(ulong)
+// rx_dat:受信データの格納先頭アドレス(ulong)
+// cs_cnt:0 cs制御有り/1 cs制御最初無し/2 cs制御最後無し/3 cs制御無し
+//-----------------------------------------------------------------------
+int cmd_ps_spi (unsigned long bus, unsigned long cs, unsigned long dat_len, unsigned long *tx_dat, unsigned long *rx_dat, unsigned short cs_cnt) {
+
+    int rcode = 0;
+    int cnt,cnt1;
+    unsigned long data;
+    unsigned long *tx_data,*rx_data;
+    unsigned long bus_offset;
+    unsigned long data_offset,status_offset,config_offset,rxdata_offset;
+
+    DBGLOG_FMT("cmd_ps_spi in (bus:%x cs:%x dat_len:%x tx_dat:%x rx_dat:%x cs_cnt:%x)\n", (UINT)bus, (UINT)cs, (UINT)dat_len, (UINT)tx_dat, (UINT)rx_dat, (UINT)cs_cnt );
+
+    if(bus == 0) bus_offset = ZYNQ_SPI0_OFFSET;
+    else bus_offset = ZYNQ_SPI1_OFFSET;
+
+    data_offset = bus_offset + ZYNQ_SPI_TX_DATA;
+    status_offset = bus_offset + ZYNQ_SPI_INTR_STATUS;
+    config_offset = bus_offset + ZYNQ_SPI_CONFIG;
+    rxdata_offset = bus_offset + ZYNQ_SPI_RX_DATA;
+    
+    tx_data = tx_dat;
+    rx_data = rx_dat;
+
+    if ((cs_cnt == 0) || (cs_cnt == 2)){
+        if (cs > 2) {
+            printf ("device select err\n");
+            return 1;
+        }
+        if (cs == 2) cs = 3;
+        data = f_boot_reg_read(config_offset) & ~(0x00003C00);
+        cs <<= 10;
+        data |= cs;
+        //csイネーブル
+        f_boot_reg_write(config_offset, data);
+    }
+
+    //データ送信
+    for (cnt = 0;cnt < dat_len;cnt++) {
+        f_boot_reg_write(data_offset, *tx_data); 
+        tx_data++;
+    }
+    //データ受信
+DBGLOG_OFF
+    for (cnt = 0;cnt < dat_len;cnt++) {
+        cnt1 = 0;
+        //データ受信するまで待つ
+        while((f_boot_reg_read(status_offset) & 0x00000010) == 0) {
+//RRH-007 boot alpha)miyazaki ppcEOL chg start mrruからの展開
+            if (cnt1 > 1000000) {
+                printf(" RX FIFO timeout(spi) \n");
+//RRH-007 boot alpha)miyazaki ppcEOL chg end mrruからの展開
+
+                //csディセーブル
+                f_boot_reg_write(config_offset, SPI_CONFIG_INIT);
+                return 1;
+            }
+//RRH-007 boot alpha)miyazaki ppcEOL chg start mrruからの展開
+            udelay(1*100);  //100us wait
+//RRH-007 boot alpha)miyazaki ppcEOL chg end mrruからの展開
+
+            cnt1++;
+        }
+        //受信データ取り込み
+        *rx_data = f_boot_reg_read(rxdata_offset);
+        rx_data++;
+    }
+DBGLOG_ON
+
+    if ((cs_cnt == 0) || (cs_cnt == 1)){
+        //csディセーブル
+        f_boot_reg_write(config_offset, SPI_CONFIG_INIT);
+    }
+    return rcode;
+}
+
+//RRH-007 boot alpha)miyazaki ppcEOL chg start mrruからの展開
+//====================================================================
+// フラッシュ QSPIアクセス
+//====================================================================
+// probeコマンドでI/Oモードにしてから使用すること
+
+//--------------------------
+// QSPI FIFO クリア
+//--------------------------
+int cmd_ps_qspi_ini(void)
+{
+    int cnt;
+    DBGLOG_FMT("cmd_ps_qspi_ini in\n") ;
+    
+    // RX FIFOを空にする
+    cnt = 0;
+DBGLOG_OFF
+    while((f_boot_reg_read(ZYNQ_QSPI_INTR_STATUS_REG) & 0x00000010) != 0) {
+        cnt += 1;
+        if (cnt >= 252) {
+            printf(" RX FIFO err \n");
+            return 1;
+        }
+    }
+DBGLOG_ON
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------
+// PS接続QSPIアクセスコマンド
+// dat_len:tx_datのデータ数(コマンド、アドレスも含む)
+// tx_dat:送信データの先頭アドレス(uchar) リード用の空データ分のバッファも用意しておくこと
+// rx_dat:受信データの格納先頭アドレス(uchar) dat_len分データ読み込むので、必要なバッファを用意すること
+// tx_no:CS選択(上位CS:0/下位CS:1)
+//-----------------------------------------------------------------------
+int cmd_ps_qspi (unsigned char dat_len, unsigned char *tx_dat, unsigned char *rx_dat, unsigned char tx_no) {
+
+    unsigned int cnt;
+    unsigned char *tx_data,*rx_data;
+    unsigned long conf_org_reg,tx_data_reg,tx_cs_mask;
+
+    DBGLOG_FMT("cmd_ps_qspi in (dat_len:%x tx_dat:%x rx_dat:%x tx_no:%x\n", (UINT)dat_len, (UINT)tx_dat, (UINT)rx_dat, (UINT)tx_no);
+
+    tx_data = tx_dat;
+    rx_data = rx_dat;
+
+    if(dat_len>252){
+        printf("data length err! \n");
+        return 1;
+    }
+    
+    switch (tx_no) {
+    case 0: // 上位CS
+        tx_cs_mask = 0x0000A000; // GEN_FIFO [15:14] 上位パス(10)、[13]上位チップ駆動
+        break;
+    case 1: // 下位CS
+        tx_cs_mask = 0x00005000; // GEN_FIFO [15:14] 下位パス(01)、[12]下位チップ駆動
+        break;
+    default:
+        printf("CS select err! \n");
+        return 1;
+    }
+
+    f_boot_reg_write(ZYNQ_QSPI_0014, 0x00000000);   // レガシーQSPIコントローラをディセーブルにする
+    f_boot_reg_write(ZYNQ_QSPI_0144, 0x00000001);   // ジェネリックQSPIを選択
+    conf_org_reg = f_boot_reg_read(ZYNQ_QSPI_0100); // コンフィギュレーションレジスタの初期値を保存
+    f_boot_reg_write(ZYNQ_QSPI_0100, 0x20080010);   // IOモード、マニュアルスタートを設定
+    f_boot_reg_write(ZYNQ_QSPI_0114, 0x00000001);   // ジェネリックQSPIコントローラをイネーブルにする
+
+    tx_data_reg = 0x00030400 | tx_cs_mask; // 書き込みコマンド設定
+    // データ送信
+    for (cnt = 0; cnt < dat_len; cnt++) { // データ長分書き込み
+        tx_data_reg |= ((unsigned long)*tx_data); // 書き込みデータ設定
+//printf("write data = 0x%08x\n",tx_data_reg);
+        f_boot_reg_write(ZYNQ_QSPI_0140, tx_data_reg);
+        tx_data++;
+        tx_data_reg &= 0xFFFFFF00; // 書き込みデータクリア
+    }
+
+    tx_data_reg &= 0xFFFCCFFF; // コマンド設定(受信[17]送信[16]セレクト駆動[13:12]クリア)
+    f_boot_reg_write(ZYNQ_QSPI_0140, tx_data_reg); // フラッシュのCSをディセーブル設定
+    f_boot_reg_write(ZYNQ_QSPI_0100, 0x30080010);  // GEN_FIFOからの転送をスタートする
+
+    // データ受信
+    for (cnt = 0; cnt < dat_len; cnt++) { // データ長分読み出し
+        while((f_boot_reg_read(ZYNQ_QSPI_0104) & 0x00000800)) {} // RXFIFOがemptyでない事を確認
+        *rx_data = (unsigned char)f_boot_reg_read(ZYNQ_QSPI_0120); // データ読み出し
+//printf("read data = 0x%x\n",*rx_data);
+        rx_data++;
+    }
+
+    f_boot_reg_write(ZYNQ_QSPI_0114, 0x00000000);   // ジェネリックQSPIコントローラをディセーブルにする
+    f_boot_reg_write(ZYNQ_QSPI_0100, conf_org_reg); // コンフィギュレーションレジスタを元に戻す
+
+    return 0;
+}
+
+
+
+
+// B3 mod-s
+//--------------------------
+// QSPI0の 面切り替え
+// side : upper:1/lower:0
+//--------------------------
+int QSPI0_select(unsigned long side)
+{
+#if 0 // cmd_ps_qspi()を修正したので、このままでは使えない
+    unsigned long len_dat;
+    unsigned long tx_dat[5];
+    unsigned long rx_dat[5];
+    
+    DBGLOG_FMT("QSPI0_select in  side:%d\n", (int)side );
+
+    // qspi0 I/Oモード設定
+    if(do_spi_flash_probe_rrh_ext(0)) return 1;
+
+
+    // QSPI RX FIFO初期化
+    if(cmd_ps_qspi_ini()) return 1;
+
+    // write enable コマンド
+    tx_dat[0] = 0x06;
+    len_dat = 1;
+    if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, 1)) return 1;
+
+    // write expanded address register コマンド
+    tx_dat[0] = 0xC5;
+    tx_dat[0] |= (side << 8) & 0x0000FF00 ;
+    len_dat = 1;
+    if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, 2)) return 1;
+
+    //debug
+    // read expanded address register コマンド
+    tx_dat[0] = 0xC8;
+    len_dat = 1;
+    if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, 2)) return 1;
+
+    printf("SS0 & Side = %d.\n",(unsigned int)side);
+    printf("expanded address register = 0x%08x \n",(unsigned int)rx_dat[0]);
+#endif // cmd_ps_qspi()を修正したので、このままでは使えない
+
+    return 0;
+}
+
+//--------------------------
+// QSPI1の 面切り替え
+// side : upper:1/lower:0
+//--------------------------
+int QSPI1_select(unsigned long side)
+{
+#if 0 // cmd_ps_qspi()を修正したので、このままでは使えない
+    unsigned long len_dat;
+    unsigned long tx_dat[5];
+    unsigned long rx_dat[5];
+
+    DBGLOG_FMT("QSPI1_select in  side:%d\n", (int)side );
+
+    // qspi1 I/Oモード設定
+    if(do_spi_flash_probe_rrh_ext(1)) return 1;
+
+    // QSPI RX FIFO初期化
+    if(cmd_ps_qspi_ini()) return 1;
+
+    // write enable コマンド
+    tx_dat[0] = 0x06;
+    len_dat = 1;
+    if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, 1)) return 1;
+
+    // write expanded address register コマンド
+    tx_dat[0] = 0xC5;
+    tx_dat[0] |= (side << 8) & 0x0000FF00 ;
+    len_dat = 1;
+    if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, 2)) return 1;
+
+    //debug
+    // read expanded address register コマンド
+    tx_dat[0] = 0xC8;
+    len_dat = 1;
+    if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, 2)) return 1;
+
+    printf("SS1 & Side = %d.\n",(unsigned int)side);
+    printf("expanded address register = 0x%08x \n",(unsigned int)rx_dat[0]);
+#endif // cmd_ps_qspi()を修正したので、このままでは使えない
+
+    return 0;
+}
+// B3 mod-e
+
+//====================================================================
+// フラッシュ QSPIアクセス(PL)
+//====================================================================
+
+//--------------------------
+// PL Data読み出し
+//--------------------------
+int cmd_pl_qspi_data_read(unsigned char *data_p)
+{
+    unsigned int count;
+    unsigned long buf;
+    
+    DBGLOG_FMT("cmd_pl_qspi_data_read in \n");
+
+    // Rx_Empty = "0"であることを確認
+	count = 0;
+	while (f_boot_reg_read(PL_QSPI_BASE + PL_QSPI_STATE) & 0x00000001) {
+		// 待ち合わせ必要？
+        udelay(1*100);  //100us wait
+		if(count++ > 1000000) return 1;		// 一定回数確認してデータ無ければ抜ける
+	}
+    // FLASHからのリード値取得(1byte)
+    buf = f_boot_reg_read(PL_QSPI_BASE + PL_QSPI_RX);				// 0xA002_006C
+	*data_p = (unsigned char)buf;
+    DBGLOG_FMT("cmd_pl_qspi_data_read ok:%x \n",buf);
+
+	return 0;
+}
+
+//--------------------------
+// PL Data読み出し(回数分読み捨て)
+//--------------------------
+int cmd_pl_qspi_data_read_cycle(int num)
+{
+	int rcode = 0;
+    unsigned int count;
+    unsigned char data;
+    
+    DBGLOG_FMT("cmd_pl_qspi_data_read_cycle in \n");
+
+	for (count = 0; count < num; count++) {
+		//ダミーリード
+		if(cmd_pl_qspi_data_read(&data) != 0) {
+			printf(" RX FIFO timeout(Dummy read:%d/%d)(pl qspi) \n",count,num);
+			rcode = 1;
+		}
+	}
+	return rcode;
+}
+
+//-----------------------------------------------------------------------
+// PL接続QSPI ip アクセスコマンド
+// dat_len:tx_datのデータ数
+// tx_dat:送信データの先頭アドレス(uchar*)（Nullの場合は空データ書き込み）
+// rx_dat:受信データの格納先頭アドレス(uchar*)（Nullの場合は読み出しデータ廃棄）
+//-----------------------------------------------------------------------
+int cmd_pl_qspi (unsigned long dat_len, unsigned char *tx_dat, unsigned char *rx_dat)
+{
+	int rcode = 0;
+    unsigned int cnt;
+    unsigned char *tx_data,*rx_data;
+    unsigned char data;
+
+    DBGLOG_FMT("cmd_pl_qspi in (dat_len:%x tx_dat:%x rx_dat:%x\n", (UINT)dat_len, (UINT)tx_dat, (UINT)rx_dat );
+
+    tx_data = tx_dat;
+    rx_data = rx_dat;
+
+    //データ送信
+    for (cnt = 0;cnt < dat_len;cnt++) {
+    	if (tx_dat != 0) {
+		    //データ書き込み
+		    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, (unsigned int)*tx_data);		// 0xA002_0068
+    	    tx_data++;
+    	} else
+    	{
+		    //空データ書き込み
+		    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, 0x00000000);		// 0xA002_0068
+    	}
+    	if (rx_dat == 0) {
+    		rx_data = &data;		// ダミーバッファ設定
+    	}
+	    //データ読み出し
+		if(cmd_pl_qspi_data_read(rx_data) != 0) {
+			printf(" RX FIFO timeout(Data read:%d/%d)(pl qspi) \n",cnt,(UINT)dat_len);
+			rcode = 1;
+		}
+		rx_data++;
+    }
+	return rcode;
+}
+
+//--------------------------
+// PL CS ディセーブル
+//--------------------------
+void cmd_pl_qspi_cs_ini(void)
+{
+    DBGLOG_FMT("cmd_pl_qspi_cs_ini in \n");
+
+    // CS ディセーブルに設定
+    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CS, 0xFFFFFFFF);		// 0xA002_0070
+    //データ送信ディセーブル設定
+    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000186);		// 0xA002_0060
+}
+
+
+//--------------------------
+// PL CS イネーブル
+//--------------------------
+void cmd_pl_qspi_cs_en(unsigned long cs)
+{
+    unsigned long data;
+    
+    DBGLOG_FMT("cmd_pl_qspi_cs_en in (cs:%x)\n", (UINT)cs );
+
+    // CS イネーブルに設定
+	data = ~(0x00000001 << cs);
+    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CS, data);				// 0xA002_0070
+    //データ送信イネーブル設定
+    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000086);		// 0xA002_0060
+}
+
+//--------------------------
+// PL Write Enableコマンド設定
+//--------------------------
+void cmd_pl_qspi_write_en(void)
+{
+    unsigned char data;
+    
+    DBGLOG_FMT("cmd_pl_qspi_write_en in \n");
+
+    //SPIシステムイネーブルをイネーブル
+    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000186);		// 0xA002_0060
+    //WRITE ENABLEコマンド
+    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, 0x00000006);		// 0xA002_0068
+
+    //csイネーブル
+    cmd_pl_qspi_cs_en(0);	// SS0固定
+	//ダミーリード
+	if(cmd_pl_qspi_data_read(&data) != 0) {
+		printf(" RX FIFO timeout(write EN)(pl qspi) \n");
+	}
+	// CS ディセーブルに設定
+    cmd_pl_qspi_cs_ini();
+}
+
+//--------------------------
+// PL Flag Status Register確認
+//--------------------------
+int cmd_pl_qspi_streg_chk(void)
+{
+    unsigned int count;
+    unsigned char data, stReg;
+    
+    DBGLOG_FMT("cmd_pl_qspi_streg_chk in \n");
+
+    // Status Register(Bit0:write in progress) = "0"であることを確認
+	stReg = 0x01; //初期値として"1"(in progress)を設定
+	count = 0;
+	while (1) {
+		//Status register readコマンド
+		f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, 0x00000005);		// 0xA002_0068
+		//データリード用のダミー書き込み
+		f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, 0x00000000);		// 0xA002_0068
+
+		//csイネーブル
+	    cmd_pl_qspi_cs_en(0);	// SS0固定
+
+		//ダミーリード
+		if(cmd_pl_qspi_data_read(&data) != 0) {
+			printf(" RX FIFO timeout(Status register command read)(pl qspi) \n");
+		}
+		//Status registerデータリード
+		if(cmd_pl_qspi_data_read(&stReg) != 0) {
+			printf(" RX FIFO timeout(Status register data read)(pl qspi) \n");
+		}
+		// CS ディセーブルに設定
+	    cmd_pl_qspi_cs_ini();
+		
+		if ((stReg & 0x01) == 0x00) {
+			break ;			// Status Register確認完了
+		}
+		// 待ち合わせ必要？
+        udelay(1*100);  //100us wait
+		if(count++ > 10000000) return 1;		// 一定回数確認して書き込み完了にならなければ抜ける
+	}
+	//SPIシステムイネーブルをディセーブル
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000184);		// 0xA002_0060
+
+	return 0;
+}
+
+//--------------------------
+// PL QSPI 初期設定(FIFO クリア／Flash Dummy cycle設定)
+//--------------------------
+void cmd_pl_qspi_ini(void)
+{
+static int PL_QSPI_INI_FLG = 0;
+
+	if (PL_QSPI_INI_FLG != 0) return;		//初期化されていれば、処理しない
+
+	DBGLOG_FMT("cmd_pl_qspi_ini in \n");
+
+/* FIFOクリア */
+	// SPIソフトリセット
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_RESET, 0x0000000A);		// 0xA002_0040
+	// Wait 1us以上
+    udelay(1);  // 1us wait
+	//SPIシステムイネーブルをディセーブル
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000184);		// 0xA002_0060
+    // CS ディセーブルに設定
+    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CS, 0xFFFFFFFF);		// 0xA002_0070
+	//FIFOリセット
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x000001E4);		// 0xA002_0060
+    //SPIシステムイネーブルをイネーブル
+/* Flash Dummy cycle設定のWRITE ENABLE コマンドで実施
+ *	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000186);		// 0xA002_0060
+ */
+	// Wait そのまま走らせるとWriteENコマンドのダミーリードが出来ないので、待ち合わせ
+    udelay(1*1000);  // 1ms wait
+
+/* Flash Dummy cycle設定 */
+	// WRITE ENABLE コマンド
+	cmd_pl_qspi_write_en();
+	//write status/configuration register コマンド
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, 0x00000001);		// 0xA002_0068
+	//Status Register設定値
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, 0x00000040);		// 0xA002_0068
+	//Configuration Register設定値
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, 0x00000047);		// 0xA002_0068
+	//csイネーブル
+    cmd_pl_qspi_cs_en(0);	// SS0固定
+	//ダミーリード 3回
+	if(cmd_pl_qspi_data_read_cycle(3) != 0) {
+		printf(" RX FIFO timeout(Dummy cycle set)(pl qspi) \n");
+	}
+	// CS ディセーブルに設定
+    cmd_pl_qspi_cs_ini();
+	// Flag Status Register確認
+	if (cmd_pl_qspi_streg_chk() != 0) {
+		printf(" RX FIFO timeout(Dummy cycle set)(pl qspi) \n");
+	}
+	PL_QSPI_INI_FLG = 1;		//初期化処理完了
+}	
+
+
+//-----------------------------------------------------------------------
+// PL QSPI用アクセスエリア設定コマンド
+//-----------------------------------------------------------------------
+int do_plqspif_sect_set (unsigned long upper) {
+
+    DBGLOG_FMT("do_plqspif_sect_set in ( upper:%x )\n", (UINT)upper);
+    
+	// WRITE ENABLE コマンド
+	cmd_pl_qspi_write_en();
+
+    // write expanded address register コマンド
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, 0x000000C5);		// 0xA002_0068
+	//Configuration Register設定値
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, upper);				// 0xA002_0068
+	//csイネーブル
+    cmd_pl_qspi_cs_en(0);	// SS0固定
+	//ダミーリード 2回
+	if(cmd_pl_qspi_data_read_cycle(2) != 0) {
+		printf(" RX FIFO timeout(sect set)(pl qspi) \n");
+	}
+	// CS ディセーブルに設定
+    cmd_pl_qspi_cs_ini();
+	//SPIシステムイネーブルをディセーブル
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000184);		// 0xA002_0060
+
+    return 0;
+}
+
+
+
+//====================================================================
+// PL フラッシュ QSPIアクセス
+//====================================================================
+//-----------------------------------------------------------------------
+// PL qspi flash 読み込み
+//-----------------------------------------------------------------------
+int cmd_plqspif_read_part( unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len) {
+    unsigned long tx_dat[8];
+    unsigned long address1,address2;
+    unsigned long cnt;
+
+    DBGLOG_FMT("cmd_plqspif_read_part in ( cs:%x add:%x fadd:%x len:%d\n)\n", (UINT)cs, (UINT)add, (UINT)fadd, (int)len );
+    
+    // read コマンド
+    tx_dat[0] = 0x03;  //spi
+    // アドレス
+    address1 = fadd >> 8;
+    address2 = address1 >> 8;
+    tx_dat[1] = address2 & 0x000000FF;
+    tx_dat[2] = address1 & 0x000000FF;
+    tx_dat[3] = fadd & 0x000000FF;
+
+    //SPIシステムイネーブルをイネーブル
+    f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000186);		// 0xA002_0060
+	for (cnt = 0; cnt < 4; cnt++) {
+		//readコマンド+アドレス用送信
+		f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, tx_dat[cnt]);		// 0xA002_0068
+	}
+	//csイネーブル
+    cmd_pl_qspi_cs_en(0);	// SS0固定
+	//ダミーリード 4回
+	if(cmd_pl_qspi_data_read_cycle(4) != 0) {
+		printf(" RX FIFO timeout(Read command set)(pl qspi) \n");
+	}
+
+	//データリード
+	if(cmd_pl_qspi(len, 0, (unsigned char*)add) != 0) {
+		printf(" RX FIFO timeout(Data Read)(pl qspi) \n");
+	}
+
+	// CS ディセーブルに設定
+    cmd_pl_qspi_cs_ini();
+	//SPIシステムイネーブルをディセーブル
+	f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_CNT, 0x00000184);		// 0xA002_0060
+
+    return 0;
+}
+
+//-----------------------------------------------------------------------
+// PL qspi flash 読み込み(256分割)
+//-----------------------------------------------------------------------
+int cmd_plqspif_read_half( unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len) {
+    unsigned long s_len,c_len;
+    int rtn = 0;
+
+    DBGLOG_FMT("cmd_plqspif_read_half in (cs:%x add:%x fadd:%x len:%x)\n", (UINT)cs, (UINT)add, (UINT)fadd, (UINT)len ) ;
+
+	s_len = 0x100-(fadd % 0x100);	//最初の受信データ長設定（フラッシュの0x100番地まで）
+	if (s_len > len) {
+		s_len = len;				//全体データ長が短ければ、全体データ長分設定
+	}
+	for ( c_len =0; c_len < len; ) {
+		if(cmd_plqspif_read_part(cs, add+c_len, fadd+c_len, s_len) != 0) {
+			rtn = 1;
+		}
+		c_len += s_len;				//受信済みデータ長更新
+		if (len >= (c_len + 0x100)) {
+			s_len = 0x100;			//受信データ最大256byte
+		} else
+		{
+			s_len = len - c_len;	//残りサイズ
+		}
+	}
+
+    return rtn;
+}
+
+//-----------------------------------------------------------------------
+// PL qspi flash 読み込み(full)(SPI初期設定を含む)
+//-----------------------------------------------------------------------
+int cmd_plqspif_read( unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len) {
+    unsigned long st_fadd,end_fadd,seg;
+    unsigned long st_add;
+    unsigned long dat_len;
+    
+    DBGLOG_FMT("cmd_plqspif_read in (cs:0x%x add:0x%x, fadd:0x%x len:0x%x)\n", (UINT)cs, (UINT)add, (UINT)fadd, (UINT)len );
+
+    st_fadd = fadd;
+    end_fadd = fadd + len - 1;
+    st_add = add;
+
+    // 初期設定
+    cmd_pl_qspi_ini();
+//    printf("PL qspi frash read\n");
+    
+	for(seg = (fadd >> 24);seg <= (end_fadd >> 24); seg++) {
+		if(seg == (end_fadd >> 24)) {
+			// 最後のブロックは残りサイズ
+			dat_len = end_fadd - st_fadd + 1;
+		} else
+		{
+			// 最初/途中のブロックは境界から先頭までのサイズ
+			dat_len = 0x01000000 - (st_fadd & 0x00FFFFFF);
+		}
+		//アクセスエリア設定
+        do_plqspif_sect_set(seg);
+		if(cmd_plqspif_read_half(cs,st_add,st_fadd,dat_len) != 0) {
+			printf("PL qspi frash read NG segment:%d\n",(UINT)seg);
+		}
+		st_fadd += dat_len;		// フラッシュ読み出し先更新
+		st_add += dat_len;		// バッファ書き込み先更新
+	}
+//    printf("\nread end\n");
+
+    return 0;
+}
+
+//-----------------------------------------------------------------------
+// PL qspi flash 書き込み
+//-----------------------------------------------------------------------
+int cmd_plqspif_write_part( unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len) {
+    unsigned long tx_dat[5];
+    unsigned long address1,address2;
+    unsigned long cnt;
+
+    DBGLOG_FMT("cmd_plqspif_write_part in (cs:%x add:%x fadd:%x len:%x)\n", (UINT)cs, (UINT)add, (UINT)fadd, (UINT)len ) ;
+    
+    // write コマンド
+    tx_dat[0] = 0x02;  //spi
+
+    // アドレス
+    address1 = fadd >> 8;
+    address2 = address1 >> 8;
+    tx_dat[1] = address2 & 0x000000FF;
+    tx_dat[2] = address1 & 0x000000FF;
+    tx_dat[3] = fadd & 0x000000FF;
+	tx_dat[4] = *((unsigned char*)add) & 0x000000FF;		//FLASHへのWriteデータ(1byte目)
+	add++;		//1byte目取り出したので更新
+	len--;		//サイズも減算
+
+	// WRITE ENABLE コマンド
+	cmd_pl_qspi_write_en();
+    for(cnt = 0; cnt < 5; cnt++) {
+		//writeコマンド+アドレス+データ1byte目送信
+		f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, tx_dat[cnt]);		// 0xA002_0068
+    }
+	//csイネーブル
+    cmd_pl_qspi_cs_en(0);	// SS0固定
+	//ダミーリード 5回
+	if(cmd_pl_qspi_data_read_cycle(5) != 0) {
+		printf(" RX FIFO timeout(Write command set)(pl qspi) \n");
+	}
+
+	//データライト
+	if(cmd_pl_qspi(len, (unsigned char*)add, 0) != 0) {
+		printf(" RX FIFO timeout(Data Write)(pl qspi) \n");
+	}
+
+	// CS ディセーブルに設定
+    cmd_pl_qspi_cs_ini();
+	// Flag Status Register確認
+	if (cmd_pl_qspi_streg_chk() != 0) {
+		printf(" RX FIFO timeout(Write command)(pl qspi) \n");
+	}
+
+    return 0;
+}
+
+//-----------------------------------------------------------------------
+// PL qspi flash 書き込み(256分割)
+//-----------------------------------------------------------------------
+int cmd_plqspif_write_half( unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len) {
+    unsigned long s_len,c_len;
+    int rtn = 0;
+
+    DBGLOG_FMT("cmd_plqspif_write_half in (cs:%x add:%x fadd:%x len:%x)\n", (UINT)cs, (UINT)add, (UINT)fadd, (UINT)len ) ;
+
+	s_len = 0x100-(fadd % 0x100);	//最初の送信データ長設定（フラッシュの0x100番地まで）
+	if (s_len > len) {
+		s_len = len;				//全体データ長が短ければ、全体データ長分設定
+	}
+	for ( c_len =0; c_len < len; ) {
+		if(cmd_plqspif_write_part(cs, add+c_len, fadd+c_len, s_len) != 0) {
+			rtn = 1;
+		}
+		c_len += s_len;				//送信済みデータ長更新
+		if (len >= (c_len + 0x100)) {
+			s_len = 0x100;			//送信データ最大256byte
+		} else
+		{
+			s_len = len - c_len;	//残りサイズ
+		}
+	}
+
+    return rtn;
+}
+
+//-----------------------------------------------------------------------
+// PL qspi flash 書き込み(full)(SPI初期設定を含む)
+//-----------------------------------------------------------------------
+int cmd_plqspif_write(unsigned long cs, unsigned long add, unsigned long fadd, unsigned long len) {
+    unsigned long st_fadd,end_fadd,seg;
+    unsigned long st_add;
+    unsigned long dat_len;
+
+    DBGLOG_FMT("cmd_plqspif_write in (cs:0x%x add:0x%x fadd:0x%x len:0x%x)\n", (UINT)cs, (UINT)add, (UINT)fadd, (UINT)len );
+    
+    st_fadd = fadd;
+    end_fadd = fadd + len - 1;
+    st_add = add;
+
+    // 初期設定
+    cmd_pl_qspi_ini();
+//    printf("PL qspi frash write\n");
+
+	for(seg = (fadd >> 24);seg <= (end_fadd >> 24); seg++) {
+		if(seg == (end_fadd >> 24)) {
+			// 最後のブロックは残りサイズ
+			dat_len = end_fadd - st_fadd + 1;
+		} else
+		{
+			// 最初/途中のブロックは境界から先頭までのサイズ
+			dat_len = 0x01000000 - (st_fadd & 0x00FFFFFF);
+		}
+		//アクセスエリア設定
+        do_plqspif_sect_set(seg);
+		if(cmd_plqspif_write_half(cs,st_add,st_fadd,dat_len) != 0) {
+			printf("PL qspi frash write NG segment:%d\n",(UINT)seg);
+		}
+		st_fadd += dat_len;		// フラッシュ書き込み先更新
+		st_add += dat_len;		// バッファ読み出し先更新
+	}
+//    printf("\nwrite end\n");
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------
+// PL qspi flash セクタ消去
+//-----------------------------------------------------------------------
+int cmd_plqspif_sect_erase(unsigned long cs, unsigned long sect_add) {
+    unsigned long tx_dat[5];
+    unsigned long address0,address1,address2;
+    unsigned long cnt;
+    unsigned char data;
+
+    DBGLOG_FMT("cmd_plqspif_sect_erase in (cs:0x%x sect_add:0x%x)\n", (UINT)cs, (UINT)sect_add) ;
+    
+    // FLAG STATUS register CLEAR コマンド
+    address2 = 0;
+    address1 = 0;
+    address0 = sect_add & 0x000000FF;
+
+    tx_dat[0] = 0xD8;
+    tx_dat[1] = address0;
+    tx_dat[2] = address1;
+    tx_dat[3] = address2;
+
+	//フェールセーフ目的でダミーリード
+	cmd_plqspif_read_half(cs, (unsigned long)&data, (sect_add << 16), 1);
+
+	// WRITE ENABLE コマンド
+	cmd_pl_qspi_write_en();
+    for(cnt = 0; cnt < 4; cnt++) {
+		//SECTOR ERASEコマンド+アドレス送信
+		f_boot_reg_write(PL_QSPI_BASE + PL_QSPI_TX, tx_dat[cnt]);		// 0xA002_0068
+    }
+	//csイネーブル
+    cmd_pl_qspi_cs_en(0);	// SS0固定
+	//ダミーリード 4回
+	if(cmd_pl_qspi_data_read_cycle(4) != 0) {
+		printf(" RX FIFO timeout(Erase command set)(pl qspi) \n");
+	}
+
+	// CS ディセーブルに設定
+    cmd_pl_qspi_cs_ini();
+	// Flag Status Register確認
+	if (cmd_pl_qspi_streg_chk() != 0) {
+		printf(" RX FIFO timeout(Erase command)(pl qspi) \n");
+	}
+
+    return 0;
+}
+
+
+//-----------------------------------------------------------------------
+// PL qspi flash 消去
+//-----------------------------------------------------------------------
+int cmd_plqspif_erase_half(unsigned long cs, unsigned long add, unsigned long len) {
+    unsigned long address1,address2;
+
+    unsigned long cnt;
+    int rcode = 0;
+
+    DBGLOG_FMT("cmd_plqspif_erase_half in [cs:%x add:0x%08x len:0x%08x]\n", (UINT)cs, (UINT)add, (UINT)len );
+    
+    address1 = add >> 16;
+    address2 = (add + len - 1) >> 16;
+
+    for(cnt=address1;cnt<=address2;cnt++) {
+        rcode = cmd_plqspif_sect_erase (cs, cnt);
+//        printf("*");
+    }
+
+    return rcode;
+}
+
+//-----------------------------------------------------------------------
+// PL qspi flash 消去(full)(SPI初期設定を含む)
+//-----------------------------------------------------------------------
+int cmd_plqspif_erase(unsigned long cs, unsigned long add, unsigned long len) {
+    unsigned long st_fadd,end_fadd,seg;
+    unsigned long dat_len;
+    int rcode = 0;
+
+    DBGLOG_FMT("cmd_plqspif_erase in [cs:%x add:0x%08x len:0x%08x]\n", (UINT)cs, (UINT)add, (UINT)len );
+
+    
+    st_fadd = add;
+    end_fadd = add + len - 1;
+
+    // 初期設定
+    cmd_pl_qspi_ini();
+//    printf("PL qspi frash erase\n");
+
+	for(seg = (add >> 24);seg <= (end_fadd >> 24); seg++) {
+		if(seg == (end_fadd >> 24)) {
+			// 最後のブロックは残りサイズ
+			dat_len = end_fadd - st_fadd + 1;
+		} else
+		{
+			// 最初/途中のブロックは境界から先頭までのサイズ
+			dat_len = 0x01000000 - (st_fadd & 0x00FFFFFF);
+		}
+		//アクセスエリア設定
+        do_plqspif_sect_set(seg);
+		if(cmd_plqspif_erase_half(cs,st_fadd,dat_len) != 0) {
+			printf("PL qspi frash erase NG segment:%d\n",(UINT)seg);
+		}
+		st_fadd += dat_len;		// フラッシュ消去先更新
+	}
+//    printf("\nerase end\n");
+
+    return rcode;
+}
+//RRH-007 boot alpha)miyazaki ppcEOL chg end mrruからの展開
+
+
+/*
+ * Syntax:
+ *	i2c md {i2c_chip} {addr}{.0, .1, .2} {len}
+ */
+int rrh_eeprom_read(unsigned long param_top, unsigned long param_size)
+{
+	int				i;
+	int				line_top_pos	;	/* １行毎の先頭オフセット		*/
+	char			hexdmp[50] 	;
+	char			symdmp[20] 	;
+	char			cnvbuf[4]		;
+	char			readbuf[3]		;
+	int				read_pos		;
+	
+	/*
+	 * Print the lines.
+	 *
+	 * We buffer all read data, so we can make sure data is read only
+	 * once.
+	 */
+
+	DBGLOG_FMT("rrh_eeprom_read in  addr:%08x  length:%x(%d)\n", (UINT)param_top, (UINT)param_size, (int)param_size );
+
+	
+	/* 0x10 byte毎に読み込み、表示する */
+	/* addr : 読み込み開始アドレス */
+	/* length : 読み込みサイズ */
+	line_top_pos = ( param_top / 0x10 ) * 0x10 ;
+	read_pos	=	0;
+	DBGLOG_FMT("1st time line_top_pos : %08x\n", line_top_pos ) ;
+   	printf( "adr.  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f     0123456789abcdef\n" );
+	while(1) {
+
+		memset( hexdmp, 0, sizeof(hexdmp)) ;
+		memset( symdmp, 0, sizeof(symdmp)) ;
+		for( i = 0 ; i < 0x10 ; i++ ) {	/* １行分のサイズ	*/
+
+			if( ( line_top_pos + i ) < param_top ) {	/* 開始位置前の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " ");
+			}
+			else if( ( line_top_pos + i ) >= param_top + param_size ) {	/* 終了位置後の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " " );
+			}
+			else {		/* 以外*/
+			
+				/* EEPROMより１バイト読み込み */
+				if( f_boot_eeprom_read( param_top + read_pos, readbuf ) != D_BOOT_OK) {
+					break;
+				}
+
+
+				/* １６進表示変換		*/
+				sprintf( cnvbuf, "%02x ", (unsigned int)(readbuf[0]&0xff) ) ;
+				strcat( hexdmp, cnvbuf ) ;
+
+				/* ASCII表示変換(文字表示できる分のみASCII文字で表示	*/
+				if( readbuf[0] >= 0x20 && readbuf[0] <= 0x7e )  {
+					sprintf( cnvbuf, "%c", readbuf[0] );
+					strcat( symdmp, cnvbuf ) ;
+				}
+				else {
+					strcat( symdmp, "." ) ;	/* 表示不可能文字分 */
+				}
+				
+				read_pos++;
+			}
+		}
+		/* 表示 */
+		printf("%04x: %s  [%s]\n", line_top_pos, hexdmp, symdmp );
+		/* 次の為の更新 */
+		line_top_pos += 0x10 ;	/* */
+		
+		/* 終了判定 */
+		if( line_top_pos >= param_top + param_size || line_top_pos >= 0x800) {	/* 表示開始位置から表示サイズ分を超えた？ */
+			break;
+		}
+	
+	}
+	return 0;
+}
+
+
+/*
+ * Syntax:
+ *	i2c md {i2c_chip} {addr}{.0, .1, .2} {len}
+ */
+int rrh_eeprom_read2(unsigned long param_top, unsigned long param_size)
+{
+	int				i;
+	int				line_top_pos	;	/* １行毎の先頭オフセット		*/
+	char			hexdmp[50] 	;
+	char			symdmp[20] 	;
+	char			cnvbuf[4]		;
+	char			readbuf[3]		;
+	int				read_pos		;
+	int				rslt			;
+	
+	/*
+	 * Print the lines.
+	 *
+	 * We buffer all read data, so we can make sure data is read only
+	 * once.
+	 */
+
+	rslt = 0xFF ;
+
+	DBGLOG_FMT("rrh_eeprom_read in  addr:%08x  length:%x(%d)\n", (UINT)param_top, (UINT)param_size, (int)param_size );
+
+	
+	/* 0x10 byte毎に読み込み、表示する */
+	/* addr : 読み込み開始アドレス */
+	/* length : 読み込みサイズ */
+	line_top_pos = ( param_top / 0x10 ) * 0x10 ;
+	read_pos	=	0;
+	DBGLOG_FMT("1st time line_top_pos : %08x\n", line_top_pos ) ;
+/*   	printf( "adr.  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f     0123456789abcdef\n" ); */
+	while(1) {
+
+		memset( hexdmp, 0, sizeof(hexdmp)) ;
+		memset( symdmp, 0, sizeof(symdmp)) ;
+		for( i = 0 ; i < 0x10 ; i++ ) {	/* １行分のサイズ	*/
+
+			if( ( line_top_pos + i ) < param_top ) {	/* 開始位置前の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " ");
+			}
+			else if( ( line_top_pos + i ) >= param_top + param_size ) {	/* 終了位置後の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " " );
+			}
+			else {		/* 以外*/
+			
+				/* EEPROMより１バイト読み込み */
+				if( f_boot_eeprom_read( param_top + read_pos, readbuf ) != D_BOOT_OK) {
+					break;
+				}
+
+				rslt = readbuf[0]&0xff ;
+
+				/* １６進表示変換		*/
+				sprintf( cnvbuf, "%02x ", (unsigned int)(readbuf[0]&0xff) ) ;
+				strcat( hexdmp, cnvbuf ) ;
+
+				/* ASCII表示変換(文字表示できる分のみASCII文字で表示	*/
+				if( readbuf[0] >= 0x20 && readbuf[0] <= 0x7e )  {
+					sprintf( cnvbuf, "%c", readbuf[0] );
+					strcat( symdmp, cnvbuf ) ;
+				}
+				else {
+					strcat( symdmp, "." ) ;	/* 表示不可能文字分 */
+				}
+				
+				read_pos++;
+			}
+		}
+		/* 表示 */
+		printf("%s\n", hexdmp );
+		/* 次の為の更新 */
+		line_top_pos += 0x10 ;	/* */
+		
+		/* 終了判定 */
+		if( line_top_pos >= param_top + param_size || line_top_pos >= 0x800) {	/* 表示開始位置から表示サイズ分を超えた？ */
+			break;
+		}
+	
+	}
+	return rslt;
+}
+
+
+/* Write (fill) memory
+ *
+ * Syntax:
+ *	i2c mw {i2c_chip} {addr}{.0, .1, .2} {data} [{count}]
+ */
+int rrh_eeprom_write( unsigned long addr,  unsigned char byte)
+{
+	int ret ;
+//	if (i2c_write(chip, addr, alen, &byte, 1) != 0)
+	ret = f_boot_eeprom_write(addr, byte ) ;
+	DBGLOG_FMT("f_boot_eeprom_write ret:%d\n", ret ) ;
+	if( ret != D_BOOT_OK )	{
+		puts ("Error writing the chip.\n");
+		return 1;
+	}
+	return (D_BOOT_OK);
+}
+
+#if 0	//未使用
+/*	FLASH EOL対応 add start	*/
+//-----------------------------------------------------------------------
+// PL QSPI用ManufactureIDリードコマンド(FlashEOL対応)
+//-----------------------------------------------------------------------
+int do_plqspif_id_read (unsigned long cs) {
+    unsigned long len_dat;
+    unsigned long tx_dat[5];
+    unsigned long rx_dat[5];
+    int ret;
+
+    /*	変数とテーブル初期化	*/
+    ret=0xff;
+	/*	Manufacture ID is MICRON(0x20)	*/
+    plQspiInfo = QSPI_MICRON_ID;
+
+    // read ManufactureID コマンド
+    tx_dat[0] = 0x9F;
+    tx_dat[1] = 0x00;
+    len_dat = 2;
+    if(cmd_pl_qspi(cs, len_dat, tx_dat, rx_dat,0))
+    {
+		return ret;
+	}
+	/*	case of Manufacture ID is MACRONIX(0xc2)	*/
+    if( rx_dat[1] == QSPI_MACRONIX_ID )
+    {
+        plQspiInfo = rx_dat[1];
+    }
+    return rx_dat[1];
+}
+
+//-----------------------------------------------------------------------
+// ダミーサイクル設定コマンド(Micron)
+// dummy : dummy cycle(FlashEOL micron設定を分けた)
+//-----------------------------------------------------------------------
+int cmd_pl_qspi_dummy_set_Micron (unsigned long cs, unsigned long dummy) {
+    unsigned long len_dat;
+    unsigned long tx_dat[5];
+    unsigned long rx_dat[5];
+    unsigned long buf;
+
+    // read volatile configuration register コマンド
+    tx_dat[0] = 0x85;
+    tx_dat[1] = 0x00;
+    len_dat = 2;
+    if(cmd_pl_qspi (cs, len_dat, tx_dat, rx_dat,0)) return 1;
+
+    buf = rx_dat[1] & 0x0000000F;
+    buf |= ((dummy & 0x0000000F) << 4);
+
+    // write enable コマンド
+    tx_dat[0] = 0x06;
+    len_dat = 1;
+    if(cmd_pl_qspi (cs, len_dat, tx_dat, rx_dat,0)) return 1;
+
+    // write volatile configuration register コマンド
+    tx_dat[0] = 0x81;
+    tx_dat[1] = buf;
+    len_dat = 2;
+    if(cmd_pl_qspi (cs, len_dat, tx_dat, rx_dat,0)) return 1;
+
+    return 0;
+}
+
+//-----------------------------------------------------------------------
+// ダミーサイクル設定コマンド(macronix)
+// dummy : dummy cycle(FlashEOL macronix設定追加)
+//-----------------------------------------------------------------------
+int cmd_pl_qspi_dummy_set_Macronix (unsigned long cs, unsigned long dummy) {
+    unsigned long len_dat;
+    unsigned long tx_dat[5];
+    unsigned long rx_dat[5];
+    unsigned long buf;
+
+    if(dummy < 5){
+        buf = 0x07;
+    }else if(dummy < 7){
+        buf = 0x47;
+    }else if(dummy < 9){
+        buf = 0x87;
+    }else{
+        buf = 0xC7;
+    }
+
+    // write enable コマンド
+    tx_dat[0] = 0x06;
+    len_dat = 1;
+    if(cmd_pl_qspi (cs, len_dat, tx_dat, rx_dat,0)) return 1;
+
+    // write status configuration register コマンド
+    tx_dat[0] = 0x01;
+    tx_dat[1] = 0x40;
+    tx_dat[2] = buf;
+    len_dat = 3;
+    if(cmd_pl_qspi (cs, len_dat, tx_dat, rx_dat,0)) return 1;
+
+    return 0;
+}
+
+//-----------------------------------------------------------------------
+// ダミーサイクル設定コマンド
+// dummy : dummy cycle(FlashEOL フラッシュIDで設定を分けた)
+//-----------------------------------------------------------------------
+//int cmd_pl_qspi_dummy_set (unsigned long bus, unsigned long cs, unsigned long dummy) {
+int cmd_pl_qspi_dummy_set (unsigned long cs, unsigned long dummy) {
+    int buf;
+
+    buf = 1;
+
+	printf("dummy cycle set start(ID=%x)\n", (unsigned int)plQspiInfo);
+	
+    if(plQspiInfo == QSPI_MICRON_ID){
+        buf = cmd_pl_qspi_dummy_set_Micron (cs, dummy);
+    }else if(plQspiInfo == QSPI_MACRONIX_ID){
+        buf = cmd_pl_qspi_dummy_set_Macronix (cs, dummy);
+    }else{
+        printf("Manufacture register NG!\n");
+        buf = cmd_pl_qspi_dummy_set_Micron (cs, dummy);
+    }
+    
+	printf("dummy cycle set complete\n");
+
+    return buf;
+}
+#endif	//未使用
+//--------------------------------------------------
+// WRITE STATUS REGISTER
+//--------------------------------------------------
+int cmd_rrh_wtst (void)
+{
+    unsigned int cnt;
+    unsigned char len_dat;
+    unsigned char tx_dat[4];
+    unsigned char rx_dat[4];
+
+#if 0 // 初期化・Flash ID判定、必要かも知れないが、止血
+	// QSPI RX FIFO初期化
+    if(cmd_ps_qspi_ini())
+    {
+		return 1;
+	}
+	/*	Flash ID取得未	*/
+	if(qspiFlashId == 0)
+	{
+		
+	}
+	/*	macronix	*/
+    if(qspiFlashId == QSPI_MACRONIX_ID)
+    {
+		printf("QPSI FLASH ID : MACRONIX(0x%08x)\n",qspiFlashId);
+#endif // 初期化・Flash ID判定、必要かも知れないが、止血
+    for (cnt = 0; cnt < 2; cnt++) { // CS2回（上位/下位）分設定する
+    	// write enable コマンド
+        tx_dat[0] = 0x06;
+        len_dat = 1;
+        if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, cnt))
+        {
+			printf("write enable Error\n");
+			return 1;
+		}
+        // write status config register コマンド
+        tx_dat[0] = 0x01;
+        tx_dat[1] = 0x42;  // status register
+        len_dat = 2;
+        if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, cnt))
+        {
+			printf("write status register Error\n");
+			return 1;
+		}
+        // read status config register コマンド
+        tx_dat[0] = 0x05;
+        tx_dat[1] = 0x00;  // read用ダミー
+        len_dat = 2;
+        while (1) {
+            if(cmd_ps_qspi (len_dat, tx_dat, rx_dat, cnt))
+            {
+                printf("read status register Error\n");
+                return 1;
+            }
+            if (!(rx_dat[1] & 0x01)) { // bit0が"0"になっていることを確認
+                break;
+            }
+        }
+    }
+#if 0 // Flash ID判定、必要かも知れないが、止血
+    }
+    /*	micron	*/
+    else if(qspiFlashId == QSPI_MICRON_ID)
+    {
+		printf("QPSI FLASH ID : MICRON(0x%08x)\n",qspiFlashId);
+        /*	micron用の処理を入れる(いまのところ処理なし)	*/
+    }
+    else	/*	unkown	*/
+    {
+	    printf("unkown QPSI FLASH ID : 0x%08x \n",qspiFlashId);
+        return 1;
+    }
+#endif // Flash ID判定、必要かも知れないが、止血
+	printf("write status register finish!!!\n");
+	return 0;
+}
+/*	FLASH EOL対応 add end	*/
+
+//--------------------------------------------------
+// RESET
+//--------------------------------------------------
+int cmd_rrh_reset (int kind)
+{
+	if (kind == 1) {
+		f_boot_reg_write(0xff5e0218, 0x00000010);
+	}else{	// 暫定対処
+		f_boot_cpld_write(0x28, 0x00) ;
+		f_boot_reg_write(0xa0000fa0, 0x00000000);
+		f_boot_reg_write(0xa0000ff8, 0x0000a55a);
+	}
+	return 0;
+}
+
+/*
+ * Syntax:
+ *	i2c md {i2c_chip} {addr}{.0, .1, .2} {len}
+ */
+int rrh_cpld_read(unsigned long param_top, unsigned long param_size)
+{
+	int				i;
+	int				line_top_pos	;	/* １行毎の先頭オフセット		*/
+	char			hexdmp[50] 	;
+	char			symdmp[20] 	;
+	char			cnvbuf[4]		;
+	char			readbuf[3]		;
+	int				read_pos		;
+	
+	/*
+	 * Print the lines.
+	 *
+	 * We buffer all read data, so we can make sure data is read only
+	 * once.
+	 */
+
+	DBGLOG_FMT("rrh_cpld_read in  addr:%08x  length:%x(%d)\n", (UINT)param_top, (UINT)param_size, (int)param_size );
+
+	
+	/* 0x10 byte毎に読み込み、表示する */
+	/* addr : 読み込み開始アドレス */
+	/* length : 読み込みサイズ */
+	line_top_pos = ( param_top / 0x10 ) * 0x10 ;
+	read_pos	=	0;
+	DBGLOG_FMT("1st time line_top_pos : %08x\n", line_top_pos ) ;
+   	printf( "adr.  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f     0123456789abcdef\n" );
+	while(1) {
+
+		memset( hexdmp, 0, sizeof(hexdmp)) ;
+		memset( symdmp, 0, sizeof(symdmp)) ;
+		for( i = 0 ; i < 0x10 ; i++ ) {	/* １行分のサイズ	*/
+
+			if( ( line_top_pos + i ) < param_top ) {	/* 開始位置前の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " ");
+			}
+			else if( ( line_top_pos + i ) >= param_top + param_size ) {	/* 終了位置後の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " " );
+			}
+			else {		/* 以外*/
+			
+				/* CPLDより１バイト読み込み */
+				if( f_boot_cpld_read( param_top + read_pos, readbuf ) != D_BOOT_OK) {
+					break;
+				}
+
+				/* １６進表示変換		*/
+				sprintf( cnvbuf, "%02x ", (unsigned int)(readbuf[0]&0xff) ) ;
+				strcat( hexdmp, cnvbuf ) ;
+
+				/* ASCII表示変換(文字表示できる分のみASCII文字で表示	*/
+				if( readbuf[0] >= 0x20 && readbuf[0] <= 0x7e )  {
+					sprintf( cnvbuf, "%c", readbuf[0] );
+					strcat( symdmp, cnvbuf ) ;
+				}
+				else {
+					strcat( symdmp, "." ) ;	/* 表示不可能文字分 */
+				}
+				
+				read_pos++;
+			}
+		}
+		/* 表示 */
+		printf("%04x: %s  [%s]\n", line_top_pos, hexdmp, symdmp );
+		/* 次の為の更新 */
+		line_top_pos += 0x10 ;	/* */
+		
+		/* 終了判定 */
+		if( line_top_pos >= param_top + param_size || line_top_pos >= 0x800) {	/* 表示開始位置から表示サイズ分を超えた？ */
+			break;
+		}
+	
+	}
+	return 0;
+}
+
+
+/* Write (fill) memory
+ *
+ * Syntax:
+ *	i2c mw {i2c_chip} {addr}{.0, .1, .2} {data} [{count}]
+ */
+int rrh_cpld_write( unsigned long addr,  unsigned char byte)
+{
+	int ret ;
+//	if (i2c_write(chip, addr, alen, &byte, 1) != 0)
+	ret = f_boot_cpld_write(addr, byte ) ;
+	DBGLOG_FMT("f_boot_cpld_write ret:%d\n", ret ) ;
+	if( ret != D_BOOT_OK )	{
+		puts ("Error writing the chip.\n");
+	}
+	return (D_BOOT_OK);
+}
+
+int rrh_pl_qspi_read(unsigned long param_top, unsigned long param_size)
+{
+	int				i;
+	int				line_top_pos	;	/* １行毎の先頭オフセット		*/
+	char			hexdmp[50] 	;
+	char			symdmp[20] 	;
+	char			cnvbuf[4]		;
+	char			readbuf[3]		;
+	int				read_pos		;
+	
+	/*
+	 * Print the lines.
+	 *
+	 * We buffer all read data, so we can make sure data is read only
+	 * once.
+	 */
+
+	DBGLOG_FMT("rrh_pl_qspi_read in  addr:%08x  length:%x(%d)\n", (UINT)param_top, (UINT)param_size, (int)param_size );
+
+	
+	/* 0x10 byte毎に読み込み、表示する */
+	/* addr : 読み込み開始アドレス */
+	/* length : 読み込みサイズ */
+	line_top_pos = ( param_top / 0x10 ) * 0x10 ;
+	read_pos	=	0;
+	DBGLOG_FMT("1st time line_top_pos : %08x\n", line_top_pos ) ;
+   	printf( "adr.  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f     0123456789abcdef\n" );
+	while(1) {
+
+		memset( hexdmp, 0, sizeof(hexdmp)) ;
+		memset( symdmp, 0, sizeof(symdmp)) ;
+		for( i = 0 ; i < 0x10 ; i++ ) {	/* １行分のサイズ	*/
+
+			if( ( line_top_pos + i ) < param_top ) {	/* 開始位置前の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " ");
+			}
+			else if( ( line_top_pos + i ) >= param_top + param_size ) {	/* 終了位置後の場合 */
+				strcat( hexdmp, "   ");
+				strcat( symdmp, " " );
+			}
+			else {		/* 以外*/
+			
+				/* PL_QSPIより１バイト読み込み */
+				if( cmd_plqspif_read( 0, (unsigned long)readbuf, param_top + read_pos, 1 ) != D_BOOT_OK) {
+					break;
+				}
+
+				/* １６進表示変換		*/
+				sprintf( cnvbuf, "%02x ", (unsigned int)(readbuf[0]&0xff) ) ;
+				strcat( hexdmp, cnvbuf ) ;
+
+				/* ASCII表示変換(文字表示できる分のみASCII文字で表示	*/
+				if( readbuf[0] >= 0x20 && readbuf[0] <= 0x7e )  {
+					sprintf( cnvbuf, "%c", readbuf[0] );
+					strcat( symdmp, cnvbuf ) ;
+				}
+				else {
+					strcat( symdmp, "." ) ;	/* 表示不可能文字分 */
+				}
+				
+				read_pos++;
+			}
+		}
+		/* 表示 */
+		printf("%04x: %s  [%s]\n", line_top_pos, hexdmp, symdmp );
+		/* 次の為の更新 */
+		line_top_pos += 0x10 ;	/* */
+		
+		/* 終了判定 */
+		if( line_top_pos >= param_top + param_size || line_top_pos >= 0x08000000) {	/* 表示開始位置から表示サイズ分を超えた？ */
+			break;
+		}
+	
+	}
+	return 0;
+}
+
+int rrh_pl_qspi_erase( unsigned long addr, unsigned long length)
+{
+	int ret ;
+	
+	if ((addr % 0x10000) != 0) {
+		puts ("Parameter Error addr NG.\n");
+		return 1;
+	}
+	if (((length % 0x10000) != 0) || (length == 0)) {
+		puts ("Parameter Error length NG.\n");
+		return 1;
+	}
+	if ((addr + length) > 0x08000000) {
+		puts ("Total Size Error (addr + length) NG.\n");
+		return 1;
+	}
+	
+	ret = cmd_plqspif_erase(0, addr, length) ;
+	DBGLOG_FMT("cmd_plqspif_erase ret:%d\n", ret ) ;
+	if( ret != D_BOOT_OK )	{
+		puts ("Error erase chip.\n");
+	}
+	return (D_BOOT_OK);
+}
+
+
+/*
+ * Syntax:
+ *	Flash Memory Program Load 
+ */
+unsigned long rrh_flash_addr(unsigned long param_top , unsigned long eep_read_data)
+{
+	unsigned long	flash_addr = NULL ;
+	/*
+	 * Print the lines.
+	 *
+	 * We buffer all read data, so we can make sure data is read only
+	 * once.
+	 */
+
+	DBGLOG_FMT("rrh_flash_addr in  Kind:%08x\n", (UINT)param_top );
+
+	switch(param_top) {
+		case	1 :			/* OS/Karnel Load */
+			if(eep_read_data != 0x01){
+				flash_addr = 0x04C00000 + 0x08000000 ;
+			}
+			else {
+				flash_addr = 0x04C00000 ;
+			}
+			break ;
+		case	2 :			/* FPGA-PL Load */
+			if(eep_read_data != 0x01){
+				flash_addr = 0x04000000 + 0x08000000 ;
+			}
+			else {
+				flash_addr = 0x04000000 ;
+			}
+			break ;
+		case	3 :			/* Slave FPGA Load */
+			if(eep_read_data != 0x01){
+				flash_addr = 0x0 + 0x02000000 ;
+			}
+			else {
+				flash_addr = 0x0 ;
+			}
+			break ;
+		defalt    :			/* その他 */
+			printf(" Error!! (Parameter Error)\n");
+			return 0;
+			break ;
+	}
+	printf("%08x\n",flash_addr) ;
+	return flash_addr ;
+}
+
+
+//#endif // RRH-DPDC -------------------------------------------------------
+/* RRH-001 boot alpha)nakajima-h add end */
+
