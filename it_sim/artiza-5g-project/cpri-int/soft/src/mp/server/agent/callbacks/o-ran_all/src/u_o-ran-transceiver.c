
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2019, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump-sdk 18.10-9

    User SIL-SA module
    bundle o-ran_all
    module o-ran-transceiver
    revision 2019-02-04
    namespace urn:o-ran:transceiver:1.0
    organization O-RAN Alliance
    Created: 2019-06-21T02:49:14Z
    CLI parameters:
        defnames true
        format uc
        indent 4
        module ietf-yang-types
        module ietf-inet-types
        module ietf-interfaces
        module iana-if-type
        module ietf-ip
        module iana-hardware
        module ietf-hardware
        module ietf-netconf-acm
        module o-ran-hardware
        module o-ran-software-management
        module o-ran-interfaces
        module o-ran-transceiver
        module o-ran-mplane-int
        module o-ran-dhcp
        module o-ran-compression-factors
        module o-ran-uplane-conf
        module o-ran-module-cap
        module o-ran-processing-element
        module o-ran-performance-management
        module o-ran-fm
        module o-ran-lbm
        module o-ran-supervision
        module o-ran-beamforming
        module o-ran-operations
        module o-ran-usermgmt
        module o-ran-sync
        sil-bundle o-ran_all
        sil-get2
        sil-sa
        unified true

 */

#include <string.h>
#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_val.h"

/* SIL bundle: o-ran_all */
#include "y_ietf-yang-types.h"
#include "u_ietf-yang-types.h"
#include "y_ietf-inet-types.h"
#include "u_ietf-inet-types.h"
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_iana-if-type.h"
#include "u_iana-if-type.h"
#include "y_ietf-ip.h"
#include "u_ietf-ip.h"
#include "y_iana-hardware.h"
#include "u_iana-hardware.h"
#include "y_ietf-hardware.h"
#include "u_ietf-hardware.h"
#include "y_ietf-netconf-acm.h"
#include "u_ietf-netconf-acm.h"
#include "y_o-ran-hardware.h"
#include "u_o-ran-hardware.h"
#include "y_o-ran-software-management.h"
#include "u_o-ran-software-management.h"
#include "y_o-ran-interfaces.h"
#include "u_o-ran-interfaces.h"
#include "y_o-ran-transceiver.h"
#include "u_o-ran-transceiver.h"
#include "y_o-ran-mplane-int.h"
#include "u_o-ran-mplane-int.h"
#include "y_o-ran-dhcp.h"
#include "u_o-ran-dhcp.h"
#include "y_o-ran-compression-factors.h"
#include "u_o-ran-compression-factors.h"
#include "y_o-ran-uplane-conf.h"
#include "u_o-ran-uplane-conf.h"
#include "y_o-ran-module-cap.h"
#include "u_o-ran-module-cap.h"
#include "y_o-ran-processing-element.h"
#include "u_o-ran-processing-element.h"
#include "y_o-ran-performance-management.h"
#include "u_o-ran-performance-management.h"
#include "y_o-ran-fm.h"
#include "u_o-ran-fm.h"
#include "y_o-ran-lbm.h"
#include "u_o-ran-lbm.h"
#include "y_o-ran-supervision.h"
#include "u_o-ran-supervision.h"
#include "y_o-ran-beamforming.h"
#include "u_o-ran-beamforming.h"
#include "y_o-ran-operations.h"
#include "u_o-ran-operations.h"
#include "y_o-ran-usermgmt.h"
#include "u_o-ran-usermgmt.h"
#include "y_o-ran-sync.h"
#include "u_o-ran-sync.h"

#include "f_mpsw_msg_o-ran_transceiver_def.h"
#include "f_mpsw_msg_o-ran_transceiver_typ.h"
#include "i_o-ran-transceiver.h"

/* put your static variables here */


/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_name_edit
*
* Edit database object callback
* Path: /port-transceivers/port-transceiver-data/name
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_name_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    (void)scb; /* remove yumaworks warning */
    (void)msg; /* remove yumaworks warning */
    (void)newval; /* remove yumaworks warning */
    (void)curval; /* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s",
            __func__,
            agt_cbtype_name(cbtyp));
        log_info("\n   key_name=%s, key_port=%s",
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_STRING(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_STRING(curval) : 0;

    (void)newval_val; /* pgr0060 */ /* remove yumaworks warning */
    (void)curval_val; /* pgr0060 */ /* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_transceiver_port_transceivers_port_transceiver_data_name_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
        case OP_EDITOP_DELETE:
            /* Edit NGのためError応答 */
            res = ERR_NCX_OPERATION_NOT_SUPPORTED;
            if(LOGWARN) {
                log_warn("\n%s: Operation not supported, editop=%s", __func__, op_editop_name(editop));
            }
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_name_edit */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_present_get
*
* Get database object callback for leaf present
* Path: /port-transceivers/port-transceiver-data/present
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_present_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_present = 0;

    uint32 port_num;
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_present);
        }
        return res;
    }

    if (LOGDEV1) {
        log_dev1("\n   present(MSI data) = %d", cfm->transceiver_data[port_num].present);
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {
        v_present = true;
    }
    else {
        v_present = false;
    }

    /* add present to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_o_ran_transceiver_M_o_ran_transceiver,
        y_o_ran_transceiver_N_present,
        v_present,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_present_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_id_get
*
* Get database object callback for leaf vendor-id
* Path: /port-transceivers/port-transceiver-data/vendor-id
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_id_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_vendor_id = 0;

    uint32 port_num;
    xmlChar vendor_id_str[SAA_TRANS_VENDOR_ID_LEN+1];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_vendor_id);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   vendor-id(MSI data) = %s, length = %ld",
                cfm->transceiver_data[port_num].vendor_id,
                strlen((const char *)cfm->transceiver_data[port_num].vendor_id));
        }

        i_o_ran_transceiver_string_correction(vendor_id_str, cfm->transceiver_data[port_num].vendor_id, SAA_TRANS_VENDOR_ID_LEN);

        v_vendor_id = (const xmlChar *)vendor_id_str;

        /* add vendor_id to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_vendor_id,
            v_vendor_id,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_id_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_part_get
*
* Get database object callback for leaf vendor-part
* Path: /port-transceivers/port-transceiver-data/vendor-part
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_part_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_vendor_part = 0;

    uint32 port_num;
    xmlChar vendor_part_str[SAA_TRANS_VENDOR_PART_LEN+1];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_vendor_part);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   vendor-part(MSI data) = %s, length = %ld",
                cfm->transceiver_data[port_num].vendor_part,
                strlen((const char *)cfm->transceiver_data[port_num].vendor_part));
        }

        i_o_ran_transceiver_string_correction(vendor_part_str, cfm->transceiver_data[port_num].vendor_part, SAA_TRANS_VENDOR_PART_LEN);

        v_vendor_part = (const xmlChar *)vendor_part_str;

        /* add vendor_part to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_vendor_part,
            v_vendor_part,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_part_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_rev_get
*
* Get database object callback for leaf vendor-rev
* Path: /port-transceivers/port-transceiver-data/vendor-rev
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_rev_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_vendor_rev = 0;

    uint32 port_num;
    xmlChar vendor_rev_str[SAA_TRANS_VENDOR_REV_LEN+1];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_vendor_rev);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   vendor-rev(MSI data) = %s, length = %ld",
                cfm->transceiver_data[port_num].vendor_rev,
                strlen((const char *)cfm->transceiver_data[port_num].vendor_rev));
        }

        memset(vendor_rev_str, '\0', SAA_TRANS_VENDOR_REV_LEN+1);
        vendor_rev_str[0] = cfm->transceiver_data[port_num].vendor_rev[0];
        vendor_rev_str[1] = cfm->transceiver_data[port_num].vendor_rev[1];

        v_vendor_rev = (const xmlChar *)vendor_rev_str;

        /* add vendor_rev to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_vendor_rev,
            v_vendor_rev,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_vendor_rev_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_serial_no_get
*
* Get database object callback for leaf serial-no
* Path: /port-transceivers/port-transceiver-data/serial-no
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_serial_no_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_serial_no = 0;

    uint32 port_num;
    xmlChar serial_no_str[SAA_TRANS_SERIAL_NO_LEN+1];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_serial_no);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   serial-no(MSI data) = %s, length = %ld",
                cfm->transceiver_data[port_num].serial_no,
                strlen((const char *)cfm->transceiver_data[port_num].serial_no));
        }

        i_o_ran_transceiver_string_correction(serial_no_str, cfm->transceiver_data[port_num].serial_no, SAA_TRANS_SERIAL_NO_LEN);

        v_serial_no = (const xmlChar *)serial_no_str;

        /* add serial_no to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_serial_no,
            v_serial_no,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_serial_no_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_SFF8472_compliance_code_get
*
* Get database object callback for leaf SFF8472-compliance-code
* Path: /port-transceivers/port-transceiver-data/SFF8472-compliance-code
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_SFF8472_compliance_code_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_SFF8472_compliance_code = 0;

    uint32 port_num;
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_SFF8472_compliance_code);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   SFF8472-compliance-code(MSI data) = %d", cfm->transceiver_data[port_num].SFF8472_compliance_code);
        }

        switch(cfm->transceiver_data[port_num].SFF8472_compliance_code) {
        case 0x01:
            v_SFF8472_compliance_code = i_o_ran_transceiver_N_sfp8472_rev_9_3;
            break;
        case 0x02:
            v_SFF8472_compliance_code = i_o_ran_transceiver_N_sfp8472_rev_9_5;
            break;
        case 0x03:
            v_SFF8472_compliance_code = i_o_ran_transceiver_N_sfp8472_rev_10_2;
            break;
        case 0x04:
            v_SFF8472_compliance_code = i_o_ran_transceiver_N_sfp8472_rev_11_0;
            break;
        case 0x05:
            v_SFF8472_compliance_code = i_o_ran_transceiver_N_sfp8472_rev_11_3;
            break;
        case 0x06:
            v_SFF8472_compliance_code = i_o_ran_transceiver_N_sfp8472_rev_11_4;
            break;
        case 0x07:
            v_SFF8472_compliance_code = i_o_ran_transceiver_N_sfp8472_rev_12_0;
            break;
        default:
            v_SFF8472_compliance_code = i_o_ran_transceiver_N_sfp8472_rev_undefined;
            break;
        }

        /* add SFF8472_compliance_code to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_SFF8472_compliance_code,
            v_SFF8472_compliance_code,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_SFF8472_compliance_code_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_connector_type_get
*
* Get database object callback for leaf connector-type
* Path: /port-transceivers/port-transceiver-data/connector-type
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_connector_type_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_connector_type = 0;

    uint32 port_num;
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_connector_type);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   connector-type(MSI data) = %d", cfm->transceiver_data[port_num].connector_type);
        }

        switch(cfm->transceiver_data[port_num].connector_type) {
        case 0x01:
            v_connector_type = i_o_ran_transceiver_N_conn_type_sub_conn;
            break;
        case 0x06:
            v_connector_type = i_o_ran_transceiver_N_conn_type_fib_jck;
            break;
        case 0x07:
            v_connector_type = i_o_ran_transceiver_N_conn_type_luc_conn;
            break;
        case 0x08:
            v_connector_type = i_o_ran_transceiver_N_conn_type_mt_rj;
            break;
        case 0x09:
            v_connector_type = i_o_ran_transceiver_N_conn_type_mul_opt;
            break;
        case 0x0A:
            v_connector_type = i_o_ran_transceiver_N_conn_type_sg;
            break;
        case 0x0B:
            v_connector_type = i_o_ran_transceiver_N_conn_type_opt_pig;
            break;
        case 0x0C:
            v_connector_type = i_o_ran_transceiver_N_conn_type_mfpo_1x12;
            break;
        case 0x0D:
            v_connector_type = i_o_ran_transceiver_N_conn_type_mfpo_2x16;
            break;
        case 0x20:
            v_connector_type = i_o_ran_transceiver_N_conn_type_hss_2;
            break;
        case 0x21:
            v_connector_type = i_o_ran_transceiver_N_conn_type_copp_pig;
            break;
        case 0x22:
            v_connector_type = i_o_ran_transceiver_N_conn_type_rj45;
            break;
        case 0x23:
            v_connector_type = i_o_ran_transceiver_N_conn_type_no_sep_conn;
            break;
        case 0x24:
            v_connector_type = i_o_ran_transceiver_N_conn_type_mxc_2x16;
            break;
        default:
            v_connector_type = i_o_ran_transceiver_N_conn_type_unknown;
            break;
        }

        /* add connector_type to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_connector_type,
            v_connector_type,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_connector_type_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_nominal_bitrate_get
*
* Get database object callback for leaf nominal-bitrate
* Path: /port-transceivers/port-transceiver-data/nominal-bitrate
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_nominal_bitrate_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint32 v_nominal_bitrate = 0;

    uint32 port_num;
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_nominal_bitrate);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   nominal-bitrate(MSI data) = %d", cfm->transceiver_data[port_num].nominal_bitrate);
        }

        v_nominal_bitrate = (uint32)cfm->transceiver_data[port_num].nominal_bitrate;

        /* add nominal_bitrate to get2cb return_valQ */
        val_value_t *return_val = agt_make_uint_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_nominal_bitrate,
            v_nominal_bitrate,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_nominal_bitrate_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_low_bitrate_margin_get
*
* Get database object callback for leaf low-bitrate-margin
* Path: /port-transceivers/port-transceiver-data/low-bitrate-margin
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_low_bitrate_margin_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_low_bitrate_margin = 0;

    uint32 port_num;
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_low_bitrate_margin);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   low-bitrate-margin(MSI data) = %d", cfm->transceiver_data[port_num].low_bitrate_margin);
        }

        v_low_bitrate_margin = (uint8)cfm->transceiver_data[port_num].low_bitrate_margin;

        /* add low_bitrate_margin to get2cb return_valQ */
        val_value_t *return_val = agt_make_uint_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_low_bitrate_margin,
            v_low_bitrate_margin,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_low_bitrate_margin_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_high_bitrate_margin_get
*
* Get database object callback for leaf high-bitrate-margin
* Path: /port-transceivers/port-transceiver-data/high-bitrate-margin
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_high_bitrate_margin_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_high_bitrate_margin = 0;

    uint32 port_num;
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_high_bitrate_margin);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   high-bitrate-margin(MSI data) = %d", cfm->transceiver_data[port_num].high_bitrate_margin);
        }

        v_high_bitrate_margin = (uint8)cfm->transceiver_data[port_num].high_bitrate_margin;

        /* add high_bitrate_margin to get2cb return_valQ */
        val_value_t *return_val = agt_make_uint_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_high_bitrate_margin,
            v_high_bitrate_margin,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_high_bitrate_margin_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_rx_power_type_get
*
* Get database object callback for leaf rx-power-type
* Path: /port-transceivers/port-transceiver-data/rx-power-type
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_rx_power_type_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_rx_power_type = 0;

    uint32 port_num;
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_rx_power_type);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   rx-power-type(MSI data) = %d", cfm->transceiver_data[port_num].rx_power_type);
        }

        switch(cfm->transceiver_data[port_num].rx_power_type) {
        case 0:
            v_rx_power_type = i_o_ran_transceiver_N_rx_power_type_oma;
            break;
        case 1:
            v_rx_power_type = i_o_ran_transceiver_N_rx_power_type_avp;
            break;
        default:
            if(LOGWARN) {
                log_warn("\n%s: MSI parameter failed, %s=%d",
                    __func__, 
                    y_o_ran_transceiver_N_rx_power_type, 
                    cfm->transceiver_data[port_num].rx_power_type);
            }
            return ERR_NCX_OPERATION_FAILED;
        }

        /* add rx_power_type to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_rx_power_type,
            v_rx_power_type,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_rx_power_type_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_rx_power_get
*
* Get database object callback for leaf rx-power
* Path: /port-transceivers/port-transceiver-data/rx-power
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_rx_power_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_rx_power = 0;

    uint32 port_num;
    char rx_power_str[D_PARAM_NUM_MAX];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_rx_power);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   rx-power(MSI data) = %f", cfm->transceiver_data[port_num].rx_power);
        }

        snprintf(rx_power_str, D_PARAM_NUM_MAX, "%.4f", cfm->transceiver_data[port_num].rx_power);
        v_rx_power = (const xmlChar *)rx_power_str;

        /* add rx_power to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_rx_power,
            v_rx_power,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_rx_power_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_tx_power_get
*
* Get database object callback for leaf tx-power
* Path: /port-transceivers/port-transceiver-data/tx-power
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_tx_power_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_tx_power = 0;

    uint32 port_num;
    char tx_power_str[D_PARAM_NUM_MAX];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_tx_power);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   tx-power(MSI data) = %f", cfm->transceiver_data[port_num].tx_power);
        }

        snprintf(tx_power_str, D_PARAM_NUM_MAX, "%.4f", cfm->transceiver_data[port_num].tx_power);
        v_tx_power = (const xmlChar *)tx_power_str;

        /* add tx_power to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_tx_power,
            v_tx_power,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_tx_power_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_tx_bias_current_get
*
* Get database object callback for leaf tx-bias-current
* Path: /port-transceivers/port-transceiver-data/tx-bias-current
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_tx_bias_current_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_tx_bias_current = 0;

    uint32 port_num;
    char tx_bias_current_str[D_PARAM_NUM_MAX];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_tx_bias_current);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   tx-bias-current(MSI data) = %f", cfm->transceiver_data[port_num].tx_bias_current);
        }

        snprintf(tx_bias_current_str, D_PARAM_NUM_MAX, "%.4f", cfm->transceiver_data[port_num].tx_bias_current);
        v_tx_bias_current = (const xmlChar *)tx_bias_current_str;

        /* add tx_bias_current to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_tx_bias_current,
            v_tx_bias_current,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_tx_bias_current_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_voltage_get
*
* Get database object callback for leaf voltage
* Path: /port-transceivers/port-transceiver-data/voltage
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_voltage_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_voltage = 0;

    uint32 port_num;
    char voltage_str[D_PARAM_NUM_MAX];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_voltage);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   voltage(MSI data) = %f", cfm->transceiver_data[port_num].voltage);
        }

        snprintf(voltage_str, D_PARAM_NUM_MAX, "%.4f", cfm->transceiver_data[port_num].voltage);
        v_voltage = (const xmlChar *)voltage_str;

        /* add voltage to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_voltage,
            v_voltage,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_voltage_get */

/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_temperature_get
*
* Get database object callback for leaf temperature
* Path: /port-transceivers/port-transceiver-data/temperature
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_temperature_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{

    if (LOGINFO) {
        log_info("\nEnter %s: key_name=%s, key_port=%s",
            __func__,
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_temperature = 0;

    uint32 port_num;
    char temperature_str[D_PARAM_NUM_MAX];
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_REJ))];
    T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_TRANSCEIVER_GET_CFM *)buffer;

    res = i_o_ran_transceiver_send_msi(&buffer, k_port_transceivers_port_transceiver_data_interface_name, &port_num);
    if(res != NO_ERR)
    {
        if(LOGWARN) {
            log_warn("\n%s: Operation Failed to get param, %s", __func__, y_o_ran_transceiver_N_temperature);
        }
        return res;
    }

    if(cfm->transceiver_data[port_num].present == SAA_TRANS_SFP_PRESENT) {

        if (LOGDEV1) {
            log_dev1("\n   temperature(MSI data) = %f", cfm->transceiver_data[port_num].temperature);
        }

        snprintf(temperature_str, D_PARAM_NUM_MAX, "%.4f", cfm->transceiver_data[port_num].temperature);
        v_temperature = (const xmlChar *)temperature_str;

        /* add temperature to get2cb return_valQ */
        val_value_t *return_val = agt_make_leaf2(
            obj,
            y_o_ran_transceiver_M_o_ran_transceiver,
            y_o_ran_transceiver_N_temperature,
            v_temperature,
            &res);
        if (return_val) {
            getcb_add_return_val(get2cb, return_val);
        }

    }

    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_temperature_get */


/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_port_transceiver_data_edit
*
* Edit database object callback
* Path: /port-transceivers/port-transceiver-data
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_port_transceiver_data_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_port_transceivers_port_transceiver_data_interface_name,
    const xmlChar *k_port_transceivers_port_transceiver_data_port_number)
{
    status_t res = NO_ERR;

    (void)scb; /* remove yumaworks warning */
    (void)msg; /* remove yumaworks warning */
    (void)newval; /* remove yumaworks warning */
    (void)curval; /* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s",
            __func__,
            agt_cbtype_name(cbtyp));
        log_info("\n   key_name=%s, key_port=%s",
            k_port_transceivers_port_transceiver_data_interface_name,
            k_port_transceivers_port_transceiver_data_port_number);
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
        case OP_EDITOP_DELETE:
            /* Edit NGのためError応答 */
            res = ERR_NCX_OPERATION_NOT_SUPPORTED;
            if(LOGWARN) {
                log_warn("\n%s: Operation not supported, editop=%s", __func__, op_editop_name(editop));
            }
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_transceiver_port_transceivers_port_transceiver_data_edit */


/********************************************************************
* FUNCTION u_o_ran_transceiver_port_transceivers_edit
*
* Edit database object callback
* Path: /port-transceivers
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_port_transceivers_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    (void)scb; /* remove yumaworks warning */
    (void)msg; /* remove yumaworks warning */
    (void)newval; /* remove yumaworks warning */
    (void)curval; /* remove yumaworks warning */

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_transceiver_port_transceivers_edit */

/********************************************************************
* FUNCTION u_o_ran_transceiver_init
*
* initialize the o-ran-transceiver server instrumentation library
*
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    ncx_module_t *o_ran_transceiver_mod = NULL;

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    o_ran_transceiver_mod = ncx_find_module(modname, revision);
    if (o_ran_transceiver_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }

    /* put your module initialization code here */
    
    return res;

} /* u_o_ran_transceiver_init */

/********************************************************************
* FUNCTION u_o_ran_transceiver_init2
*
* SIL init phase 2: non-config data structures
* Called after running config is loaded
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_transceiver_init2 (void)
{
    status_t res = NO_ERR;

    /* put your init2 code here */
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    return res;

} /* u_o_ran_transceiver_init2 */

/********************************************************************
* FUNCTION u_o_ran_transceiver_cleanup
*    cleanup the server instrumentation library
*
********************************************************************/
void u_o_ran_transceiver_cleanup (void)
{

    /* put your cleanup code here */
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

} /* u_o_ran_transceiver_cleanup */

/* END SIL-SA u_o_ran_transceiver.c */
