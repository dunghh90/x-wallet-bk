
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2019, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump-sdk 18.10-9

    User SIL-SA module
    bundle o-ran_all
    module o-ran-module-cap
    revision 2019-02-04
    namespace urn:o-ran:module-cap:1.0
    organization O-RAN Alliance
    Created: 2019-06-21T02:49:14Z
    CLI parameters:
        defnames true
        format uc
        indent 4
        module ietf-yang-types
        module ietf-inet-types
        module ietf-interfaces
        module iana-if-type
        module ietf-ip
        module iana-hardware
        module ietf-hardware
        module ietf-netconf-acm
        module o-ran-hardware
        module o-ran-software-management
        module o-ran-interfaces
        module o-ran-transceiver
        module o-ran-mplane-int
        module o-ran-dhcp
        module o-ran-compression-factors
        module o-ran-uplane-conf
        module o-ran-module-cap
        module o-ran-processing-element
        module o-ran-performance-management
        module o-ran-fm
        module o-ran-lbm
        module o-ran-supervision
        module o-ran-beamforming
        module o-ran-operations
        module o-ran-usermgmt
        module o-ran-sync
        sil-bundle o-ran_all
        sil-get2
        sil-sa
        unified true

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_val.h"

/* SIL bundle: o-ran_all */
#include "y_ietf-yang-types.h"
#include "u_ietf-yang-types.h"
#include "y_ietf-inet-types.h"
#include "u_ietf-inet-types.h"
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_iana-if-type.h"
#include "u_iana-if-type.h"
#include "y_ietf-ip.h"
#include "u_ietf-ip.h"
#include "y_iana-hardware.h"
#include "u_iana-hardware.h"
#include "y_ietf-hardware.h"
#include "u_ietf-hardware.h"
#include "y_ietf-netconf-acm.h"
#include "u_ietf-netconf-acm.h"
#include "y_o-ran-hardware.h"
#include "u_o-ran-hardware.h"
#include "y_o-ran-software-management.h"
#include "u_o-ran-software-management.h"
#include "y_o-ran-interfaces.h"
#include "u_o-ran-interfaces.h"
#include "y_o-ran-transceiver.h"
#include "u_o-ran-transceiver.h"
#include "y_o-ran-mplane-int.h"
#include "u_o-ran-mplane-int.h"
#include "y_o-ran-dhcp.h"
#include "u_o-ran-dhcp.h"
#include "y_o-ran-compression-factors.h"
#include "u_o-ran-compression-factors.h"
#include "y_o-ran-uplane-conf.h"
#include "u_o-ran-uplane-conf.h"
#include "y_o-ran-module-cap.h"
#include "u_o-ran-module-cap.h"
#include "y_o-ran-processing-element.h"
#include "u_o-ran-processing-element.h"
#include "y_o-ran-performance-management.h"
#include "u_o-ran-performance-management.h"
#include "y_o-ran-fm.h"
#include "u_o-ran-fm.h"
#include "y_o-ran-lbm.h"
#include "u_o-ran-lbm.h"
#include "y_o-ran-supervision.h"
#include "u_o-ran-supervision.h"
#include "y_o-ran-beamforming.h"
#include "u_o-ran-beamforming.h"
#include "y_o-ran-operations.h"
#include "u_o-ran-operations.h"
#include "y_o-ran-usermgmt.h"
#include "u_o-ran-usermgmt.h"
#include "y_o-ran-sync.h"
#include "u_o-ran-sync.h"

#include "i_o-ran-module-cap.h"
#include "f_saa_com_init.h"

/* put your static variables here */

/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_compression_format_get
*
* Get database object callback for choice compression-format
* Path: /module-capability/ru-capabilities/format-of-iq-sample/compression-method-supported/compression-format
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_compression_format_get (
    getcb_get2_t *get2cb)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the active case; determined by the SIL or SIL-SA
     * callback based on instances in the system
     * It may be NULL if no active case and choice is optional */
    const xmlChar *active_case_modname = NULL;
    const xmlChar *active_case = y_o_ran_module_cap_N_block_floating_point;

    if (active_case == NULL) {
        return ERR_NCX_NO_INSTANCE;
    }

    /* set the active case return values */
    res = getcb_set_active_case(get2cb, active_case_modname, active_case);
    if (res != NO_ERR) {
        if(LOGWARN){
            log_warn("\n%s getcb_set_active_case is fail.", __func__);
        }
        return res;
    }

    /* get the template for the active case */
    obj_template_t *case_obj = 
        obj_find_child(obj, active_case_modname, active_case);
    if (case_obj == NULL) {
        if(LOGWARN){
            log_warn("\n%s case_obj is not found.", __func__);
        }
        return ERR_NCX_NOT_FOUND;
    }
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, case_obj);
    for (; childobj; childobj =getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */
        xmlChar *para_temp;
        if (!xml_strcmp(active_case, y_o_ran_module_cap_N_block_floating_point)) {
            if (!xml_strcmp(name, y_o_ran_module_cap_N_exponent)) {
                /* leaf exponent (uint8) */
                res = i_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_compression_format_get(&para_temp);
                if(res == NO_ERR)
                {
                    val_value_t *return_val = agt_make_leaf2(
                        case_obj,
                        active_case_modname,
                        y_o_ran_module_cap_N_exponent,
                        (const xmlChar *)para_temp,
                        &res);
                    if (return_val) {
                        getcb_add_return_val(get2cb, return_val);
                    }
                }
                else
                {
                    if(LOGWARN){
                        log_warn("\n%s exponent is NULL.", __func__);
                    }
                    return res;
                }
            }
        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_compression_format_get */

/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_get
*
* Get database object callback for list compression-method-supported
* Path: /module-capability/ru-capabilities/format-of-iq-sample/compression-method-supported
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_get (
    getcb_get2_t *get2cb)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    boolean getnext = FALSE;
    (void)getnext; /* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries; /* remove yumaworks warning */

    /* This list has no keys defined; return entry somehow
     * no need to call getcb_add_return_key */

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data = FALSE;

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        xmlChar *para_temp;
        if (!xml_strcmp(name, y_o_ran_module_cap_N_compression_type)) {
            /* leaf compression-type (enumeration) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_get_para(&para_temp, y_o_ran_module_cap_N_compression_type);
            if (LOGDEV1) {
                log_dev1("\n%s: para_temp=%s", __func__, para_temp);
            }
            if(res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_compression_type,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_bitwidth)) {
            /* leaf bitwidth (uint8) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_get_para(&para_temp, y_o_ran_module_cap_N_bitwidth);
            if (LOGDEV1) {
                log_dev1("\n%s: para_temp=%s", __func__, para_temp);
            }
            if(res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_bitwidth,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_compression_method_supported_get */

/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_get
*
* Get database object callback for container format-of-iq-sample
* Path: /module-capability/ru-capabilities/format-of-iq-sample
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_get (
    getcb_get2_t *get2cb)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        xmlChar *para_temp;
        if (!xml_strcmp(name, y_o_ran_module_cap_N_dynamic_compression_supported)) {
            /* leaf dynamic-compression-supported (boolean) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_get_bool(E_IQ_SAMPLE_CMPSUP, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d para_temp=%s", __func__, __LINE__, para_temp);
            }
            if (res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_dynamic_compression_supported,
                    (const xmlChar *)para_temp,
                    &res);
                if(return_val)
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_realtime_variable_bit_width_supported)) {
            /* leaf realtime-variable-bit-width-supported (boolean) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_get_bool(E_IQ_SAMPLE_BWTSUP, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d para_temp=%s", __func__, __LINE__, para_temp);
            }
            if (res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_realtime_variable_bit_width_supported,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_variable_bit_width_per_channel_supported)) {
            /* leaf variable-bit-width-per-channel-supported (boolean) */

        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_syminc_supported)) {
            /* leaf syminc-supported (boolean) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_get_bool(E_IQ_SAMPLE_SYMSUP, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d para_temp=%s", __func__, __LINE__, para_temp);
            }
            if (res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_syminc_supported,
                    (const xmlChar *)para_temp,
                    &res);
                if(return_val)
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_ru_capabilities_format_of_iq_sample_get */

/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get
*
* Get database object callback for list ul-mixed-num-required-guard-rbs
* Path: /module-capability/ru-capabilities/ul-mixed-num-required-guard-rbs
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_scs_a,
    boolean scs_a_fixed,
    boolean scs_a_present,
    const xmlChar *k_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_scs_b,
    boolean scs_b_fixed,
    boolean scs_b_present)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
        log_info("\n    present_scs_a=%d ,fixed_scs_a=%d", scs_a_present, scs_a_fixed);
        log_info("\n    key_name_scs_a=%s", k_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_scs_a);
        log_info("\n    present_scs_b=%d ,fixed_scs_b=%d", scs_b_present, scs_b_fixed);
        log_info("\n    key_name_scs_b=%s", k_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_scs_b);
    }

    boolean getnext = FALSE;

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries; /* remove yumaworks warning */

    /* key情報未登録の場合は処理を行わない */
    if(saa_upconf_max_scs_a_num_ul == 0 || saa_upconf_max_scs_b_num_ul == 0) {
        if (LOGDEV1) {
            log_dev1("\n%s:%d No key info, saa_upconf_max_scs_a_num_ul=%d, saa_upconf_max_scs_b_num_ul=%d",
                __func__,
                __LINE__,
                saa_upconf_max_scs_a_num_ul,
                saa_upconf_max_scs_b_num_ul);
        }
        return res;
    }

    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

    //if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
    //    return ERR_NCX_NO_INSTANCE;
    //}

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data_a = TRUE;
    boolean more_data_b = TRUE;

    const xmlChar *key_name = 0;
    xmlChar *key_name_temp_a = NULL;
    xmlChar *key_name_temp_b = NULL;

    /* Key check */
    uint32 curindex_a = 0;
    uint32 curindex_b = 0;
    boolean name_ok = FALSE;

    if ((scs_a_present)&&(scs_b_present)) {
        /* get key's number from key */
        res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_key(
            k_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_scs_a,
            k_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_scs_b,
            &curindex_a,
            &curindex_b);
        if(res == NO_ERR) {
            name_ok = TRUE;
        }
        else {
            return ERR_NCX_NO_INSTANCE;
        }
    }

    /* check validity of keys present */
    if (getnext) {
        if ((scs_a_fixed)||(scs_b_fixed)) {
            return ERR_NCX_NO_INSTANCE;
        }

        if (!scs_a_present) {
            // return first key [0]
            res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_first_key(SAA_MODCAP_KEY_SCS_A, &key_name_temp_a);
            if (res != NO_ERR) {
                return res;
            }
        }
        else {
            /* getnextなのでkey indexを1進める */
            curindex_a++;
            /* find the correct key to retrieve */
            if ((res == NO_ERR) &&  (((curindex_a < saa_upconf_max_scs_a_num_ul) && more_data_a) || ((curindex_b < saa_upconf_max_scs_b_num_ul) && more_data_b))) {

                if(curindex_a >=  saa_upconf_max_scs_a_num_ul) {
                    curindex_a--;
                    more_data_a = FALSE;
                }
                /* curindexで指定されたkeyを取得 */
                res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_target_key(curindex_a, SAA_MODCAP_KEY_SCS_A, &key_name_temp_a);
                if (res == NO_ERR) {
                    /* check if the current entry is the last one
                     * and set more_data flag accordingly
                     */
                    if (curindex_a == (saa_upconf_max_scs_a_num_ul - 1)) {
                        more_data_a = FALSE;
                    }
                }
                else {
                    return ERR_NCX_NO_INSTANCE;
                }
            }
            else {
                return ERR_NCX_NO_INSTANCE;
            }
        }

        if (!scs_b_present) {
            // return first key [0]
            res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_first_key(SAA_MODCAP_KEY_SCS_B, &key_name_temp_b);
            if (res != NO_ERR) {
                return res;
            }
        }
        else {
            /* getnextなのでkey indexを1進める */
            curindex_b++;
            /* find the correct key to retrieve */
            if ((res == NO_ERR) &&  (((curindex_a < saa_upconf_max_scs_a_num_ul) && more_data_a) || ((curindex_b < saa_upconf_max_scs_b_num_ul) && more_data_b))) {

            if(curindex_b >= saa_upconf_max_scs_b_num_ul) {
                curindex_b--;
                more_data_b = FALSE;
            }
                /* curindexで指定されたkeyを取得 */
                res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_target_key(curindex_b, SAA_MODCAP_KEY_SCS_B, &key_name_temp_b);
                if (res == NO_ERR) {
                    /* check if the current entry is the last one
                     * and set more_data flag accordingly
                     */
                    if (curindex_b == (saa_upconf_max_scs_b_num_ul - 1)) {
                        more_data_b = FALSE;
                    }
                }
                else {
                    return ERR_NCX_NO_INSTANCE;
                }
            }
            else {
                return ERR_NCX_NO_INSTANCE;
            }
        }
    }
    else{
        if (scs_a_present && name_ok) {
            res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_target_key(curindex_a, SAA_MODCAP_KEY_SCS_A, &key_name_temp_a);
            if(res != NO_ERR) {
                return ERR_NCX_NO_INSTANCE;
            }
        } else {
            /* get the first interface name */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_first_key(SAA_MODCAP_KEY_SCS_A, &key_name_temp_a);
            if (res != NO_ERR) {
                return res;
            }
        }
        if (scs_b_present && name_ok) {
            res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_target_key(curindex_b, SAA_MODCAP_KEY_SCS_B, &key_name_temp_b);
            if(res != NO_ERR) {
                return ERR_NCX_NO_INSTANCE;
            }
        } else {
            /* get the first interface name */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_first_key(SAA_MODCAP_KEY_SCS_B, &key_name_temp_b);
            if (res != NO_ERR) {
                return res;
            }
        }
    }
    if ((key_name_temp_a == NULL) || (key_name_temp_b == NULL)) {
        return NO_ERR;
    }

    key_name = (const xmlChar *)key_name_temp_a;

    /* if we are here, then the index is valid */
    obj_template_t *name_obj = obj_find_child(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_scs_a);
    if(name_obj == NULL) {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s:%d name_obj is NULL", __func__, __LINE__);
        }
        return ERR_NCX_NO_INSTANCE;
    }

    val_value_t *retval = agt_make_leaf2(name_obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_scs_a, key_name, &res);
    if (retval) {
        if (scs_a_fixed) {
            VAL_SET_FIXED_VALUE(retval);
        }
        getcb_add_return_key(get2cb, retval);
    }

    key_name = (const xmlChar *)key_name_temp_b;

    /* if we are here, then the index is valid */
    obj_template_t *name_obj2 = obj_find_child(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_scs_b);
    if(name_obj == NULL) {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s:%d name_obj is NULL", __func__, __LINE__);
        }
        return ERR_NCX_NO_INSTANCE;
    }

    val_value_t *retval2 = agt_make_leaf2(name_obj2, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_scs_b, key_name, &res);
    if (retval2) {
        if (scs_b_fixed) {
            VAL_SET_FIXED_VALUE(retval2);
        }
        getcb_add_return_key(get2cb, retval2);
    }

    if (LOGDEV1) {
        log_dev1("\n%s: more_data_a=%d, more_data_b=%d", __func__, more_data_a, more_data_b);
    }

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data_a;
    GETCB_GET2_MORE_DATA(get2cb) = more_data_b;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        xmlChar *para_temp;
        if (!xml_strcmp(name, y_o_ran_module_cap_N_number_of_guard_rbs_ul)) {
            /* leaf number-of-guard-rbs-ul (uint8) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get_para(curindex_a, y_o_ran_module_cap_N_number_of_guard_rbs_ul, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d para_temp=%s", __func__, __LINE__, para_temp);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_number_of_guard_rbs_ul, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param,  para = %s", __func__, __LINE__, y_o_ran_module_cap_N_number_of_guard_rbs_ul);
                }
                return res;
            }

        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_ru_capabilities_ul_mixed_num_required_guard_rbs_get */

/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get
*
* Get database object callback for list dl-mixed-num-required-guard-rbs
* Path: /module-capability/ru-capabilities/dl-mixed-num-required-guard-rbs
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_scs_a,
    boolean scs_a_fixed,
    boolean scs_a_present,
    const xmlChar *k_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_scs_b,
    boolean scs_b_fixed,
    boolean scs_b_present)
{
    if (LOGINFO) {
        log_info("\nEnter %s", __func__);
        log_info("\n    present_scs_a=%d ,fixed_scs_a=%d", scs_a_present, scs_a_fixed);
        log_info("\n    key_name_scs_a=%s", k_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_scs_a);
        log_info("\n    present_scs_b=%d ,fixed_scs_b=%d", scs_b_present, scs_b_fixed);
        log_info("\n    key_name_scs_b=%s", k_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_scs_b);
    }

    boolean getnext = FALSE;

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries; /* remove yumaworks warning */

    /* key情報未登録の場合は処理を行わない */
    if(saa_upconf_max_scs_a_num_dl == 0 || saa_upconf_max_scs_b_num_dl == 0) {
        if (LOGDEV1) {
            log_dev1("\n%s:%d No key info, saa_upconf_max_scs_a_num_dl=%d, saa_upconf_max_scs_b_num_dl=%d",
                __func__,
                __LINE__,
                saa_upconf_max_scs_a_num_dl,
                saa_upconf_max_scs_b_num_dl);
        }
        return res;
    }

    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

    //if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
    //    return ERR_NCX_NO_INSTANCE;
    //}

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data_a = TRUE;
    boolean more_data_b = TRUE;

    const xmlChar *key_name = 0;
    //const xmlChar *key_name_a = 0;
    xmlChar *key_name_temp_a = NULL;
    //const xmlChar *key_name_b = 0;
    xmlChar *key_name_temp_b = NULL;

    /* Key check */
    uint32 curindex_a = 0;
    uint32 curindex_b = 0;
    boolean name_ok = FALSE;

    if ((scs_a_present)&&(scs_b_present)) {
        /* get key's number from key */
        res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_key(
            k_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_scs_a,
            k_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_scs_b,
            &curindex_a,
            &curindex_b);
        if(res == NO_ERR) {
            name_ok = TRUE;
        }
        else {
            return ERR_NCX_NO_INSTANCE;
        }
    }

    /* check validity of keys present */
    if (getnext) {
        if ((scs_a_fixed)||(scs_b_fixed)) {
            return ERR_NCX_NO_INSTANCE;
        }

        if (!scs_a_present) {
            // return first key [0]
            res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_first_key(SAA_MODCAP_KEY_SCS_A, &key_name_temp_a);
            if (res != NO_ERR) {
                return res;
            }
        }
        else {
            /* getnextなのでkey indexを1進める */
            curindex_a++;
            /* find the correct key to retrieve */
            if ((res == NO_ERR) &&  (((curindex_a < saa_upconf_max_scs_a_num_dl) && more_data_a) || ((curindex_b < saa_upconf_max_scs_b_num_dl) && more_data_b))) {

                if(curindex_a >= saa_upconf_max_scs_a_num_dl) {
                    curindex_a--;
                    more_data_a = FALSE;
                }
                /* curindexで指定されたkeyを取得 */
                res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_target_key(curindex_a, SAA_MODCAP_KEY_SCS_A, &key_name_temp_a);
                if (res == NO_ERR) {
                    /* check if the current entry is the last one
                     * and set more_data flag accordingly
                     */
                    if (curindex_a == (saa_upconf_max_scs_a_num_dl - 1)) {
                        more_data_a = FALSE;
                    }
                }
                else {
                    return ERR_NCX_NO_INSTANCE;
                }
            }
            else {
                return ERR_NCX_NO_INSTANCE;
            }
        }

        if (!scs_b_present) {
            // return first key [0]
            res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_first_key(SAA_MODCAP_KEY_SCS_B, &key_name_temp_b);
            if (res != NO_ERR) {
                return res;
            }
        }
        else {
            /* getnextなのでkey indexを1進める */
            curindex_b++;
            /* find the correct key to retrieve */
            if ((res == NO_ERR) &&  (((curindex_a < saa_upconf_max_scs_a_num_dl) && more_data_a) || ((curindex_b < saa_upconf_max_scs_b_num_dl) && more_data_b))) {

                if(curindex_b >= saa_upconf_max_scs_b_num_dl) {
                    curindex_b--;
                    more_data_b = FALSE;
                }
                /* curindexで指定されたkeyを取得 */
                res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_target_key(curindex_b, SAA_MODCAP_KEY_SCS_B, &key_name_temp_b);
                if (res == NO_ERR) {
                    /* check if the current entry is the last one
                     * and set more_data flag accordingly
                     */
                    if (curindex_b == (saa_upconf_max_scs_b_num_dl - 1)) {
                        more_data_b = FALSE;
                    }
                }
                else {
                    return ERR_NCX_NO_INSTANCE;
                }
            }
            else {
                return ERR_NCX_NO_INSTANCE;
            }
        }

    }
    else{
        if (scs_a_present && name_ok) {
            res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_target_key(curindex_a, SAA_MODCAP_KEY_SCS_A, &key_name_temp_a);
            if(res != NO_ERR) {
                return ERR_NCX_NO_INSTANCE;
            }
        } else {
            /* get the first interface name */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_first_key(SAA_MODCAP_KEY_SCS_A, &key_name_temp_a);
            if (res != NO_ERR) {
                return res;
            }
        }

        if (scs_b_present && name_ok) {
            res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_target_key(curindex_b, SAA_MODCAP_KEY_SCS_B, &key_name_temp_b);
            if(res != NO_ERR) {
                return ERR_NCX_NO_INSTANCE;
            }
        } else {
            /* get the first interface name */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_first_key(SAA_MODCAP_KEY_SCS_B, &key_name_temp_b);
            if (res != NO_ERR) {
                return res;
            }
        }
    }
    if ((key_name_temp_a == NULL) || (key_name_temp_b == NULL)) {
        return NO_ERR;
    }


    key_name = (const xmlChar *)key_name_temp_a;

    /* if we are here, then the index is valid */
    obj_template_t *name_obj = obj_find_child(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_scs_a);
    if(name_obj == NULL) {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s:%d name_obj is NULL", __func__, __LINE__);
        }
        return ERR_NCX_NO_INSTANCE;
    }

    val_value_t *retval = agt_make_leaf2(name_obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_scs_a, key_name, &res);
    if (retval) {
        if (scs_a_fixed) {
            VAL_SET_FIXED_VALUE(retval);
        }
        getcb_add_return_key(get2cb, retval);
    }

    key_name = (const xmlChar *)key_name_temp_b;

    /* if we are here, then the index is valid */
    obj_template_t *name_obj2 = obj_find_child(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_scs_b);
    if(name_obj == NULL) {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s:%d name_obj is NULL", __func__, __LINE__);
        }
        return ERR_NCX_NO_INSTANCE;
    }

    val_value_t *retval2 = agt_make_leaf2(name_obj2, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_scs_b, key_name, &res);
    if (retval2) {
        if (scs_b_fixed) {
            VAL_SET_FIXED_VALUE(retval2);
        }
        getcb_add_return_key(get2cb, retval2);
    }

    if (LOGDEV1) {
        log_dev1("\n%s:%d more_data_a=%d, more_data_b=%d", __func__, __LINE__, more_data_a, more_data_b);
    }

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data_a;
    GETCB_GET2_MORE_DATA(get2cb) = more_data_b;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        xmlChar *para_temp;
        if (!xml_strcmp(name, y_o_ran_module_cap_N_number_of_guard_rbs_dl)) {
            /* leaf number-of-guard-rbs-dl (uint8) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get_para(curindex_a, y_o_ran_module_cap_N_number_of_guard_rbs_dl, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d para_temp=%s", __func__, __LINE__, para_temp);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_number_of_guard_rbs_dl, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param,  para = %s", __func__, __LINE__, y_o_ran_module_cap_N_number_of_guard_rbs_dl);
                }
                return res;
            }

        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_ru_capabilities_dl_mixed_num_required_guard_rbs_get */

/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_ru_capabilities_get
*
* Get database object callback for container ru-capabilities
* Path: /module-capability/ru-capabilities
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_ru_capabilities_get (
    getcb_get2_t *get2cb)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        xmlChar *para_temp;
        if (!xml_strcmp(name, y_o_ran_module_cap_N_ru_supported_category)) {
            /* leaf ru-supported-category (enumeration) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_get_para(E_MODULE_CAPA_CATEGORY, &para_temp);
            if(res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_ru_supported_category,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_number_of_ru_ports)) {
            /* leaf number-of-ru-ports (uint8) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_get_para(E_MODULE_CAPA_RU_PORT, &para_temp);
            if ( res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_number_of_ru_ports,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_number_of_spatial_streams)) {
            /* leaf number-of-spatial-streams (uint8) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_get_para(E_MODULE_CAPA_NUM_SPA_STREAM, &para_temp);
            if(res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_number_of_spatial_streams,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_power_per_pa_antenna)) {
            /* leaf max-power-per-pa-antenna (decimal64) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_get_para(E_MODULE_CAPA_MAX_PWR, &para_temp);

            if ( res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_max_power_per_pa_antenna,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_min_power_per_pa_antenna)) {
            /* leaf min-power-per-pa-antenna (decimal64) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_get_para(E_MODULE_CAPA_MIN_PWR, &para_temp);
            if (res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_min_power_per_pa_antenna,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_fronthaul_split_option)) {
            /* leaf fronthaul-split-option (uint8) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_get_para(E_MODULE_CAPA_SPLT_OPT, &para_temp);
            if(res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_fronthaul_split_option,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }

        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_energy_saving_by_transmission_blanks)) {
            /* leaf energy-saving-by-transmission-blanks (boolean) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_get_para(E_MODULE_CAPA_ENERGY_SAVING, &para_temp);
            if(res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_energy_saving_by_transmission_blanks,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }

        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_dynamic_transport_delay_management_supported)) {
            /* leaf dynamic-transport-delay-management-supported (boolean) */
            res = i_o_ran_module_cap_module_capability_ru_capabilities_get_para(E_MODULE_CAPA_DYNAMIC_TRANS, &para_temp);
            if(res == NO_ERR)
            {
                val_value_t *return_val = agt_make_leaf2(
                    obj,
                    y_o_ran_module_cap_M_o_ran_module_cap,
                    y_o_ran_module_cap_N_dynamic_transport_delay_management_supported,
                    (const xmlChar *)para_temp,
                    &res);
                if( return_val )
                {
                    getcb_add_return_val(get2cb, return_val);
                }
            }
            else
            {
                return res;
            }
        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_ru_capabilities_get */


#ifdef u_o_ran_module_cap_F_LAA
/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_band_capabilities_sub_band_info_sub_band_frequency_ranges_get
*
* Get database object callback for list sub-band-frequency-ranges
* Path: /module-capability/band-capabilities/sub-band-info/sub-band-frequency-ranges
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_band_capabilities_sub_band_info_sub_band_frequency_ranges_get (
    getcb_get2_t *get2cb,
    uint16 k_module_capability_band_capabilities_band_number,
    const xmlChar *k_module_capability_band_capabilities_sub_band_info_sub_band_frequency_ranges_sub_band,
    boolean sub_band_fixed,
    boolean sub_band_present)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    boolean getnext = FALSE;
    (void)k_module_capability_band_capabilities_band_number; /* remove yumaworks warning */
    (void)k_module_capability_band_capabilities_sub_band_info_sub_band_frequency_ranges_sub_band; /* remove yumaworks warning */
    (void)sub_band_fixed; /* remove yumaworks warning */
    (void)sub_band_present; /* remove yumaworks warning */
    (void)getnext; /* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries; /* remove yumaworks warning */


    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

    //if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
    //    return ERR_NCX_NO_INSTANCE;
    //}

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data = TRUE;

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_module_cap_N_max_supported_frequency_dl)) {
            /* leaf max-supported-frequency-dl (uint64) */

        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_min_supported_frequency_dl)) {
            /* leaf min-supported-frequency-dl (uint64) */

        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_band_capabilities_sub_band_info_sub_band_frequency_ranges_get */

/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_band_capabilities_sub_band_info_get
*
* Get database object callback for container sub-band-info
* Path: /module-capability/band-capabilities/sub-band-info
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_band_capabilities_sub_band_info_get (
    getcb_get2_t *get2cb,
    uint16 k_module_capability_band_capabilities_band_number)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_module_capability_band_capabilities_band_number; /* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_module_cap_N_number_of_laa_scarriers)) {
            /* leaf number-of-laa-scarriers (uint8) */

        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_maximum_laa_buffer_size)) {
            /* leaf maximum-laa-buffer-size (uint16) */

        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_maximum_processing_time)) {
            /* leaf maximum-processing-time (uint16) */

        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_self_configure)) {
            /* leaf self-configure (boolean) */

        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_band_capabilities_sub_band_info_get */

#endif /* u_o_ran_module_cap_F_LAA */
/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_band_capabilities_get
*
* Get database object callback for list band-capabilities
* Path: /module-capability/band-capabilities
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_band_capabilities_get (
    getcb_get2_t *get2cb,
    uint16 k_module_capability_band_capabilities_band_number,
    boolean band_number_fixed,
    boolean band_number_present)
{
    if (LOGINFO) {
        log_info("\nEnter %s", __func__);
        log_info("\n    present=%d ,fixed=%d", band_number_present, band_number_fixed);
        log_info("\n    key_band_num=%hd", k_module_capability_band_capabilities_band_number);
    }

    boolean getnext = FALSE;

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries; /* remove yumaworks warning */


    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

    //if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
    //    return ERR_NCX_NO_INSTANCE;
    //}

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data = TRUE;

    /* key object */
    const xmlChar *key_name = 0;
    xmlChar *key_name_temp = NULL;
    char target_key_name[D_PARAM_NUM_MAX];
    snprintf(target_key_name, D_PARAM_NUM_MAX, "%d", k_module_capability_band_capabilities_band_number);


    /* key number check */
    uint32 curindex = 0;
    boolean band_number_ok = FALSE;
    if (band_number_present) {
        /* get key's number from key */
        res = i_o_ran_module_cap_module_capability_band_capabilities_get_key_num((const xmlChar *)target_key_name, &curindex);
        if(res == NO_ERR) {
            band_number_ok = TRUE;
        }
        else {
            return ERR_NCX_NO_INSTANCE;
        }
    }

    /* check validity of keys present */
    if (getnext) {
        if (band_number_fixed) {
            return ERR_NCX_NO_INSTANCE;
        }

        /* adjust the key to find the next entry after
         * the specified value
         */
        if (!band_number_present) {
            // return first key [0]
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_first_key(&key_name_temp);
            if (res != NO_ERR) {
                return res;
            }
        }
        else {
            /* getnextなのでkey indexを1進める */
            curindex++;
            /* find the correct key to retrieve */
            if ((res == NO_ERR) && (curindex < saa_upconf_max_band_cap_num)) {
                /* curindexで指定されたkeyを取得 */
                res = i_o_ran_module_cap_module_capability_band_capabilities_get_target_key(curindex, &key_name_temp);
                if (res == NO_ERR) {
                    /* check if the current entry is the last one
                     * and set more_data flag accordingly
                     */
                    if (curindex == (saa_upconf_max_band_cap_num - 1)) {
                        more_data = FALSE;
                    }
                }
                else {
                    return ERR_NCX_NO_INSTANCE;
                }
            }
            else {
                return ERR_NCX_NO_INSTANCE;
            }
        }
    }
    else {
        if (band_number_present && band_number_ok) {
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_target_key(curindex, &key_name_temp);
            if(res != NO_ERR) {
                return ERR_NCX_NO_INSTANCE;
            }
        } else {
            /* get the first interface name */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_first_key(&key_name_temp);
            if (res != NO_ERR) {
                return res;
            }
        }
    }

    if (key_name_temp == NULL) {
        return NO_ERR;
    }

    key_name = (const xmlChar *)key_name_temp;

    /* if we are here, then the index is valid */
    obj_template_t *name_obj = obj_find_child(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_band_number);
    if(name_obj == NULL) {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s:%d name_obj is NULL", __func__, __LINE__);
        }
        return ERR_NCX_NO_INSTANCE;
    }

    val_value_t *retval = agt_make_leaf2(name_obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_band_number, key_name, &res);
    if (retval) {
        if (band_number_fixed) {
            VAL_SET_FIXED_VALUE(retval);
        }
        getcb_add_return_key(get2cb, retval);
    }

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        xmlChar *para_temp;
        if (!xml_strcmp(name, y_o_ran_module_cap_N_max_supported_frequency_dl)) {
            /* leaf max-supported-frequency-dl (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_supported_frequency_dl, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d band_capabilities_get, %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_supported_frequency_dl, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_supported_frequency_dl, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_supported_frequency_dl);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_min_supported_frequency_dl)) {
            /* leaf min-supported-frequency-dl (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_min_supported_frequency_dl, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_min_supported_frequency_dl, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_min_supported_frequency_dl, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_min_supported_frequency_dl);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_supported_bandwidth_dl)) {
            /* leaf max-supported-bandwidth-dl (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_supported_bandwidth_dl, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_supported_bandwidth_dl, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_supported_bandwidth_dl, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_supported_bandwidth_dl);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_num_carriers_dl)) {
            /* leaf max-num-carriers-dl (uint32) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_num_carriers_dl, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_num_carriers_dl, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_num_carriers_dl, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_num_carriers_dl);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_carrier_bandwidth_dl)) {
            /* leaf max-carrier-bandwidth-dl (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_carrier_bandwidth_dl, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_carrier_bandwidth_dl, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_carrier_bandwidth_dl, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_carrier_bandwidth_dl);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_min_carrier_bandwidth_dl)) {
            /* leaf min-carrier-bandwidth-dl (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_min_carrier_bandwidth_dl, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_min_carrier_bandwidth_dl, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_min_carrier_bandwidth_dl, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_min_carrier_bandwidth_dl);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_supported_frequency_ul)) {
            /* leaf max-supported-frequency-ul (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_supported_frequency_ul, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_supported_frequency_ul, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_supported_frequency_ul, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_supported_frequency_ul);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_min_supported_frequency_ul)) {
            /* leaf min-supported-frequency-ul (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_min_supported_frequency_ul, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_min_supported_frequency_ul, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_min_supported_frequency_ul, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_min_supported_frequency_ul);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_supported_bandwidth_ul)) {
            /* leaf max-supported-bandwidth-ul (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_supported_bandwidth_ul, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_supported_bandwidth_ul, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_supported_bandwidth_ul, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_supported_bandwidth_ul);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_num_carriers_ul)) {
            /* leaf max-num-carriers-ul (uint32) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_num_carriers_ul, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_num_carriers_ul, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_num_carriers_ul, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_num_carriers_ul);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_carrier_bandwidth_ul)) {
            /* leaf max-carrier-bandwidth-ul (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_carrier_bandwidth_ul, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_carrier_bandwidth_ul, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_carrier_bandwidth_ul, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_carrier_bandwidth_ul);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_min_carrier_bandwidth_ul)) {
            /* leaf min-carrier-bandwidth-ul (uint64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_min_carrier_bandwidth_ul, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_min_carrier_bandwidth_ul, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_min_carrier_bandwidth_ul, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_min_carrier_bandwidth_ul);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_num_component_carriers)) {
            /* leaf max-num-component-carriers (uint8) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_num_component_carriers, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_num_component_carriers, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_num_component_carriers, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_num_component_carriers);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_num_bands)) {
            /* leaf max-num-bands (uint16) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_num_bands, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_num_bands, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_num_bands, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_num_bands);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_num_sectors)) {
            /* leaf max-num-sectors (uint8) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_num_sectors, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_num_sectors, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_num_sectors, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_num_sectors);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_max_power_per_antenna)) {
            /* leaf max-power-per-antenna (decimal64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_max_power_per_antenna, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_max_power_per_antenna, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_max_power_per_antenna, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_max_power_per_antenna);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_min_power_per_antenna)) {
            /* leaf min-power-per-antenna (decimal64) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_min_power_per_antenna, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_min_power_per_antenna, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_min_power_per_antenna, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_min_power_per_antenna);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_codebook_configuration_ng)) {
            /* leaf codebook-configuration_ng (uint8) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_codebook_configuration_ng, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_codebook_configuration_ng, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_codebook_configuration_ng, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_codebook_configuration_ng);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_codebook_configuration_n1)) {
            /* leaf codebook-configuration_n1 (uint8) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_codebook_configuration_n1, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_codebook_configuration_n1, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_codebook_configuration_n1, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_codebook_configuration_n1);
                }
                return res;
            }
        } else if (!xml_strcmp(name, y_o_ran_module_cap_N_codebook_configuration_n2)) {
            /* leaf codebook-configuration_n2 (uint8) */
            res = i_o_ran_module_cap_module_capability_band_capabilities_get_para(curindex, y_o_ran_module_cap_N_codebook_configuration_n2, &para_temp);
            if (LOGDEV1) {
                log_dev1("\n%s:%d %s res = %d", __func__, __LINE__, y_o_ran_module_cap_N_codebook_configuration_n2, res);
            }
            if(res == NO_ERR) {
                retval = agt_make_leaf2(obj, y_o_ran_module_cap_M_o_ran_module_cap, y_o_ran_module_cap_N_codebook_configuration_n2, (const xmlChar *)para_temp, &res);
                if (retval) {
                    getcb_add_return_val(get2cb, retval);
                }
            }
            else {
                if(LOGWARN) {
                    log_warn("\n%s:%d operation failed to get param, modcap band-cap para = %s", __func__, __LINE__, y_o_ran_module_cap_N_codebook_configuration_n2);
                }
                return res;
            }
        }
    }

    return res;

} /* u_o_ran_module_cap_module_capability_band_capabilities_get */

/********************************************************************
* FUNCTION u_o_ran_module_cap_module_capability_get
*
* Get database object callback for container module-capability
* Path: /module-capability
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_module_capability_get (
    getcb_get2_t *get2cb)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    (void)obj; /* remove yumaworks warning */
    status_t res = NO_ERR;

    /* no terminal child nodes to check */

    return res;

} /* u_o_ran_module_cap_module_capability_get */

/********************************************************************
* FUNCTION u_o_ran_module_cap_init
*
* initialize the o-ran-module-cap server instrumentation library
*
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    status_t res = NO_ERR;
    ncx_module_t *o_ran_module_cap_mod = NULL;

    o_ran_module_cap_mod = ncx_find_module(modname, revision);
    if (o_ran_module_cap_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }

    /* put your module initialization code here */
    res = i_o_ran_module_cap_init();

    return res;

} /* u_o_ran_module_cap_init */

/********************************************************************
* FUNCTION u_o_ran_module_cap_init2
*
* SIL init phase 2: non-config data structures
* Called after running config is loaded
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_module_cap_init2 (void)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    status_t res = NO_ERR;

    /* put your init2 code here */

    return res;

} /* u_o_ran_module_cap_init2 */

/********************************************************************
* FUNCTION u_o_ran_module_cap_cleanup
*    cleanup the server instrumentation library
*
********************************************************************/
void u_o_ran_module_cap_cleanup (void)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* put your cleanup code here */

} /* u_o_ran_module_cap_cleanup */

/* END SIL-SA u_o_ran_module_cap.c */
