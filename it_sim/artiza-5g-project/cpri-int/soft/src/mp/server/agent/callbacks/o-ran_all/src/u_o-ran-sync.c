
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2019, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump-sdk 18.10-9

    User SIL-SA module
    bundle o-ran_all
    module o-ran-sync
    revision 2019-02-04
    namespace urn:o-ran:sync:1.0
    organization O-RAN Alliance
    Created: 2019-06-21T02:49:15Z
    CLI parameters:
        defnames true
        format uc
        indent 4
        module ietf-yang-types
        module ietf-inet-types
        module ietf-interfaces
        module iana-if-type
        module ietf-ip
        module iana-hardware
        module ietf-hardware
        module ietf-netconf-acm
        module o-ran-hardware
        module o-ran-software-management
        module o-ran-interfaces
        module o-ran-transceiver
        module o-ran-mplane-int
        module o-ran-dhcp
        module o-ran-compression-factors
        module o-ran-uplane-conf
        module o-ran-module-cap
        module o-ran-processing-element
        module o-ran-performance-management
        module o-ran-fm
        module o-ran-lbm
        module o-ran-supervision
        module o-ran-beamforming
        module o-ran-operations
        module o-ran-usermgmt
        module o-ran-sync
        sil-bundle o-ran_all
        sil-get2
        sil-sa
        unified true

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "ses.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_util.h"
#include "xml_val.h"

/* SIL bundle: o-ran_all */
#include "y_ietf-yang-types.h"
#include "u_ietf-yang-types.h"
#include "y_ietf-inet-types.h"
#include "u_ietf-inet-types.h"
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_iana-if-type.h"
#include "u_iana-if-type.h"
#include "y_ietf-ip.h"
#include "u_ietf-ip.h"
#include "y_iana-hardware.h"
#include "u_iana-hardware.h"
#include "y_ietf-hardware.h"
#include "u_ietf-hardware.h"
#include "y_ietf-netconf-acm.h"
#include "u_ietf-netconf-acm.h"
#include "y_o-ran-hardware.h"
#include "u_o-ran-hardware.h"
#include "y_o-ran-software-management.h"
#include "u_o-ran-software-management.h"
#include "y_o-ran-interfaces.h"
#include "u_o-ran-interfaces.h"
#include "y_o-ran-transceiver.h"
#include "u_o-ran-transceiver.h"
#include "y_o-ran-mplane-int.h"
#include "u_o-ran-mplane-int.h"
#include "y_o-ran-dhcp.h"
#include "u_o-ran-dhcp.h"
#include "y_o-ran-compression-factors.h"
#include "u_o-ran-compression-factors.h"
#include "y_o-ran-uplane-conf.h"
#include "u_o-ran-uplane-conf.h"
#include "y_o-ran-module-cap.h"
#include "u_o-ran-module-cap.h"
#include "y_o-ran-processing-element.h"
#include "u_o-ran-processing-element.h"
#include "y_o-ran-performance-management.h"
#include "u_o-ran-performance-management.h"
#include "y_o-ran-fm.h"
#include "u_o-ran-fm.h"
#include "y_o-ran-lbm.h"
#include "u_o-ran-lbm.h"
#include "y_o-ran-supervision.h"
#include "u_o-ran-supervision.h"
#include "y_o-ran-beamforming.h"
#include "u_o-ran-beamforming.h"
#include "y_o-ran-operations.h"
#include "u_o-ran-operations.h"
#include "y_o-ran-usermgmt.h"
#include "u_o-ran-usermgmt.h"
#include "y_o-ran-sync.h"
#include "u_o-ran-sync.h"
#include "i_o-ran-sync.h"

static obj_template_t *synchronization_state_change_obj;
static obj_template_t *ptp_state_change_obj;
static obj_template_t *synce_state_change_obj;

#ifdef u_o_ran_sync_F_GNSS
static obj_template_t *gnss_state_change_obj;
#endif /* u_o_ran_sync_F_GNSS */

/* put your static variables here */
static char o_ran_sync_state_freerun[]	       	= i_o_ran_sync_N_state_freerun;
static char o_ran_sync_state_locked[]     		= i_o_ran_sync_N_state_locked;
static char o_ran_sync_state_holdover[]      	= i_o_ran_sync_N_state_holdover;
static char o_ran_sync_lock_state_unlocked[]    = i_o_ran_sync_N_state_lock_unlocked;
static char o_ran_sync_lock_state_locked[]      = i_o_ran_sync_N_state_lock_locked;
static char o_ran_sync_synce_lock_state_unlocked[]    = i_o_ran_sync_N_state_synce_lock_unlocked;
static char o_ran_sync_synce_lock_state_locked[]      = i_o_ran_sync_N_state_synce_lock_locked;
static char o_ran_sync_ptp_state_disable[]     	= i_o_ran_sync_N_state_ptp_disable;
static char o_ran_sync_ptp_state_parent[]      	= i_o_ran_sync_N_state_ptp_parent;
static char o_ran_sync_ptp_state_ok[]      		= i_o_ran_sync_N_state_ptp_ok;
static char o_ran_sync_ptp_state_nok[]      		= i_o_ran_sync_N_state_ptp_nok;
static char o_ran_sync_synce_state_disable[]     = i_o_ran_sync_N_state_synce_disable;
static char o_ran_sync_synce_state_parent[]      = i_o_ran_sync_N_state_synce_parent;
static char o_ran_sync_synce_state_ok[]      	= i_o_ran_sync_N_state_synce_ok;
static char o_ran_sync_synce_state_nok[]      	= i_o_ran_sync_N_state_synce_nok;

/* TRUE in case of the first data of clock_classes list(FALSE when it is not so) */
static bool flg_clock_classes = false;

/********************************************************************
* FUNCTION u_o_ran_sync_sync_sync_status_supported_reference_types_get
*
* Get database object callback for list supported-reference-types
* Path: /sync/sync-status/supported-reference-types
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_sync_status_supported_reference_types_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_sync_sync_status_supported_reference_types_item,
    boolean item_fixed,
    boolean item_present)
{

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    boolean getnext = FALSE;

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries;/* remove yumaworks warning */


    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

//    if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
//        return ERR_NCX_NO_INSTANCE;
//    }

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data = TRUE;

    /* key object */
    const xmlChar *key_name = 0;
    xmlChar *key_name_temp = NULL;

    /* key number check */
    uint32 curindex = 0;
    boolean name_ok = FALSE;
    if (item_present) {
        /* get key's number from key */
        res = i_o_ran_sync_sync_sync_status_supported_reference_types_get_key_num(k_sync_sync_status_supported_reference_types_item, &curindex);
        if(res == NO_ERR) {
            name_ok = TRUE;
        }
        else {
            return ERR_NCX_NO_INSTANCE;
        }
    }

    /* check validity of keys present */
    if (getnext) {
        if (item_fixed) {
            return ERR_NCX_NO_INSTANCE;
        }

        /* adjust the key to find the next entry after
         * the specified value
         */
        if (!item_present) {
            // return first key [0]
            res = i_o_ran_sync_sync_sync_status_supported_reference_types_get_first_key(&key_name_temp);
            if (res != NO_ERR) {
                return res;
            }
        }
        else {
            /* getnextなのでkey indexを1進める */
            curindex++;
            /* find the correct key to retrieve */
            if ((res == NO_ERR) && (curindex < SAA_SYNC_MAX_ITEM_NUM)) {
                /* curindexで指定されたkeyを取得 */
                res = i_o_ran_sync_sync_sync_status_supported_reference_types_get_target_key(curindex, &key_name_temp);
                if (res == NO_ERR) {
                    /* check if the current entry is the last one
                     * and set more_data flag accordingly
                     */
                    if (curindex == (SAA_SYNC_MAX_ITEM_NUM - 1)) {
                        more_data = FALSE;
                    }
                }
                else {
                    return ERR_NCX_NO_INSTANCE;
                }
            }
            else {
                return ERR_NCX_NO_INSTANCE;
            }
        }
    }
    else {
        if (item_present && name_ok) {
            res = i_o_ran_sync_sync_sync_status_supported_reference_types_get_target_key(curindex, &key_name_temp);
            if(res != NO_ERR) {
                return ERR_NCX_NO_INSTANCE;
            }
        } else {
            /* get the first interface name */
            res = i_o_ran_sync_sync_sync_status_supported_reference_types_get_first_key(&key_name_temp);
            if (res != NO_ERR) {
                return res;
            }
        }
    }

    if (key_name_temp == NULL) {
        return NO_ERR;
    }

    key_name = (const xmlChar *)key_name_temp;

    /* if we are here, then the index is valid */
    obj_template_t *name_obj = obj_find_child(obj, y_o_ran_sync_M_o_ran_sync, y_o_ran_sync_N_item);

    val_value_t *retval = agt_make_leaf2(name_obj, y_o_ran_sync_M_o_ran_sync, y_o_ran_sync_N_item, key_name, &res);
    if (retval) {
        if (item_fixed) {
            VAL_SET_FIXED_VALUE(retval);
        }
        getcb_add_return_key(get2cb, retval);
    }

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

//    if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
//        return ERR_NCX_NO_INSTANCE;
//    }

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* no terminal child nodes to check */

    return res;

} /* u_o_ran_sync_sync_sync_status_supported_reference_types_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_sync_status_get
*
* Get database object callback for container sync-status
* Path: /sync/sync-status
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_sync_status_get (
    getcb_get2_t *get2cb)
{

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    const xmlChar *v_sync_state = 0;
    xmlChar *sync_state = 0;
    T_MPSW_MSI_O_RAN_SYNC_GET_CFM  get_data;
    /* MSI_O_RAN_SYNC_GET_REQ送信 */
    res = i_o_ran_sync_get_send_msi(&get_data);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_sync_N_sync_state)) {
            /* leaf sync-state (enumeration) */

		    switch(get_data.sync_t.sync_status_sync_t.sync_state)
		    {
		    case E_SYNC_STATE_FREERUN:
		        sync_state = (xmlChar *)o_ran_sync_state_freerun;
		        break;
		    case E_SYNC_STATE_LOCKED:
		        sync_state = (xmlChar *)o_ran_sync_state_locked;
		        break;
		    case E_SYNC_STATE_HOLDOVER:
		        sync_state = (xmlChar *)o_ran_sync_state_holdover;
		        break;
		    default:
		        /* error */
		        res = ERR_NCX_DATA_MISSING;
		        /* error log */
		        if(LOGWARN) {
		            log_warn("\n%s: lock_state is Not Data(u_o_ran_sync_sync_sync_status_get)", __func__);
		        }
		        return res;
		    }

			v_sync_state = (const xmlChar *)sync_state;

		    /* add sync_state to get2cb return_val */
		    val_value_t *return_val = agt_make_leaf2(
		        obj,
		        y_o_ran_sync_M_o_ran_sync,
		        y_o_ran_sync_N_sync_state,
		        v_sync_state,
		        &res);
		    if (return_val) {
		        getcb_add_return_val(get2cb, return_val);
		    }
        }
    }

    return res;

} /* u_o_ran_sync_sync_sync_status_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_sync_capability_get
*
* Get database object callback for container sync-capability
* Path: /sync/sync-capability
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_sync_capability_get (
    getcb_get2_t *get2cb)
{

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_sync_N_sync_t_tsc)) {
            /* leaf sync-t-tsc (enumeration) */
            xmlChar *sync_capability = 0;
	        res = i_o_ran_sync_sync_sync_capability_get(&sync_capability);
            if (res != NO_ERR) {
                return res;
            }
		    if (LOGDEV1) {
		        log_dev1("\n%s: sync_capability: %s", __func__, sync_capability);
		    }
		    const xmlChar *v_sync_capability = (const xmlChar *)sync_capability;

		    val_value_t *return_val = agt_make_leaf2(
		        obj,
		        y_o_ran_sync_M_o_ran_sync,
		        y_o_ran_sync_N_sync_t_tsc,
		        v_sync_capability,
		        &res);
		    if (return_val) {
		        getcb_add_return_val(get2cb, return_val);
		    }
        }
    }

    return res;

} /* u_o_ran_sync_sync_sync_capability_get */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_domain_number_edit
*
* Edit database object callback
* Path: /sync/ptp-config/domain-number
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_domain_number_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    uint8 newval_val = (newval) ? VAL_UINT8(newval) : 0;
    uint8 curval_val = (curval) ? VAL_UINT8(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        res = i_o_ran_sync_sync_ptp_config_domain_number_validate(newval, curval);

        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
		if (LOGDEV1) {
	        log_dev1("\n%s: editop:%d", __func__, editop);
        }
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            if(newval)
            {
                /* edit値設定 */
                T_MPSW_MSI_O_RAN_SYNC_EDIT_REQ  edit_data;
                /* edit値初期化 */
                i_o_ran_sync_edit_table_init(&edit_data);

                /* domain_number */
                edit_data.ptp_config_t.domain_number            = newval_val;

                /* MSI_O_RAN_SYNC_EDIT_REQ send */
                res = i_o_ran_sync_edit_req_send_msi(&edit_data);
            }
            else
            {
                /* error */
                res = ERR_NCX_DATA_MISSING;
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s: domain_number is Not Data", __func__);
                }
            }
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_domain_number_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_accepted_clock_classes_edit
*
* Edit database object callback
* Path: /sync/ptp-config/accepted-clock-classes
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_accepted_clock_classes_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint8 k_sync_ptp_config_accepted_clock_classes_clock_classes)
{
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        res = i_o_ran_sync_sync_ptp_config_accepted_clock_classes_validate(k_sync_ptp_config_accepted_clock_classes_clock_classes);

        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
		if (LOGDEV1) {
		    log_dev1("\n%s: editop:%d", __func__, editop);
		}
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            /* 最初に設定されたclock_classesのみMSIで送信する */
            if (!flg_clock_classes)
            {
                if (LOGINFO) {
                    log_info("\nThe first of the clock-classes = %u",k_sync_ptp_config_accepted_clock_classes_clock_classes);
                }
                /* edit値設定 */
                T_MPSW_MSI_O_RAN_SYNC_EDIT_REQ  edit_data;
                /* edit値初期化 */
                i_o_ran_sync_edit_table_init(&edit_data);

                /* clock_classes設定 */
                edit_data.ptp_config_t.clock_classes = k_sync_ptp_config_accepted_clock_classes_clock_classes;

                /* MSI_O_RAN_SYNC_EDIT_REQ send */
                res = i_o_ran_sync_edit_req_send_msi(&edit_data);
                flg_clock_classes = true;
            }
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_accepted_clock_classes_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_ptp_profile_edit
*
* Edit database object callback
* Path: /sync/ptp-config/ptp-profile
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_ptp_profile_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_ENUM_NAME(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_ENUM_NAME(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning *//* pgr0060 */
    (void)curval_val;/* remove yumaworks warning *//* pgr0060 */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_ptp_config_ptp_profile_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_ptp_profile_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_1_config_multicast_mac_address_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-1-config/multicast-mac-address
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_1_config_multicast_mac_address_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_ENUM_NAME(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_ENUM_NAME(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning *//* pgr0060 */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
	    if (LOGDEV1) {
	        log_dev1("\n%s: editop:%d", __func__, editop);
	    }
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            if(newval)
            {
                /* edit値設定 */
                T_MPSW_MSI_O_RAN_SYNC_EDIT_REQ  edit_data;
                /* edit値初期化 */
                i_o_ran_sync_edit_table_init(&edit_data);

                /* multicast_mac_address */
                if (!xml_strcmp(newval_val, (const xmlChar *)i_o_ran_sync_N_forwardable))
                {
                    edit_data.ptp_config_t.multicast_mac_address = E_SYNC_MULTICAST_ADDR_FORWARDABLE;
                }
                else if (!xml_strcmp(newval_val, (const xmlChar *)i_o_ran_sync_N_nonforwardable)) {
                    edit_data.ptp_config_t.multicast_mac_address = E_SYNC_MULTICAST_ADDR_NONFORWARDABLE;
                }
                else
                {
                    /* error */
                    res = ERR_NCX_DATA_MISSING;
                    /* error log */
                    if(LOGWARN) {
                        log_warn("\n%s: multicast_mac_address is Not Data", __func__);
                    }
                    return res;
                }

                /* MSI_O_RAN_SYNC_EDIT_REQ send */
                res = i_o_ran_sync_edit_req_send_msi(&edit_data);
            }
            else
            {
                /* error */
                res = ERR_NCX_DATA_MISSING;
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s: multicast_mac_address is Not Data", __func__);
                }
            }
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_1_config_multicast_mac_address_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_1_config_delay_asymmetry_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-1-config/delay-asymmetry
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_1_config_delay_asymmetry_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    int16 newval_val = (newval) ? VAL_INT16(newval) : 0;
    int16 curval_val = (curval) ? VAL_INT16(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            if(newval)
            {
                /* edit値設定 */
                T_MPSW_MSI_O_RAN_SYNC_EDIT_REQ  edit_data;
                /* edit値初期化 */
                i_o_ran_sync_edit_table_init(&edit_data);

                /* delay_asymmetry設定 */
                edit_data.ptp_config_t.delay_asymmetry = newval_val;

                /* MSI_O_RAN_SYNC_EDIT_REQ send */
                res = i_o_ran_sync_edit_req_send_msi(&edit_data);
            }
            else
            {
                /* error */
                res = ERR_NCX_DATA_MISSING;
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s: delay_asymmetry is Not Data", __func__);
                }
            }
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_1_config_delay_asymmetry_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_1_config_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-1-config
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_1_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_ptp_config_g_8275_1_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_1_config_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_2_config_local_ip_port_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-2-config/local-ip-port
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_2_config_local_ip_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_STRING(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_STRING(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning *//* pgr0060 */
    (void)curval_val;/* remove yumaworks warning *//* pgr0060 */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_ptp_config_g_8275_2_config_local_ip_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_2_config_local_ip_port_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_2_config_master_ip_configuration_ip_address_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-2-config/master-ip-configuration/ip-address
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_2_config_master_ip_configuration_ip_address_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint8 k_sync_ptp_config_g_8275_2_config_master_ip_configuration_local_priority)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_STRING(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_STRING(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning *//* pgr0060 */
    (void)curval_val;/* remove yumaworks warning *//* pgr0060 */
    (void)k_sync_ptp_config_g_8275_2_config_master_ip_configuration_local_priority;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_ptp_config_g_8275_2_config_master_ip_configuration_ip_address_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_2_config_master_ip_configuration_ip_address_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_2_config_master_ip_configuration_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-2-config/master-ip-configuration
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_2_config_master_ip_configuration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    uint8 k_sync_ptp_config_g_8275_2_config_master_ip_configuration_local_priority)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)k_sync_ptp_config_g_8275_2_config_master_ip_configuration_local_priority;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_ptp_config_g_8275_2_config_master_ip_configuration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_2_config_master_ip_configuration_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_2_config_log_inter_sync_period_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-2-config/log-inter-sync-period
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_2_config_log_inter_sync_period_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    int8 newval_val = (newval) ? VAL_INT8(newval) : 0;
    int8 curval_val = (curval) ? VAL_INT8(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_ptp_config_g_8275_2_config_log_inter_sync_period_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_2_config_log_inter_sync_period_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_2_config_log_inter_announce_period_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-2-config/log-inter-announce-period
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_2_config_log_inter_announce_period_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    int8 newval_val = (newval) ? VAL_INT8(newval) : 0;
    int8 curval_val = (curval) ? VAL_INT8(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_ptp_config_g_8275_2_config_log_inter_announce_period_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_2_config_log_inter_announce_period_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_g_8275_2_config_edit
*
* Edit database object callback
* Path: /sync/ptp-config/g-8275-2-config
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_g_8275_2_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_ptp_config_g_8275_2_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_g_8275_2_config_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_config_edit
*
* Edit database object callback
* Path: /sync/ptp-config
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_config_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_status_reporting_period_edit
*
* Edit database object callback
* Path: /sync/ptp-status/reporting-period
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_status_reporting_period_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    uint8 newval_val = (newval) ? VAL_UINT8(newval) : 0;
    uint8 curval_val = (curval) ? VAL_UINT8(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        res = i_o_ran_sync_sync_ptp_status_reporting_period_validate(newval, curval);

        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            if(newval)
            {
                /* edit値設定 */
                T_MPSW_MSI_O_RAN_SYNC_EDIT_REQ  edit_data;
                /* edit値初期化 */
                i_o_ran_sync_edit_table_init(&edit_data);

                /* ptp_reporting_period */
                edit_data.ptp_config_t.ptp_reporting_period = newval_val;

                /* MSI_O_RAN_SYNC_EDIT_REQ send */
                res = i_o_ran_sync_edit_req_send_msi(&edit_data);
            }
            else
            {
                /* error */
                res = ERR_NCX_DATA_MISSING;
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s: ptp_reporting_period is Not Data", __func__);
                }
            }
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_status_reporting_period_edit */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_status_lock_state_get
*
* Get database object callback for leaf lock-state
* Path: /sync/ptp-status/lock-state
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_status_lock_state_get (
    getcb_get2_t *get2cb)
{

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    T_MPSW_MSI_O_RAN_SYNC_GET_CFM  get_data;
    /* MSI_O_RAN_SYNC_GET_REQ送信 */
    res = i_o_ran_sync_get_send_msi(&get_data);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    xmlChar *lock_state = 0;

    switch(get_data.sync_t.ptp_status_t.lock_state)
    {
    case E_PTP_STATE_UNLOCKED:
        lock_state = (xmlChar *)o_ran_sync_lock_state_unlocked;
        break;
    case E_PTP_STATE_LOCKED:
        lock_state = (xmlChar *)o_ran_sync_lock_state_locked;
        break;
    default:
        /* error */
        res = ERR_NCX_DATA_MISSING;
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: lock_state=%d", __func__, get_data.sync_t.ptp_status_t.lock_state);
        }
        return res;
    }

    const xmlChar *v_lock_state = (const xmlChar *)lock_state;
    if(LOGDEV1) {
        log_dev1("\n%s: v_lock_state: %s	lock_state: %s)", __func__, v_lock_state, lock_state);
    }

    /* add lock_state to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_lock_state,
        v_lock_state,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_o_ran_sync_sync_ptp_status_lock_state_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_status_clock_class_get
*
* Get database object callback for leaf clock-class
* Path: /sync/ptp-status/clock-class
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_status_clock_class_get (
    getcb_get2_t *get2cb)
{

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    uint8 v_clock_class = 0;
    T_MPSW_MSI_O_RAN_SYNC_GET_CFM  get_data;
    /* MSI_O_RAN_SYNC_GET_REQ送信 */
    res = i_o_ran_sync_get_send_msi(&get_data);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: MSI failed. res=%d", __func__, res);
        }
        return res;
    }
    v_clock_class = get_data.sync_t.ptp_status_t.clock_class;

    /* add clock_class to get2cb return_valQ */
    val_value_t *return_val = agt_make_uint_leaf2(
        obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_clock_class,
        v_clock_class,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_o_ran_sync_sync_ptp_status_clock_class_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_status_clock_identity_get
*
* Get database object callback for leaf clock-identity
* Path: /sync/ptp-status/clock-identity
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_status_clock_identity_get (
    getcb_get2_t *get2cb)
{

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    T_MPSW_MSI_O_RAN_SYNC_GET_CFM  get_data;
    /* MSI_O_RAN_SYNC_GET_REQ送信 */
    res = i_o_ran_sync_get_send_msi(&get_data);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: MSI failed. res=%d", __func__, res);
        }
        return res;
    }
    const xmlChar *v_clock_identity = (const xmlChar *)get_data.sync_t.ptp_status_t.clock_identity;

    /* add clock_identity to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_clock_identity,
        v_clock_identity,
        &res);
	    if (LOGDEV1) {
	        log_dev1("\n%s: v_clock_identity 2: %s	clock_identity 2: %s", __func__, v_clock_identity, get_data.sync_t.ptp_status_t.clock_identity);
	    }
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_o_ran_sync_sync_ptp_status_clock_identity_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_status_partial_timing_supported_get
*
* Get database object callback for leaf partial-timing-supported
* Path: /sync/ptp-status/partial-timing-supported
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_status_partial_timing_supported_get (
    getcb_get2_t *get2cb)
{
    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    boolean v_partial_timing_supported = 0;

    /* add partial_timing_supported to get2cb return_valQ */
    val_value_t *return_val = agt_make_boolean_leaf(
        obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_partial_timing_supported,
        v_partial_timing_supported,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_o_ran_sync_sync_ptp_status_partial_timing_supported_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_status_sources_get
*
* Get database object callback for list sources
* Path: /sync/ptp-status/sources
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_status_sources_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_sync_ptp_status_sources_local_port_number,
    boolean local_port_number_fixed,
    boolean local_port_number_present)
{
    boolean getnext = FALSE;

    if (LOGINFO) {
	log_info("\nEnter %s: key=%s, num_fix=%d, num_pre=%d", __func__, k_sync_ptp_status_sources_local_port_number, local_port_number_fixed,local_port_number_present);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data = FALSE;
	
    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;
	
    /* 変数設定 */
    const xmlChar *v_ptp_state = 0;
	unsigned int v_two_step_flag = 0;
	unsigned int v_leap61 = 0;
	unsigned int v_leap59 = 0;
	unsigned int v_current_utc_offset_valid = 0;
	unsigned int v_ptp_timescale = 0;
	unsigned int v_time_traceable = 0;
	unsigned int v_frequency_traceable = 0;
	const xmlChar *v_source_clock_identity = 0;
	unsigned int v_source_port_number = 0;
	int v_current_utc_offset = 0;
	int v_priority1 = 0;
	int v_clock_class = 0;
	int v_clock_accuracy = 0;
	unsigned int v_offset_scaled_log_variance = 0;
    unsigned int v_priority2 = 0;
	const xmlChar * v_grandmaster_clock_identity =0;
	unsigned int v_steps_removed =0;
	unsigned int v_time_source =0;

    T_MPSW_MSI_O_RAN_SYNC_GET_CFM  get_data;
    /* MSI_O_RAN_SYNC_GET_REQ送信 */
    res = i_o_ran_sync_get_send_msi(&get_data);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: MSI failed. res=%d", __func__, res);
        }
        return res;
    }
	
    val_value_t *return_val = 
        agt_make_uint_leaf2(obj, 
            y_o_ran_sync_M_o_ran_sync,
            (const xmlChar *)"local-port-number", 
            get_data.sync_t.ptp_status_t.ptp_source_t.local_port_number, 
            &res); 
    if (res == NO_ERR) { 
        if (local_port_number_fixed) { 
            VAL_SET_FIXED_VALUE(return_val); 
        } 
        getcb_add_return_key(get2cb, return_val); 
    } else {
        if(LOGWARN) {
	        log_warn("%s: agt_make_uint_leaf2 ERROR %d", __func__, res);
	    }
    }

	/* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_sync_N_state)) {
            /* leaf state (enumeration) */

		    switch(get_data.sync_t.ptp_status_t.ptp_source_t.state)
		    {
		    case E_PTP_STATE_DISABLE:
		        v_ptp_state = (const xmlChar *)o_ran_sync_ptp_state_disable;
		        break;
		    case E_PTP_STATE_PARENT:
		        v_ptp_state = (const xmlChar *)o_ran_sync_ptp_state_parent;
		        break;
		    case E_PTP_STATE_OK:
		        v_ptp_state = (const xmlChar *)o_ran_sync_ptp_state_ok;
		        break;
		    case E_PTP_STATE_NOK:
		        v_ptp_state = (const xmlChar *)o_ran_sync_ptp_state_nok;
		        break;
		    	
		    default:
		        /* error */
		        res = ERR_NCX_DATA_MISSING;
		        /* error log */
		        if(LOGWARN) {
		            log_warn("\n%s: state=%d", __func__, get_data.sync_t.ptp_status_t.ptp_source_t.state);
		        }
		    	
		        return res;
		    }
		    if (LOGDEV1) {
		        log_dev1("\n%s: v_ptp_state=%s", __func__, v_ptp_state);
		    }
        	
        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_state = agt_make_leaf2(
		        obj,
		        y_o_ran_sync_M_o_ran_sync,
		        y_o_ran_sync_N_state,
		        v_ptp_state,
		        &res);
		    if (return_val_state) {
		        getcb_add_return_val(get2cb, return_val_state);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_two_step_flag)) {
            /* leaf two-step-flag (boolean) */
        	
        	v_two_step_flag = get_data.sync_t.ptp_status_t.ptp_source_t.twostep_flag;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_tsf = agt_make_boolean_leaf(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_two_step_flag,
                v_two_step_flag,
                &res);
		    if (return_val_tsf) {
		        getcb_add_return_val(get2cb, return_val_tsf);
		    }

        } else if (!xml_strcmp(name, y_o_ran_sync_N_leap61)) {
            /* leaf leap61 (boolean) */
        	
        	v_leap61 = get_data.sync_t.ptp_status_t.ptp_source_t.leap61;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_61 = agt_make_boolean_leaf(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_leap61,
                v_leap61,
                &res);
		    if (return_val_61) {
		        getcb_add_return_val(get2cb, return_val_61);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_leap59)) {
            /* leaf leap59 (boolean) */
        	
        	v_leap59 = get_data.sync_t.ptp_status_t.ptp_source_t.leap59;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_59 = agt_make_boolean_leaf(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_leap59,
                v_leap59,
                &res);
		    if (return_val_59) {
		        getcb_add_return_val(get2cb, return_val_59);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_current_utc_offset_valid)) {
            /* leaf current-utc-offset-valid (boolean) */
        	
        	v_current_utc_offset_valid = get_data.sync_t.ptp_status_t.ptp_source_t.current_utc_offset_valid;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_cuov = agt_make_boolean_leaf(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_current_utc_offset_valid,
                v_current_utc_offset_valid,
                &res);
		    if (return_val_cuov) {
		        getcb_add_return_val(get2cb, return_val_cuov);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_ptp_timescale)) {
            /* leaf ptp-timescale (boolean) */
        	
        	v_ptp_timescale = get_data.sync_t.ptp_status_t.ptp_source_t.ptp_timescale;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_ptptsc = agt_make_boolean_leaf(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_ptp_timescale,
                v_ptp_timescale,
                &res);
		    if (return_val_ptptsc) {
		        getcb_add_return_val(get2cb, return_val_ptptsc);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_time_traceable)) {
            /* leaf time-traceable (boolean) */
        	
        	v_time_traceable = get_data.sync_t.ptp_status_t.ptp_source_t.time_traceable;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_trab = agt_make_boolean_leaf(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_time_traceable,
                v_time_traceable,
                &res);
		    if (return_val_trab) {
		        getcb_add_return_val(get2cb, return_val_trab);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_frequency_traceable)) {
            /* leaf frequency-traceable (boolean) */
        	
        	v_frequency_traceable = get_data.sync_t.ptp_status_t.ptp_source_t.frequency_traceable;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_frt = agt_make_boolean_leaf(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_frequency_traceable,
                v_frequency_traceable,
                &res);
		    if (return_val_frt) {
		        getcb_add_return_val(get2cb, return_val_frt);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_source_clock_identity)) {
            /* leaf source-clock-identity (string) */
        	v_source_clock_identity = (const xmlChar *)get_data.sync_t.ptp_status_t.ptp_source_t.source_clock_identity;
        	
		    /* add lock_state to get2cb return_val */
		    val_value_t *return_val_scid = agt_make_leaf2(
		        obj,
		        y_o_ran_sync_M_o_ran_sync,
		        y_o_ran_sync_N_source_clock_identity,
		        v_source_clock_identity,
		        &res);
		    if (return_val_scid) {
		        getcb_add_return_val(get2cb, return_val_scid);
		    }




        } else if (!xml_strcmp(name, y_o_ran_sync_N_source_port_number)) {
            /* leaf source-port-number (uint16) */
        	
        	v_source_port_number = get_data.sync_t.ptp_status_t.ptp_source_t.source_port_number;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_spn = agt_make_uint_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_source_port_number,
                v_source_port_number,
                &res);
		    if (return_val_spn) {
		        getcb_add_return_val(get2cb, return_val_spn);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_current_utc_offset)) {
            /* leaf current-utc-offset (int16) */
        	
        	v_current_utc_offset = get_data.sync_t.ptp_status_t.ptp_source_t.current_utc_offset;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_cuo = agt_make_int_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_current_utc_offset,
                v_current_utc_offset,
                &res);
		    if (return_val_cuo) {
		        getcb_add_return_val(get2cb, return_val_cuo);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_priority1)) {
            /* leaf priority1 (int8) */
        	
        	v_priority1 = get_data.sync_t.ptp_status_t.ptp_source_t.priority1;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_pri1 = agt_make_int_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_priority1,
                v_priority1,
                &res);
		    if (return_val_pri1) {
		        getcb_add_return_val(get2cb, return_val_pri1);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_clock_class)) {
            /* leaf clock-class (int8) */
        	
        	v_clock_class = get_data.sync_t.ptp_status_t.ptp_source_t.clock_class;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_clc = agt_make_int_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_clock_class,
                v_clock_class,
                &res);
		    if (return_val_clc) {
		        getcb_add_return_val(get2cb, return_val_clc);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_clock_accuracy)) {
            /* leaf clock-accuracy (int8) */
        	
        	v_clock_accuracy = get_data.sync_t.ptp_status_t.ptp_source_t.clock_accuracy;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_cla = agt_make_int_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_clock_accuracy,
                v_clock_accuracy,
                &res);
		    if (return_val_cla) {
		        getcb_add_return_val(get2cb, return_val_cla);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_offset_scaled_log_variance)) {
            /* leaf offset-scaled-log-variance (uint16) */
        	
        	v_offset_scaled_log_variance = get_data.sync_t.ptp_status_t.ptp_source_t.offset_scaled_log_variance;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_oslv = agt_make_uint_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_offset_scaled_log_variance,
                v_offset_scaled_log_variance,
                &res);
		    if (return_val_oslv) {
		        getcb_add_return_val(get2cb, return_val_oslv);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_priority2)) {
            /* leaf priority2 (uint8) */
        	
            v_priority2 = get_data.sync_t.ptp_status_t.ptp_source_t.priority2;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_pri2 = agt_make_uint_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_priority2,
                v_priority2,
                &res);
		    if (return_val_pri2) {
		        getcb_add_return_val(get2cb, return_val_pri2);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_grandmaster_clock_identity)) {
            /* leaf grandmaster-clock-identity (string) */
        	v_grandmaster_clock_identity = (const xmlChar *)get_data.sync_t.ptp_status_t.ptp_source_t.grandmaster_clock_identity;

        	
		    /* add lock_state to get2cb return_val */
		    val_value_t *return_val_gcid = agt_make_leaf2(
		        obj,
		        y_o_ran_sync_M_o_ran_sync,
		        y_o_ran_sync_N_grandmaster_clock_identity,
		        v_grandmaster_clock_identity,
		        &res);
		    if (return_val_gcid) {
		        getcb_add_return_val(get2cb, return_val_gcid);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_steps_removed)) {
            /* leaf steps-removed (uint16) */
        	
        	v_steps_removed = get_data.sync_t.ptp_status_t.ptp_source_t.steps_removed;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_srm = agt_make_uint_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_steps_removed,
                v_steps_removed,
                &res);
		    if (return_val_srm) {
		        getcb_add_return_val(get2cb, return_val_srm);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_time_source)) {
            /* leaf time-source (uint8) */
        	
        	v_time_source = get_data.sync_t.ptp_status_t.ptp_source_t.time_source;

        	/* add sync_state to get2cb return_val */
		    val_value_t *return_val_tims = agt_make_uint_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_time_source,
                v_time_source,
                &res);
		    if (return_val_tims) {
		        getcb_add_return_val(get2cb, return_val_tims);
		    }


        }
    }

	log_info("\n%s: end. num_fix=%d, num_pre=%d, getnext=%d", __func__, local_port_number_fixed,local_port_number_present, getnext);

    return res;

} /* u_o_ran_sync_sync_ptp_status_sources_get */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_ptp_status_edit
*
* Edit database object callback
* Path: /sync/ptp-status
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_ptp_status_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_ptp_status_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_synce_config_acceptance_list_of_ssm_edit
*
* Edit database object callback
* Path: /sync/synce-config/acceptance-list-of-ssm
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_synce_config_acceptance_list_of_ssm_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_ENUM_NAME(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_ENUM_NAME(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning *//* pgr0060 */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_synce_config_acceptance_list_of_ssm_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
            if(newval)
            {
                /* acceptance_list_of_ssm */
                if (xml_strcmp(newval_val, (const xmlChar *)i_o_ran_sync_N_ssm_prc) && 
                    xml_strcmp(newval_val, (const xmlChar *)i_o_ran_sync_N_ssm_ssu_a))
                {
                    /* error */
                    res = ERR_NCX_DATA_MISSING;
                    /* error log */
                    if(LOGWARN) {
                        log_warn("\n%s: syncE_acceptance_ssm is Not Data", __func__);
                    }
                    return res;
                }
            }
            else
            {
                /* error */
                res = ERR_NCX_DATA_MISSING;
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s: syncE_acceptance_ssm is Not Data", __func__);
                }
            }
         break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
	    if (LOGDEV1) {
	        log_dev1("\n%s: editop:%d", __func__, editop);
	    }
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            if(newval)
            {
                /* edit値設定 */
                T_MPSW_MSI_O_RAN_SYNC_EDIT_REQ  edit_data;
                /* edit値初期化 */
                i_o_ran_sync_edit_table_init(&edit_data);

                /* acceptance_list_of_ssm */
                if (!xml_strcmp(newval_val, (const xmlChar *)i_o_ran_sync_N_ssm_prc))
                {
                    edit_data.ptp_config_t.syncE_acceptance_ssm[0] = E_SYNC_ACCEPTANCE_SSM_PRC;
                }
                else if (!xml_strcmp(newval_val, (const xmlChar *)i_o_ran_sync_N_ssm_ssu_a))
                {
                    edit_data.ptp_config_t.syncE_acceptance_ssm[0] = E_SYNC_ACCEPTANCE_SSM_SSU_A;
                }
                else
                {
                    /* error */
                    res = ERR_NCX_DATA_MISSING;
                    /* error log */
                    if(LOGWARN) {
                        log_warn("\n%s: syncE_acceptance_ssm is Not Data", __func__);
                    }
                    return res;
                }

                /* MSI_O_RAN_SYNC_EDIT_REQ send */
                res = i_o_ran_sync_edit_req_send_msi(&edit_data);
            }
            else
            {
                /* error */
                res = ERR_NCX_DATA_MISSING;
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s: syncE_acceptance_ssm is Not Data", __func__);
                }
            }
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_synce_config_acceptance_list_of_ssm_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_synce_config_ssm_timeout_edit
*
* Edit database object callback
* Path: /sync/synce-config/ssm-timeout
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_synce_config_ssm_timeout_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    uint16 newval_val = (newval) ? VAL_UINT16(newval) : 0;
    uint16 curval_val = (curval) ? VAL_UINT16(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_synce_config_ssm_timeout_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        res = i_o_ran_sync_sync_synce_config_ssm_timeout_validate(newval, curval);
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            if(newval)
            {
                /* edit値設定 */
                T_MPSW_MSI_O_RAN_SYNC_EDIT_REQ  edit_data;
                /* edit値初期化 */
                i_o_ran_sync_edit_table_init(&edit_data);

                /* ptp_reporting_period */
                edit_data.ptp_config_t.syncE_ssm_timeout = newval_val;

                /* MSI_O_RAN_SYNC_EDIT_REQ send */
                res = i_o_ran_sync_edit_req_send_msi(&edit_data);
            }
            else
            {
                /* error */
                res = ERR_NCX_DATA_MISSING;
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s: syncE_ssm_timeout is Not Data", __func__);
                }
            }
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_synce_config_ssm_timeout_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_synce_config_edit
*
* Edit database object callback
* Path: /sync/synce-config
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_synce_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_synce_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_synce_config_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_synce_status_reporting_period_edit
*
* Edit database object callback
* Path: /sync/synce-status/reporting-period
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_synce_status_reporting_period_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    uint8 newval_val = (newval) ? VAL_UINT8(newval) : 0;
    uint8 curval_val = (curval) ? VAL_UINT8(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        res = i_o_ran_sync_sync_synce_status_reporting_period_validate(newval, curval);

        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            if(newval)
            {
                /* edit値設定 */
                T_MPSW_MSI_O_RAN_SYNC_EDIT_REQ  edit_data;
                /* edit値初期化 */
                i_o_ran_sync_edit_table_init(&edit_data);

                /* syncE_reporting_period */
                edit_data.ptp_config_t.syncE_reporting_period = newval_val;

                /* MSI_O_RAN_SYNC_EDIT_REQ send */
                res = i_o_ran_sync_edit_req_send_msi(&edit_data);
            }
            else
            {
                /* error */
                res = ERR_NCX_DATA_MISSING;
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s: syncE_reporting_period is Not Data", __func__);
                }
            }
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_synce_status_reporting_period_edit */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_synce_status_lock_state_get
*
* Get database object callback for leaf lock-state
* Path: /sync/synce-status/lock-state
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_synce_status_lock_state_get (
    getcb_get2_t *get2cb)
{

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }


    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_lock_state = 0;
    T_MPSW_MSI_O_RAN_SYNC_GET_CFM  get_data;
    /* MSI_O_RAN_SYNC_GET_REQ送信 */
    res = i_o_ran_sync_get_send_msi(&get_data);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    xmlChar *lock_state = 0;

    switch(get_data.sync_t.synce_status_t.lockstate)
    {
    case E_SYNCE_LOCK_STATE_UNLOCKED:
        lock_state = (xmlChar *)o_ran_sync_synce_lock_state_unlocked;
        break;
    case E_SYNCE_LOCK_STATE_LOCKED:
        lock_state = (xmlChar *)o_ran_sync_synce_lock_state_locked;
        break;
    default:
        /* error */
        res = ERR_NCX_DATA_MISSING;
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: lock_state is Not Data(%d)", __func__, get_data.sync_t.synce_status_t.lockstate);
        }
        return res;
    }
    v_lock_state = (const xmlChar *)lock_state;
    if(LOGDEV1) {
        log_dev1("\n%s: v_lock_state: %s	lock_state: %s)", __func__, v_lock_state, lock_state);
    }

    /* add lock_state to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_lock_state,
        v_lock_state,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_o_ran_sync_sync_synce_status_lock_state_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_synce_status_sources_get
*
* Get database object callback for list sources
* Path: /sync/synce-status/sources
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_synce_status_sources_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_sync_synce_status_sources_local_port_number,
    boolean local_port_number_fixed,
    boolean local_port_number_present)
{
    boolean getnext = FALSE;

    if (LOGINFO) {
	log_info("\n%s: start. key=%p, num_fix=%d, num_pre=%d", __func__, k_sync_synce_status_sources_local_port_number, local_port_number_fixed,local_port_number_present);
    }


    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

	boolean more_data = FALSE;
	
    GETCB_GET2_MORE_DATA(get2cb) = more_data;
	
    /* 変数設定 */
    const xmlChar *v_sync_state = 0;
	int v_quality_level = 0;
	
    T_MPSW_MSI_O_RAN_SYNC_GET_CFM  get_data;
    /* MSI_O_RAN_SYNC_GET_REQ送信 */
    res = i_o_ran_sync_get_send_msi(&get_data);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    val_value_t *return_val = 
        agt_make_uint_leaf2(obj, 
            y_o_ran_sync_M_o_ran_sync,
            (const xmlChar *)"local-port-number", 
            get_data.sync_t.ptp_status_t.ptp_source_t.local_port_number, 
            &res); 
    if (res == NO_ERR) { 
        if (local_port_number_fixed) { 
            VAL_SET_FIXED_VALUE(return_val); 
        } 
        getcb_add_return_key(get2cb, return_val); 
    } else {
        if(LOGWARN) {
	        log_warn("%s: agt_make_uint_leaf2 ERROR %d", __func__, res);
	    }
    }
    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_sync_N_state)) {
            /* leaf state (enumeration) */

		    switch(get_data.sync_t.synce_status_t.synce_source_t.state)
		    {
		    case E_SYNCE_STATE_DISABLE:
		        v_sync_state = (const xmlChar *)o_ran_sync_synce_state_disable;
		        break;
		    case E_SYNCE_STATE_PARENT:
		        v_sync_state = (const xmlChar *)o_ran_sync_synce_state_parent;
		        break;
		    case E_SYNCE_STATE_OK:
		        v_sync_state = (const xmlChar *)o_ran_sync_synce_state_ok;
		        break;
		    case E_SYNCE_STATE_NOK:
		        v_sync_state = (const xmlChar *)o_ran_sync_synce_state_nok;
		        break;
		    	
		    default:
		        /* error */
		        res = ERR_NCX_DATA_MISSING;
		        /* error log */
		        if(LOGWARN) {
		            log_warn("\n%s: lock_state(%d) is Not Data.", __func__, get_data.sync_t.synce_status_t.synce_source_t.state);
		        }
		    	
		    	
		        return res;
		    }
        	
        	/* add sync_synce_status_sources to get2cb return_val */
		    val_value_t *return_val_state = agt_make_leaf2(
		        obj,
		        y_o_ran_sync_M_o_ran_sync,
		        y_o_ran_sync_N_state,
		        v_sync_state,
		        &res);
		    if (return_val_state) {
		        getcb_add_return_val(get2cb, return_val_state);
		    }


        } else if (!xml_strcmp(name, y_o_ran_sync_N_quality_level)) {
            /* leaf quality-level (uint8) */
        	
        	v_quality_level = get_data.sync_t.synce_status_t.synce_source_t.quality_level;
        	
        	
        	/* add sync_synce_status_sources to get2cb return_val_int */
		    val_value_t *return_val_int = agt_make_int_leaf2(
		    	obj,
		    	y_o_ran_sync_M_o_ran_sync,
                y_o_ran_sync_N_quality_level,
                v_quality_level,
                &res);
		    if (return_val_int) {
		        getcb_add_return_val(get2cb, return_val_int);
		    }
        }
    }

	log_info("\n %s: end. num_fix=%d, num_pre=%d, getnext=%d", __func__, local_port_number_fixed,local_port_number_present, getnext);
    return res;

} /* u_o_ran_sync_sync_synce_status_sources_get */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_synce_status_edit
*
* Edit database object callback
* Path: /sync/synce-status
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_synce_status_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_synce_status_edit */


#ifdef u_o_ran_sync_F_GNSS

/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_config_enable_edit
*
* Edit database object callback
* Path: /sync/gnss-config/enable
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_config_enable_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    boolean newval_val = (newval) ? VAL_BOOL(newval) : 0;
    boolean curval_val = (curval) ? VAL_BOOL(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_gnss_config_enable_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_gnss_config_enable_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_config_satellite_constelation_list_edit
*
* Edit database object callback
* Path: /sync/gnss-config/satellite-constelation-list
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_config_satellite_constelation_list_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_ENUM_NAME(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_ENUM_NAME(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning *//* pgr0060 */
    (void)curval_val;/* remove yumaworks warning *//* pgr0060 */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_gnss_config_satellite_constelation_list_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_gnss_config_satellite_constelation_list_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_config_polarity_edit
*
* Edit database object callback
* Path: /sync/gnss-config/polarity
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_config_polarity_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_ENUM_NAME(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_ENUM_NAME(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning *//* pgr0060 */
    (void)curval_val;/* remove yumaworks warning *//* pgr0060 */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_gnss_config_polarity_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_gnss_config_polarity_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_config_cable_delay_edit
*
* Edit database object callback
* Path: /sync/gnss-config/cable-delay
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_config_cable_delay_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    uint16 newval_val = (newval) ? VAL_UINT16(newval) : 0;
    uint16 curval_val = (curval) ? VAL_UINT16(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_gnss_config_cable_delay_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_gnss_config_cable_delay_edit */


#ifdef u_o_ran_sync_F_ANTI_JAM
/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_config_anti_jam_enable_edit
*
* Edit database object callback
* Path: /sync/gnss-config/anti-jam-enable
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_config_anti_jam_enable_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    boolean newval_val = (newval) ? VAL_BOOL(newval) : 0;
    boolean curval_val = (curval) ? VAL_BOOL(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_gnss_config_anti_jam_enable_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_gnss_config_anti_jam_enable_edit */
#endif /* u_o_ran_sync_F_ANTI_JAM */
/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_config_edit
*
* Edit database object callback
* Path: /sync/gnss-config
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_gnss_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_gnss_config_edit */
#endif /* u_o_ran_sync_F_GNSS */

#ifdef u_o_ran_sync_F_GNSS

/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_status_reporting_period_edit
*
* Edit database object callback
* Path: /sync/gnss-status/reporting-period
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_status_reporting_period_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    uint8 newval_val = (newval) ? VAL_UINT8(newval) : 0;
    uint8 curval_val = (curval) ? VAL_UINT8(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_gnss_status_reporting_period_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_gnss_status_reporting_period_edit */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_status_name_get
*
* Get database object callback for leaf name
* Path: /sync/gnss-status/name
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_status_name_get (
    getcb_get2_t *get2cb)
{
    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_name = 0;

    /* add name to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_name,
        v_name,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_o_ran_sync_sync_gnss_status_name_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_status_gnss_sync_status_get
*
* Get database object callback for leaf gnss-sync-status
* Path: /sync/gnss-status/gnss-sync-status
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_status_gnss_sync_status_get (
    getcb_get2_t *get2cb)
{
    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    const xmlChar *v_gnss_sync_status = 0;

    /* add gnss_sync_status to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_gnss_sync_status,
        v_gnss_sync_status,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_o_ran_sync_sync_gnss_status_gnss_sync_status_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_status_gnss_data_location_get
*
* Get database object callback for container location
* Path: /sync/gnss-status/gnss-data/location
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_status_gnss_data_location_get (
    getcb_get2_t *get2cb)
{
    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_sync_N_altitude)) {
            /* leaf altitude (int64) */

        } else if (!xml_strcmp(name, y_o_ran_sync_N_latitude)) {
            /* leaf latitude (decimal64) */

        } else if (!xml_strcmp(name, y_o_ran_sync_N_longitude)) {
            /* leaf longitude (decimal64) */

        }
    }

    return res;

} /* u_o_ran_sync_sync_gnss_status_gnss_data_location_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_status_gnss_data_get
*
* Get database object callback for container gnss-data
* Path: /sync/gnss-status/gnss-data
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_status_gnss_data_get (
    getcb_get2_t *get2cb)
{
    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_sync_N_satellites_tracked)) {
            /* leaf satellites-tracked (uint8) */

        }
    }

    return res;

} /* u_o_ran_sync_sync_gnss_status_gnss_data_get */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_gnss_status_edit
*
* Edit database object callback
* Path: /sync/gnss-status
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_gnss_status_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    if (LOGDEBUG) {
        log_debug("\nEnter u_o_ran_sync_sync_gnss_status_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_gnss_status_edit */
#endif /* u_o_ran_sync_F_GNSS */

/********************************************************************
* FUNCTION u_o_ran_sync_sync_edit
*
* Edit database object callback
* Path: /sync
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_sync_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_o_ran_sync_sync_edit */


/********************************************************************
* FUNCTION u_o_ran_sync_synchronization_state_change_send
*
* Send a u_o_ran_sync_synchronization_state_change notification
* Called by your code when notification event occurs
*
********************************************************************/
void u_o_ran_sync_synchronization_state_change_send (
    const xmlChar *v_sync_state)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <synchronization-state-change> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <synchronization-state-change> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(synchronization_state_change_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<synchronization-state-change> notification");
        return;
    }
    
    /* add sync_state to payload */
    parmval = agt_make_leaf2(
        synchronization_state_change_obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_sync_state,
        v_sync_state,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<synchronization-state-change> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    sil_sa_queue_notification(notif);
    
} /* u_o_ran_sync_synchronization_state_change_send */


/********************************************************************
* FUNCTION u_o_ran_sync_ptp_state_change_send
*
* Send a u_o_ran_sync_ptp_state_change notification
* Called by your code when notification event occurs
*
********************************************************************/
void u_o_ran_sync_ptp_state_change_send (
    const xmlChar *v_ptp_state)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <ptp-state-change> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <ptp-state-change> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(ptp_state_change_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<ptp-state-change> notification");
        return;
    }
    
    /* add ptp_state to payload */
    parmval = agt_make_leaf2(
        ptp_state_change_obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_ptp_state,
        v_ptp_state,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<ptp-state-change> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    sil_sa_queue_notification(notif);
    
} /* u_o_ran_sync_ptp_state_change_send */


/********************************************************************
* FUNCTION u_o_ran_sync_synce_state_change_send
*
* Send a u_o_ran_sync_synce_state_change notification
* Called by your code when notification event occurs
*
********************************************************************/
void u_o_ran_sync_synce_state_change_send (
    const xmlChar *v_synce_state)
{

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <synce-state-change> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <synce-state-change> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(synce_state_change_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<synce-state-change> notification");
        return;
    }
    
    /* add synce_state to payload */
    parmval = agt_make_leaf2(
        synce_state_change_obj,
        y_o_ran_sync_M_o_ran_sync,
        y_o_ran_sync_N_synce_state,
        v_synce_state,
        &res);
    if (parmval == NULL) {
        log_error(
            "\nError: make leaf failed (%s), cannot send "
            "<synce-state-change> notification",
            get_error_string(res));
    } else {
        agt_not_add_to_payload(notif, parmval);
    }
    
    sil_sa_queue_notification(notif);
    
} /* u_o_ran_sync_synce_state_change_send */


#ifdef u_o_ran_sync_F_GNSS
/********************************************************************
* FUNCTION u_o_ran_sync_gnss_state_change_send
*
* Send a u_o_ran_sync_gnss_state_change notification
* Called by your code when notification event occurs
*
********************************************************************/
void u_o_ran_sync_gnss_state_change_send (
    const xmlChar *v_gnss_state)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    if (ncx_feature_enabled_str(
        y_o_ran_sync_M_o_ran_sync, 
        y_o_ran_sync_R_o_ran_sync,
        (const xmlChar *)"GNSS")) {
        if (!agt_notifications_enabled()) {
            log_debug2("\nSkipping <gnss-state-change> notification; disabled");
            return;
        }
        
        if (LOGDEBUG) {
            log_debug("\nGenerating <gnss-state-change> notification");
        }
        
    agt_not_msg_t *notif = agt_not_new_notification(gnss_state_change_obj);
        if (notif == NULL) {
            log_error("\nError: malloc failed, cannot send "
            "<gnss-state-change> notification");
            return;
        }
        
        /* add gnss_state to payload */
        parmval = agt_make_leaf2(
            gnss_state_change_obj,
            y_o_ran_sync_M_o_ran_sync,
            y_o_ran_sync_N_gnss_state,
            v_gnss_state,
            &res);
        if (parmval == NULL) {
            log_error(
                "\nError: make leaf failed (%s), cannot send "
                "<gnss-state-change> notification",
                get_error_string(res));
        } else {
            agt_not_add_to_payload(notif, parmval);
        }
        
        sil_sa_queue_notification(notif);
        
    } /* u_o_ran_sync_F_GNSS */
} /* u_o_ran_sync_gnss_state_change_send */
#endif /* u_o_ran_sync_F_GNSS */
/********************************************************************
* FUNCTION u_o_ran_sync_init
*
* initialize the o-ran-sync server instrumentation library
*
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    ncx_module_t *o_ran_sync_mod = NULL;

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    o_ran_sync_mod = ncx_find_module(modname, revision);
    if (o_ran_sync_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }

    synchronization_state_change_obj = ncx_find_object(
        o_ran_sync_mod,
        y_o_ran_sync_N_synchronization_state_change);
    if (synchronization_state_change_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    ptp_state_change_obj = ncx_find_object(
        o_ran_sync_mod,
        y_o_ran_sync_N_ptp_state_change);
    if (ptp_state_change_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    synce_state_change_obj = ncx_find_object(
        o_ran_sync_mod,
        y_o_ran_sync_N_synce_state_change);
    if (synce_state_change_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }


#ifdef u_o_ran_sync_F_GNSS
    if (ncx_feature_enabled_str(
        y_o_ran_sync_M_o_ran_sync, 
        y_o_ran_sync_R_o_ran_sync,
        (const xmlChar *)"GNSS")) {
        gnss_state_change_obj = ncx_find_object(
            o_ran_sync_mod,
            y_o_ran_sync_N_gnss_state_change);
        if (gnss_state_change_obj == NULL) {
            return ERR_NCX_DEF_NOT_FOUND;
        }
    } /* u_o_ran_sync_F_GNSS */
#endif /* u_o_ran_sync_F_GNSS */

    /* put your module initialization code here */
    
    return res;

} /* u_o_ran_sync_init */

/********************************************************************
* FUNCTION u_o_ran_sync_init2
*
* SIL init phase 2: non-config data structures
* Called after running config is loaded
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_sync_init2 (void)
{
    status_t res = NO_ERR;

    /* put your init2 code here */
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* notificationハンドラ登録 */
    f_saa_com_reg_notification_handler(D_MSG_MSI_O_RAN_SYNC_SYNCSTATE_CHANGE_NTF_IND, i_o_ran_sync_synchronization_state_change_handler);
    f_saa_com_reg_notification_handler(D_MSG_MSI_O_RAN_SYNC_PTPSTATE_CHANGE_NTF_IND, i_o_ran_sync_ptp_state_change_send_handler);
    f_saa_com_reg_notification_handler(D_MSG_MSI_O_RAN_SYNC_SYNCESTATE_CHANGE_NTF_IND, i_o_ran_sync_synce_state_change_handler);

    return res;

} /* u_o_ran_sync_init2 */

/********************************************************************
* FUNCTION u_o_ran_sync_cleanup
*    cleanup the server instrumentation library
*
********************************************************************/
void u_o_ran_sync_cleanup (void)
{

    /* put your cleanup code here */
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    
} /* u_o_ran_sync_cleanup */

/* END SIL-SA u_o_ran_sync.c */
