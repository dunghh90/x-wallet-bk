
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2019, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump-sdk 18.10-9

    User SIL-SA module
    bundle o-ran_all
    module o-ran-dhcp
    revision 2019-02-04
    namespace urn:o-ran:dhcp:1.0
    organization O-RAN Alliance
    Created: 2019-06-21T02:49:14Z
    CLI parameters:
        defnames true
        format uc
        indent 4
        module ietf-yang-types
        module ietf-inet-types
        module ietf-interfaces
        module iana-if-type
        module ietf-ip
        module iana-hardware
        module ietf-hardware
        module ietf-netconf-acm
        module o-ran-hardware
        module o-ran-software-management
        module o-ran-interfaces
        module o-ran-transceiver
        module o-ran-mplane-int
        module o-ran-dhcp
        module o-ran-compression-factors
        module o-ran-uplane-conf
        module o-ran-module-cap
        module o-ran-processing-element
        module o-ran-performance-management
        module o-ran-fm
        module o-ran-lbm
        module o-ran-supervision
        module o-ran-beamforming
        module o-ran-operations
        module o-ran-usermgmt
        module o-ran-sync
        sil-bundle o-ran_all
        sil-get2
        sil-sa
        unified true

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_val.h"

/* SIL bundle: o-ran_all */
#include "y_ietf-yang-types.h"
#include "u_ietf-yang-types.h"
#include "y_ietf-inet-types.h"
#include "u_ietf-inet-types.h"
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_iana-if-type.h"
#include "u_iana-if-type.h"
#include "y_ietf-ip.h"
#include "u_ietf-ip.h"
#include "y_iana-hardware.h"
#include "u_iana-hardware.h"
#include "y_ietf-hardware.h"
#include "u_ietf-hardware.h"
#include "y_ietf-netconf-acm.h"
#include "u_ietf-netconf-acm.h"
#include "y_o-ran-hardware.h"
#include "u_o-ran-hardware.h"
#include "y_o-ran-software-management.h"
#include "u_o-ran-software-management.h"
#include "y_o-ran-interfaces.h"
#include "u_o-ran-interfaces.h"
#include "y_o-ran-transceiver.h"
#include "u_o-ran-transceiver.h"
#include "y_o-ran-mplane-int.h"
#include "u_o-ran-mplane-int.h"
#include "y_o-ran-dhcp.h"
#include "u_o-ran-dhcp.h"
#include "i_o-ran-dhcp.h"
#include "y_o-ran-compression-factors.h"
#include "u_o-ran-compression-factors.h"
#include "y_o-ran-uplane-conf.h"
#include "u_o-ran-uplane-conf.h"
#include "y_o-ran-module-cap.h"
#include "u_o-ran-module-cap.h"
#include "y_o-ran-processing-element.h"
#include "u_o-ran-processing-element.h"
#include "y_o-ran-performance-management.h"
#include "u_o-ran-performance-management.h"
#include "y_o-ran-fm.h"
#include "u_o-ran-fm.h"
#include "y_o-ran-lbm.h"
#include "u_o-ran-lbm.h"
#include "y_o-ran-supervision.h"
#include "u_o-ran-supervision.h"
#include "y_o-ran-beamforming.h"
#include "u_o-ran-beamforming.h"
#include "y_o-ran-operations.h"
#include "u_o-ran-operations.h"
#include "y_o-ran-usermgmt.h"
#include "u_o-ran-usermgmt.h"
#include "y_o-ran-sync.h"
#include "u_o-ran-sync.h"


/* put your static variables here */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_dhcpv4_netconf_clients_get
*
* Get database object callback for list netconf-clients
* Path: /dhcp/interfaces/dhcpv4/netconf-clients
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_dhcpv4_netconf_clients_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface,
    val_value_t *k_dhcp_interfaces_dhcpv4_netconf_clients_client,
    boolean client_fixed,
    boolean client_present)
{
    boolean getnext = FALSE;
    (void)getnext;/* remove yumaworks warning */
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */
    (void)k_dhcp_interfaces_dhcpv4_netconf_clients_client;/* remove yumaworks warning */
    (void)client_present;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries;/* remove yumaworks warning */

    boolean more_data = FALSE;

    char netconf_client_str[20] = "";
    char netconf_client_str_tmp[4] = "";
    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_REJ))];
    T_MPSW_MSI_O_RAN_DHCP_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_DHCP_GET_CFM *)buffer;

    /* MSI_O_RAN_DHCP_GET送信 */
    res = i_o_ran_dhcp_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    /* clientの文字列変換 exp)x.x.x.x */
    snprintf(netconf_client_str_tmp, sizeof(netconf_client_str_tmp), "%d",  (cfm->dhcpv4.netconf_client_id >> D_O_RAN_DHCP_3BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
    strcat(netconf_client_str, netconf_client_str_tmp);
    strcat(netconf_client_str, ".");

    snprintf(netconf_client_str_tmp, sizeof(netconf_client_str_tmp), "%d",  (cfm->dhcpv4.netconf_client_id >> D_O_RAN_DHCP_2BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
    strcat(netconf_client_str, netconf_client_str_tmp);
    strcat(netconf_client_str, ".");

    snprintf(netconf_client_str_tmp, sizeof(netconf_client_str_tmp), "%d",  (cfm->dhcpv4.netconf_client_id >> D_O_RAN_DHCP_1BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
    strcat(netconf_client_str, netconf_client_str_tmp);
    strcat(netconf_client_str, ".");

    snprintf(netconf_client_str_tmp, sizeof(netconf_client_str_tmp), "%d",  (cfm->dhcpv4.netconf_client_id & D_O_RAN_DHCP_1BYTE_MASK));
    strcat(netconf_client_str, netconf_client_str_tmp);

    const xmlChar *v_netconf_client = (const xmlChar *)netconf_client_str;

    /* if we are here, then the index is valid */
    obj_template_t *name_obj = obj_find_child(obj, y_o_ran_dhcp_M_o_ran_dhcp, y_o_ran_dhcp_N_client);
    if(name_obj == NULL) {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: name_obj is NULL", __func__);
        }
        return ERR_NCX_NO_INSTANCE;
    }

    val_value_t *retval = agt_make_leaf2(name_obj, y_o_ran_dhcp_M_o_ran_dhcp, y_o_ran_dhcp_N_client, v_netconf_client, &res);
    if (retval) {
        if (client_fixed) {
            VAL_SET_FIXED_VALUE(retval);
        }
        getcb_add_return_key(get2cb, retval);
    }

    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

//    if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
//        return ERR_NCX_NO_INSTANCE;
//    }

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag true if not sure */

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_dhcp_N_optional_port)) {
            /* leaf optional-port (uint16) */
        }
    }

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_dhcpv4_netconf_clients_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_dhcpv4_get
*
* Get database object callback for container dhcpv4
* Path: /dhcp/interfaces/dhcpv4
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_dhcpv4_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);
        (void)name;/* remove yumaworks warning */

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_dhcp_N_client_id)) {
            /* leaf client-id (string) */
        } else if (!xml_strcmp(name, y_o_ran_dhcp_N_dhcp_server_identifier)) {
            /* leaf dhcp-server-identifier (union) */
            char dhcp_server_identifier_str[20] = "";
            char dhcp_server_identifier_str_tmp[4] = "";
            char buffer[max(sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_REJ))];
            T_MPSW_MSI_O_RAN_DHCP_GET_CFM *cfm = NULL;

            memset(buffer, 0, sizeof(buffer));
            cfm = (T_MPSW_MSI_O_RAN_DHCP_GET_CFM *)buffer;

            /* MSI_O_RAN_DHCP_GET送信 */
            res = i_o_ran_dhcp_send_msi(&buffer);
            if(res != NO_ERR)
            {
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s MSI failed. res=%d", __func__, res);
                }
                return res;
            }

            /* dhcp-server-identifierの文字列変換 exp)x.x.x.x */
            snprintf(dhcp_server_identifier_str_tmp, sizeof(dhcp_server_identifier_str_tmp), "%d",  (cfm->dhcpv4.dhcp_server_id >> D_O_RAN_DHCP_3BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
            strcat(dhcp_server_identifier_str, dhcp_server_identifier_str_tmp);
            strcat(dhcp_server_identifier_str, ".");

            snprintf(dhcp_server_identifier_str_tmp, sizeof(dhcp_server_identifier_str_tmp), "%d",  (cfm->dhcpv4.dhcp_server_id >> D_O_RAN_DHCP_2BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
            strcat(dhcp_server_identifier_str, dhcp_server_identifier_str_tmp);
            strcat(dhcp_server_identifier_str, ".");

            snprintf(dhcp_server_identifier_str_tmp, sizeof(dhcp_server_identifier_str_tmp), "%d",  (cfm->dhcpv4.dhcp_server_id >> D_O_RAN_DHCP_1BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
            strcat(dhcp_server_identifier_str, dhcp_server_identifier_str_tmp);
            strcat(dhcp_server_identifier_str, ".");

            snprintf(dhcp_server_identifier_str_tmp, sizeof(dhcp_server_identifier_str_tmp), "%d",  cfm->dhcpv4.dhcp_server_id & D_O_RAN_DHCP_1BYTE_MASK);
            strcat(dhcp_server_identifier_str, dhcp_server_identifier_str_tmp);

            const xmlChar *v_dhcp_server_identifier = (const xmlChar *)dhcp_server_identifier_str;
            val_value_t *return_val = agt_make_leaf2(
                obj,
                y_o_ran_dhcp_M_o_ran_dhcp,
                y_o_ran_dhcp_N_dhcp_server_identifier,
                v_dhcp_server_identifier,
                &res);
            if (return_val) {
                getcb_add_return_val(get2cb, return_val);
            }

        } else if (!xml_strcmp(name, y_o_ran_dhcp_N_domain_name)) {
            /* leaf domain-name (string) */
        } else if (!xml_strcmp(name, y_o_ran_dhcp_N_domain_name_servers)) {
            /* leaf-list domain-name-servers (union) */
        } else if (!xml_strcmp(name, y_o_ran_dhcp_N_interface_mtu)) {
            /* leaf interface-mtu (uint32) */
            xmlChar *init_data = 0;
            char init_param_name[] = i_para_o_ran_dhcp_mtu;
            res = i_o_ran_dhcp_get_init_data(init_param_name, &init_data);
            if(res != NO_ERR)
            {
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s:%d wrong status. res=%d", __func__, __LINE__, res);
                }
                return res;
            }

            val_value_t *return_val = agt_make_uint_leaf2(
                obj,
                y_o_ran_dhcp_M_o_ran_dhcp,
                y_o_ran_dhcp_N_interface_mtu,
                (uint32)strtoul((char*)init_data, NULL, 10),
                &res);
            if (return_val) {
                getcb_add_return_val(get2cb, return_val);
            }

        } else if (!xml_strcmp(name, y_o_ran_dhcp_N_default_gateways)) {
            /* leaf-list default-gateways (union) */
            char default_gateways_str[20] = "";
            char default_gateways_str_tmp[4] = "";
            char buffer[max(sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_REJ))];
            T_MPSW_MSI_O_RAN_DHCP_GET_CFM *cfm = NULL;

            memset(buffer, 0, sizeof(buffer));
            cfm = (T_MPSW_MSI_O_RAN_DHCP_GET_CFM *)buffer;

            /* MSI_O_RAN_DHCP_GET送信 */
            res = i_o_ran_dhcp_send_msi(&buffer);
            if(res != NO_ERR)
            {
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s MSI failed. res=%d", __func__, res);
                }
                return res;
            }

            /* default-gatewaysの文字列変換 exp)x.x.x.x */
            snprintf(default_gateways_str_tmp, sizeof(default_gateways_str_tmp), "%d",  (cfm->dhcpv4.default_gateway  >> D_O_RAN_DHCP_3BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
            strcat(default_gateways_str, default_gateways_str_tmp);
            strcat(default_gateways_str, ".");

            snprintf(default_gateways_str_tmp, sizeof(default_gateways_str_tmp), "%d",  (cfm->dhcpv4.default_gateway  >> D_O_RAN_DHCP_2BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
            strcat(default_gateways_str, default_gateways_str_tmp);
            strcat(default_gateways_str, ".");

            snprintf(default_gateways_str_tmp, sizeof(default_gateways_str_tmp), "%d",  (cfm->dhcpv4.default_gateway  >> D_O_RAN_DHCP_1BYTE_SHIFT) & D_O_RAN_DHCP_1BYTE_MASK);
            strcat(default_gateways_str, default_gateways_str_tmp);
            strcat(default_gateways_str, ".");

            snprintf(default_gateways_str_tmp, sizeof(default_gateways_str_tmp), "%d",  cfm->dhcpv4.default_gateway & D_O_RAN_DHCP_1BYTE_MASK);
            strcat(default_gateways_str, default_gateways_str_tmp);

            const xmlChar *v_default_gateways = (const xmlChar *)default_gateways_str;
            val_value_t *return_val = agt_make_leaf2(
                obj,
                y_o_ran_dhcp_M_o_ran_dhcp,
                y_o_ran_dhcp_N_default_gateways,
                v_default_gateways,
                &res);
            if (return_val) {
                getcb_add_return_val(get2cb, return_val);
            }
        }
    }

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_dhcpv4_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_client_identifier_duid_type_get
*
* Get database object callback for choice duid-type
* Path: /dhcp/interfaces/dhcpv6/dhcp-client-identifier/duid-type
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_client_identifier_duid_type_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* サポートNoのためERR_NCX_NO_INSTANCEを返す */
    return ERR_NCX_NO_INSTANCE;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the active case; determined by the SIL or SIL-SA
     * callback based on instances in the system
     * It may be NULL if no active case and choice is optional */
    const xmlChar *active_case_modname = NULL;
    const xmlChar *active_case = NULL;

    if (active_case == NULL) {
        return ERR_NCX_NO_INSTANCE;
    }

    /* set the active case return values */
    res = getcb_set_active_case(get2cb, active_case_modname, active_case);
    if (res != NO_ERR) {
        return res;
    }

    /* get the template for the active case */
    obj_template_t *case_obj = 
        obj_find_child(obj, active_case_modname, active_case);
    if (case_obj == NULL) {
        return ERR_NCX_NOT_FOUND;
    }
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, case_obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);
        (void)name;/* remove yumaworks warning */

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

    }

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_client_identifier_duid_type_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_client_identifier_get
*
* Get database object callback for container dhcp-client-identifier
* Path: /dhcp/interfaces/dhcpv6/dhcp-client-identifier
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_client_identifier_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* サポートNoのためERR_NCX_NO_INSTANCEを返す */
    return ERR_NCX_NO_INSTANCE;

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_dhcp_N_type_code)) {
            /* leaf type-code (uint16) */

        }
    }

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_client_identifier_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_server_identifier_duid_type_get
*
* Get database object callback for choice duid-type
* Path: /dhcp/interfaces/dhcpv6/dhcp-server-identifier/duid-type
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_server_identifier_duid_type_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* サポートNoのためERR_NCX_NO_INSTANCEを返す */
    return ERR_NCX_NO_INSTANCE;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the active case; determined by the SIL or SIL-SA
     * callback based on instances in the system
     * It may be NULL if no active case and choice is optional */
    const xmlChar *active_case_modname = NULL;
    const xmlChar *active_case = NULL;

    if (active_case == NULL) {
        return ERR_NCX_NO_INSTANCE;
    }

    /* set the active case return values */
    res = getcb_set_active_case(get2cb, active_case_modname, active_case);
    if (res != NO_ERR) {
        return res;
    }

    /* get the template for the active case */
    obj_template_t *case_obj = 
        obj_find_child(obj, active_case_modname, active_case);
    if (case_obj == NULL) {
        return ERR_NCX_NOT_FOUND;
    }
    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, case_obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);
        (void)name;/* remove yumaworks warning */

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

    }

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_server_identifier_duid_type_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_server_identifier_get
*
* Get database object callback for container dhcp-server-identifier
* Path: /dhcp/interfaces/dhcpv6/dhcp-server-identifier
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_server_identifier_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* サポートNoのためERR_NCX_NO_INSTANCEを返す */
    return ERR_NCX_NO_INSTANCE;

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_dhcp_N_type_code)) {
            /* leaf type-code (uint16) */

        }
    }

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_dhcpv6_dhcp_server_identifier_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_dhcpv6_netconf_clients_get
*
* Get database object callback for list netconf-clients
* Path: /dhcp/interfaces/dhcpv6/netconf-clients
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_dhcpv6_netconf_clients_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface,
    val_value_t *k_dhcp_interfaces_dhcpv6_netconf_clients_client,
    boolean client_fixed,
    boolean client_present)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */
    (void)k_dhcp_interfaces_dhcpv6_netconf_clients_client;/* remove yumaworks warning */
    (void)client_fixed;/* remove yumaworks warning */
    (void)client_present;/* remove yumaworks warning */

    boolean getnext = FALSE;
    (void)getnext;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* サポートNoのためERR_NCX_NO_INSTANCEを返す */
    return ERR_NCX_NO_INSTANCE;

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries;/* remove yumaworks warning */


    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

//    if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
//        return ERR_NCX_NO_INSTANCE;
//    }

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data = TRUE;

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_dhcp_N_optional_port)) {
            /* leaf optional-port (uint16) */

        }
    }

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_dhcpv6_netconf_clients_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_dhcpv6_get
*
* Get database object callback for container dhcpv6
* Path: /dhcp/interfaces/dhcpv6
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_dhcpv6_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* サポートNoのためERR_NCX_NO_INSTANCEを返す */
    return ERR_NCX_NO_INSTANCE;

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_dhcp_N_domain_name)) {
            /* leaf domain-name (string) */

        } else if (!xml_strcmp(name, y_o_ran_dhcp_N_domain_name_servers)) {
            /* leaf-list domain-name-servers (union) */

        }
    }

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_dhcpv6_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_interfaces_get
*
* Get database object callback for list interfaces
* Path: /dhcp/interfaces
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_interfaces_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_dhcp_interfaces_interface,
    boolean interface_fixed,
    boolean interface_present)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_dhcp_interfaces_interface;/* remove yumaworks warning */
    (void)interface_present;/* remove yumaworks warning */

    boolean getnext = FALSE;
    (void)getnext;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        getnext = TRUE;
        break;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    uint32 max_entries = GETCB_GET2_MAX_ENTRIES(get2cb);
    (void)max_entries;/* remove yumaworks warning */


    /* For GET, find the entry that matches the key values
     * For GETNEXT, find the entry that matches the next key value
     * If the 'present' flag is false then return first key instance
     * If the 'fixed' flag is true then no GETNEXT advance for the key
     * Create a new return key val_value_t, then getcb_add_return_key */

    /***** ADD RETURN KEYS AND REMOVE THIS COMMENT ****/

//    if (GETCB_GET2_FIRST_RETURN_KEY(get2cb) == NULL) {
//        return ERR_NCX_NO_INSTANCE;
//    }

    /* For GETNEXT, set the more_data flag true if not sure */
    boolean more_data = FALSE;

    char buffer[max(sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_REJ))];
    T_MPSW_MSI_O_RAN_DHCP_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_O_RAN_DHCP_GET_CFM *)buffer;

    /* MSI_O_RAN_DHCP_GET送信 */
    res = i_o_ran_dhcp_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    xmlChar key[D_PARAM_NUM_MAX];
    if(cfm->interface == D_IETF_INTERFACE_FHETH_PORT0)
    {
        xml_strcpy(key, i_ietf_interface_N_name_fheth0);
    }
    else
    {
        /* error */
        res = ERR_NCX_INVALID_VALUE;
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s interface is NG. interface=%d", __func__, cfm->interface);
        }
        return res;
    }
    const xmlChar *v_key = (const xmlChar *)key;

    /* if we are here, then the index is valid */
    obj_template_t *name_obj = obj_find_child(obj, y_o_ran_dhcp_M_o_ran_dhcp, y_o_ran_dhcp_N_interface);
    if(name_obj == NULL) {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: name_obj is NULL", __func__);
        }
        return ERR_NCX_NO_INSTANCE;
    }

    val_value_t *retval = agt_make_leaf2(name_obj, y_o_ran_dhcp_M_o_ran_dhcp, y_o_ran_dhcp_N_interface, v_key, &res);
    if (retval) {
        if (interface_fixed) {
            VAL_SET_FIXED_VALUE(retval);
        }
        getcb_add_return_key(get2cb, retval);
    }

    /**** SET more_data FLAG ****/

    GETCB_GET2_MORE_DATA(get2cb) = more_data;

    /* no terminal child nodes to check */

    return res;

} /* u_o_ran_dhcp_dhcp_interfaces_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_m_plane_dhcp_get
*
* Get database object callback for container m-plane-dhcp
* Path: /dhcp/m-plane-dhcp
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_m_plane_dhcp_get (
    getcb_get2_t *get2cb)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_o_ran_dhcp_N_private_enterprise_number)) {
            /* leaf private-enterprise-number (uint16) */
            uint16 v_private_enterprise_number = 0;
            char buffer[max(sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_CFM), sizeof(T_MPSW_MSI_O_RAN_DHCP_GET_REJ))];
            T_MPSW_MSI_O_RAN_DHCP_GET_CFM *cfm = NULL;

            memset(buffer, 0, sizeof(buffer));
            cfm = (T_MPSW_MSI_O_RAN_DHCP_GET_CFM *)buffer;


            /* MSI_O_RAN_DHCP_GET送信 */
            res = i_o_ran_dhcp_send_msi(&buffer);
            if(res != NO_ERR)
            {
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s MSI failed. res=%d", __func__, res);
                }
                return res;
            }

            v_private_enterprise_number = (uint16)cfm->m_plane_dhcp.private_enterprise_number;
            val_value_t *return_val = agt_make_uint_leaf2(
                obj,
                y_o_ran_dhcp_M_o_ran_dhcp,
                y_o_ran_dhcp_N_private_enterprise_number,
                v_private_enterprise_number,
                &res);
            if (return_val) {
                getcb_add_return_val(get2cb, return_val);
            }

        } else if (!xml_strcmp(name, y_o_ran_dhcp_N_vendor_class_data)) {
            /* leaf vendor-class-data (string) */
            xmlChar *init_data = 0;
            char init_param_name[] = i_para_o_ran_dhcp_vendor_class_data;
            res = i_o_ran_dhcp_get_init_data(init_param_name, &init_data);
            if(res != NO_ERR)
            {
                /* error log */
                if(LOGWARN) {
                    log_warn("\n%s:%d wrong status. res=%d", __func__, __LINE__, res);
                }
                return res;
            }

            const xmlChar *v_init_data = (const xmlChar *)init_data;
            val_value_t *return_val = agt_make_leaf2(
                obj,
                y_o_ran_dhcp_M_o_ran_dhcp,
                y_o_ran_dhcp_N_vendor_class_data,
                v_init_data,
                &res);
            if (return_val) {
                getcb_add_return_val(get2cb, return_val);
            }
        }
    }

    return res;

} /* u_o_ran_dhcp_dhcp_m_plane_dhcp_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_dhcp_get
*
* Get database object callback for container dhcp
* Path: /dhcp
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_dhcp_get (
    getcb_get2_t *get2cb)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    (void)obj;/* remove yumaworks warning */
    status_t res = NO_ERR;

    /* no terminal child nodes to check */

    return res;

} /* u_o_ran_dhcp_dhcp_get */

/********************************************************************
* FUNCTION u_o_ran_dhcp_init
*
* initialize the o-ran-dhcp server instrumentation library
*
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    status_t res = NO_ERR;
    ncx_module_t *o_ran_dhcp_mod = NULL;

    o_ran_dhcp_mod = ncx_find_module(modname, revision);
    if (o_ran_dhcp_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }

    /* put your module initialization code here */
    
    return res;

} /* u_o_ran_dhcp_init */

/********************************************************************
* FUNCTION u_o_ran_dhcp_init2
*
* SIL init phase 2: non-config data structures
* Called after running config is loaded
*
* RETURNS:
*     error status
********************************************************************/
status_t u_o_ran_dhcp_init2 (void)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    status_t res = NO_ERR;

    /* put your init2 code here */

    return res;

} /* u_o_ran_dhcp_init2 */

/********************************************************************
* FUNCTION u_o_ran_dhcp_cleanup
*    cleanup the server instrumentation library
*
********************************************************************/
void u_o_ran_dhcp_cleanup (void)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* put your cleanup code here */
    
} /* u_o_ran_dhcp_cleanup */

/* END SIL-SA u_o_ran_dhcp.c */
