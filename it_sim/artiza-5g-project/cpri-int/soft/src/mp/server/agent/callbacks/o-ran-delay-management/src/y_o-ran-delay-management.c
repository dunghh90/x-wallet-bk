
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2019, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump-sdk 18.10-15

    YumaPro SIL-SA module
    module o-ran-delay-management
    revision 2019-02-04
    namespace urn:o-ran:delay:1.0
    organization O-RAN Alliance
    Created: 2019-12-20T02:20:29Z
    CLI parameters:
        format yc
        indent 4
        module o-ran-delay-management
        output y_o-ran-delay-management.c
        sil-get2
        sil-sa
        unified true

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_val.h"
#include "u_o-ran-delay-management.h"
#include "y_o-ran-delay-management.h"

/* module static variables */
static ncx_module_t *o_ran_delay_management_mod;
static obj_template_t *delay_management_obj;
static val_value_t *delay_management_val;

/********************************************************************
* FUNCTION y_o_ran_delay_management_init_static_vars
*
* initialize module static variables
*
********************************************************************/
static void y_o_ran_delay_management_init_static_vars (void)
{
    o_ran_delay_management_mod = NULL;
    delay_management_obj = NULL;
    delay_management_val = NULL;

} /* y_o_ran_delay_management_init_static_vars */

/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_bandwidth_scs_delay_state_ru_delay_profile_get
*
* Get database object callback for container ru-delay-profile
* Path: /delay-management/bandwidth-scs-delay-state/ru-delay-profile
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_bandwidth_scs_delay_state_ru_delay_profile_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-delay-management:bandwidth */
    uint32 k_delay_management_bandwidth_scs_delay_state_bandwidth = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_delay_management_M_o_ran_delay_management,
        y_o_ran_delay_management_N_bandwidth);
    if (keyval) {
        k_delay_management_bandwidth_scs_delay_state_bandwidth = VAL_UINT(keyval);
    }

    /* ancestor key o-ran-delay-management:subcarrier-spacing */
    uint32 k_delay_management_bandwidth_scs_delay_state_subcarrier_spacing = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_delay_management_M_o_ran_delay_management,
        y_o_ran_delay_management_N_subcarrier_spacing);
    if (keyval) {
        k_delay_management_bandwidth_scs_delay_state_subcarrier_spacing = VAL_UINT(keyval);
    }

    return u_o_ran_delay_management_delay_management_bandwidth_scs_delay_state_ru_delay_profile_get(
        get2cb,
        k_delay_management_bandwidth_scs_delay_state_bandwidth,
        k_delay_management_bandwidth_scs_delay_state_subcarrier_spacing);

} /* o_ran_delay_management_delay_management_bandwidth_scs_delay_state_ru_delay_profile_get */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_bandwidth_scs_delay_state_edit
*
* Edit database object callback
* Path: /delay-management/bandwidth-scs-delay-state
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_bandwidth_scs_delay_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key o-ran-delay-management:bandwidth */
    uint32 k_delay_management_bandwidth_scs_delay_state_bandwidth =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* local key o-ran-delay-management:subcarrier-spacing */
    uint32 k_delay_management_bandwidth_scs_delay_state_subcarrier_spacing =
        VAL_UINT(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_bandwidth_scs_delay_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_bandwidth_scs_delay_state_edit(scb, msg, cbtyp, editop, newval, curval,
        k_delay_management_bandwidth_scs_delay_state_bandwidth,
        k_delay_management_bandwidth_scs_delay_state_subcarrier_spacing);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_bandwidth_scs_delay_state_edit */


#ifdef u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE

/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_t1a_max_up_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/bandwidth-scs-delay-state/o-du-delay-profile/t1a-max-up
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_t1a_max_up_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-delay-management:bandwidth */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-delay-management:subcarrier-spacing */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing =
        VAL_UINT(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_t1a_max_up_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_t1a_max_up_edit(scb, msg, cbtyp, editop, newval, curval,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_t1a_max_up_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_tx_max_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/bandwidth-scs-delay-state/o-du-delay-profile/tx-max
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_tx_max_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-delay-management:bandwidth */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-delay-management:subcarrier-spacing */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing =
        VAL_UINT(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_tx_max_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_tx_max_edit(scb, msg, cbtyp, editop, newval, curval,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_tx_max_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_ta4_max_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/bandwidth-scs-delay-state/o-du-delay-profile/ta4-max
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_ta4_max_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-delay-management:bandwidth */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-delay-management:subcarrier-spacing */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing =
        VAL_UINT(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_ta4_max_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_ta4_max_edit(scb, msg, cbtyp, editop, newval, curval,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_ta4_max_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_rx_max_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/bandwidth-scs-delay-state/o-du-delay-profile/rx-max
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_rx_max_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-delay-management:bandwidth */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-delay-management:subcarrier-spacing */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing =
        VAL_UINT(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_rx_max_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_rx_max_edit(scb, msg, cbtyp, editop, newval, curval,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_rx_max_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/bandwidth-scs-delay-state/o-du-delay-profile
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-delay-management:bandwidth */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-delay-management:subcarrier-spacing */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing =
        VAL_UINT(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_edit(scb, msg, cbtyp, editop, newval, curval,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/bandwidth-scs-delay-state
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key o-ran-delay-management:bandwidth */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth =
        VAL_UINT(sil_sa_get_key(msg, 1));

    /* local key o-ran-delay-management:subcarrier-spacing */
    uint32 k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing =
        VAL_UINT(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_edit(scb, msg, cbtyp, editop, newval, curval,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_bandwidth,
        k_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_subcarrier_spacing);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_min_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/transport-delay/t12-min
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_min_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_min_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_min_edit(scb, msg, cbtyp, editop, newval, curval);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_min_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_min_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/transport-delay/t34-min
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_min_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_min_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_min_edit(scb, msg, cbtyp, editop, newval, curval);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_min_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_max_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/transport-delay/t12-max
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_max_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_max_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_max_edit(scb, msg, cbtyp, editop, newval, curval);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_max_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_max_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/transport-delay/t34-max
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_max_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_max_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_max_edit(scb, msg, cbtyp, editop, newval, curval);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_max_edit */


/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration/transport-delay
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_edit(scb, msg, cbtyp, editop, newval, curval);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_edit */

/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_adaptive_delay_configuration_edit
*
* Edit database object callback
* Path: /delay-management/adaptive-delay-configuration
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_adaptive_delay_configuration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_adaptive_delay_configuration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_adaptive_delay_configuration_edit(scb, msg, cbtyp, editop, newval, curval);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_adaptive_delay_configuration_edit */
#endif /* u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE */

/********************************************************************
* FUNCTION o_ran_delay_management_delay_management_edit
*
* Edit database object callback
* Path: /delay-management
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_delay_management_delay_management_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_delay_management_delay_management_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_delay_management_delay_management_edit(scb, msg, cbtyp, editop, newval, curval);

    if (res == NO_ERR && cbtyp == AGT_CB_COMMIT) {
        res = agt_check_cache(&delay_management_val, newval, curval, editop);
    }
    

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_delay_management_delay_management_edit */

/********************************************************************
* FUNCTION y_o_ran_delay_management_init
*
* initialize the o-ran-delay-management server instrumentation library
*
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
*
* RETURNS:
*     error status
********************************************************************/
status_t y_o_ran_delay_management_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;

    y_o_ran_delay_management_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_o_ran_delay_management_M_o_ran_delay_management)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_o_ran_delay_management_R_o_ran_delay_management)) {
        return ERR_NCX_WRONG_VERSION;
    }

    res = ncx_set_feature_enable(
        y_o_ran_delay_management_M_o_ran_delay_management,
        (const xmlChar *)"ADAPTIVE-RU-PROFILE",
#ifdef u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE
        true);
#else
        false);
#endif
    if (res != NO_ERR) {
        return res;
    }



    res = ncxmod_load_module(
        y_o_ran_delay_management_M_o_ran_delay_management,
        y_o_ran_delay_management_R_o_ran_delay_management,
        agt_get_savedevQ(),
        &o_ran_delay_management_mod);
    if (res != NO_ERR) {
        return res;
    }

    delay_management_obj = ncx_find_object(
        o_ran_delay_management_mod,
        y_o_ran_delay_management_N_delay_management);
    if (delay_management_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    res = agt_cb_register_callback(
        y_o_ran_delay_management_M_o_ran_delay_management,
        (const xmlChar *)"/o-ran-delay:delay-management",
        y_o_ran_delay_management_R_o_ran_delay_management,
        o_ran_delay_management_delay_management_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_delay_management_M_o_ran_delay_management,
        (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:bandwidth-scs-delay-state",
        y_o_ran_delay_management_R_o_ran_delay_management,
        o_ran_delay_management_delay_management_bandwidth_scs_delay_state_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_delay_management_M_o_ran_delay_management,
        (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:bandwidth-scs-delay-state/o-ran-delay:ru-delay-profile",
        y_o_ran_delay_management_R_o_ran_delay_management,
        o_ran_delay_management_delay_management_bandwidth_scs_delay_state_ru_delay_profile_get);
    if (res != NO_ERR) {
        return res;
    }


#ifdef u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE
    if (ncx_feature_enabled_str(
        y_o_ran_delay_management_M_o_ran_delay_management,
        y_o_ran_delay_management_R_o_ran_delay_management,
        (const xmlChar *)"ADAPTIVE-RU-PROFILE")) {
        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:bandwidth-scs-delay-state",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:bandwidth-scs-delay-state/o-ran-delay:o-du-delay-profile",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:bandwidth-scs-delay-state/o-ran-delay:o-du-delay-profile/o-ran-delay:t1a-max-up",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_t1a_max_up_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:bandwidth-scs-delay-state/o-ran-delay:o-du-delay-profile/o-ran-delay:tx-max",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_tx_max_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:bandwidth-scs-delay-state/o-ran-delay:o-du-delay-profile/o-ran-delay:ta4-max",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_ta4_max_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:bandwidth-scs-delay-state/o-ran-delay:o-du-delay-profile/o-ran-delay:rx-max",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_bandwidth_scs_delay_state_o_du_delay_profile_rx_max_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:transport-delay",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:transport-delay/o-ran-delay:t12-min",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_min_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:transport-delay/o-ran-delay:t34-min",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_min_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:transport-delay/o-ran-delay:t12-max",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t12_max_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:transport-delay/o-ran-delay:t34-max",
            y_o_ran_delay_management_R_o_ran_delay_management,
            o_ran_delay_management_delay_management_adaptive_delay_configuration_transport_delay_t34_max_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE */
#endif /* u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE */

    res = u_o_ran_delay_management_init(modname, revision);
    return res;

} /* y_o_ran_delay_management_init */

/********************************************************************
* FUNCTION y_o_ran_delay_management_init2
*
* SIL init phase 2: non-config data structures
* Called after running config is loaded
*
* RETURNS:
*     error status
********************************************************************/
status_t y_o_ran_delay_management_init2 (void)
{
    status_t res = NO_ERR;

    res = u_o_ran_delay_management_init2();

    return res;

} /* y_o_ran_delay_management_init2 */

/********************************************************************
* FUNCTION y_o_ran_delay_management_cleanup
*    cleanup the server instrumentation library
*
********************************************************************/
void y_o_ran_delay_management_cleanup (void)
{

    agt_cb_unregister_callbacks(
        y_o_ran_delay_management_M_o_ran_delay_management,
        (const xmlChar *)"/o-ran-delay:delay-management");

    agt_cb_unregister_callbacks(
        y_o_ran_delay_management_M_o_ran_delay_management,
        (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:bandwidth-scs-delay-state");

    agt_cb_unregister_callbacks(
        y_o_ran_delay_management_M_o_ran_delay_management,
        (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:bandwidth-scs-delay-state/o-ran-delay:ru-delay-profile");


#ifdef u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE
    if (ncx_feature_enabled_str(
        y_o_ran_delay_management_M_o_ran_delay_management,
        y_o_ran_delay_management_R_o_ran_delay_management,
        (const xmlChar *)"ADAPTIVE-RU-PROFILE")) {
        agt_cb_unregister_callbacks(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration");

        agt_cb_unregister_callbacks(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:bandwidth-scs-delay-state");

        agt_cb_unregister_callbacks(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:bandwidth-scs-delay-state/o-ran-delay:o-du-delay-profile");

        agt_cb_unregister_callbacks(
            y_o_ran_delay_management_M_o_ran_delay_management,
            (const xmlChar *)"/o-ran-delay:delay-management/o-ran-delay:adaptive-delay-configuration/o-ran-delay:transport-delay");
    } /* u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE */
#endif /* u_o_ran_delay_management_F_ADAPTIVE_RU_PROFILE */
    u_o_ran_delay_management_cleanup();

} /* y_o_ran_delay_management_cleanup */

/* END SIL-SA y_o_ran_delay_management.c */
