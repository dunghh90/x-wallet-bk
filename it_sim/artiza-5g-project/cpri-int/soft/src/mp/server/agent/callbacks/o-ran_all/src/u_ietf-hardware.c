
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2019, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump-sdk 18.10-9

    User SIL-SA module
    bundle o-ran_all
    module ietf-hardware
    revision 2018-03-13
    namespace urn:ietf:params:xml:ns:yang:ietf-hardware
    organization IETF NETMOD (Network Modeling) Working Group
    Created: 2019-06-21T02:49:14Z
    CLI parameters:
        defnames true
        format uc
        indent 4
        module ietf-yang-types
        module ietf-inet-types
        module ietf-interfaces
        module iana-if-type
        module ietf-ip
        module iana-hardware
        module ietf-hardware
        module ietf-netconf-acm
        module o-ran-hardware
        module o-ran-software-management
        module o-ran-interfaces
        module o-ran-transceiver
        module o-ran-mplane-int
        module o-ran-dhcp
        module o-ran-compression-factors
        module o-ran-uplane-conf
        module o-ran-module-cap
        module o-ran-processing-element
        module o-ran-performance-management
        module o-ran-fm
        module o-ran-lbm
        module o-ran-supervision
        module o-ran-beamforming
        module o-ran-operations
        module o-ran-usermgmt
        module o-ran-sync
        sil-bundle o-ran_all
        sil-get2
        sil-sa
        unified true

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "ses.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_util.h"
#include "xml_val.h"

/* SIL bundle: o-ran_all */
#include "y_ietf-yang-types.h"
#include "u_ietf-yang-types.h"
#include "y_ietf-inet-types.h"
#include "u_ietf-inet-types.h"
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_iana-if-type.h"
#include "u_iana-if-type.h"
#include "y_ietf-ip.h"
#include "u_ietf-ip.h"
#include "y_iana-hardware.h"
#include "u_iana-hardware.h"
#include "y_ietf-hardware.h"
#include "u_ietf-hardware.h"
#include "y_ietf-netconf-acm.h"
#include "u_ietf-netconf-acm.h"
#include "y_o-ran-hardware.h"
#include "u_o-ran-hardware.h"
#include "y_o-ran-software-management.h"
#include "u_o-ran-software-management.h"
#include "y_o-ran-interfaces.h"
#include "u_o-ran-interfaces.h"
#include "y_o-ran-transceiver.h"
#include "u_o-ran-transceiver.h"
#include "y_o-ran-mplane-int.h"
#include "u_o-ran-mplane-int.h"
#include "y_o-ran-dhcp.h"
#include "u_o-ran-dhcp.h"
#include "y_o-ran-compression-factors.h"
#include "u_o-ran-compression-factors.h"
#include "y_o-ran-uplane-conf.h"
#include "u_o-ran-uplane-conf.h"
#include "y_o-ran-module-cap.h"
#include "u_o-ran-module-cap.h"
#include "y_o-ran-processing-element.h"
#include "u_o-ran-processing-element.h"
#include "y_o-ran-performance-management.h"
#include "u_o-ran-performance-management.h"
#include "y_o-ran-fm.h"
#include "u_o-ran-fm.h"
#include "y_o-ran-lbm.h"
#include "u_o-ran-lbm.h"
#include "y_o-ran-supervision.h"
#include "u_o-ran-supervision.h"
#include "y_o-ran-beamforming.h"
#include "u_o-ran-beamforming.h"
#include "y_o-ran-operations.h"
#include "u_o-ran-operations.h"
#include "y_o-ran-usermgmt.h"
#include "u_o-ran-usermgmt.h"
#include "y_o-ran-sync.h"
#include "u_o-ran-sync.h"
#include "i_ietf-hardware.h"
#include "f_saa_ntf_lib.h"
#include "f_saa_utc_lib.h"

static obj_template_t *hardware_state_change_obj;

#ifdef u_ietf_hardware_F_hardware_state
static obj_template_t *hardware_state_oper_enabled_obj;
#endif /* u_ietf_hardware_F_hardware_state */

#ifdef u_ietf_hardware_F_hardware_state
static obj_template_t *hardware_state_oper_disabled_obj;
#endif /* u_ietf_hardware_F_hardware_state */

/* put your static variables here */
static char ietf_hardware_oper_state_unknown[]      = i_ietf_hardware_N_oper_state_unknown;
static char ietf_hardware_oper_state_disabled[]     = i_ietf_hardware_N_oper_state_disabled;
static char ietf_hardware_oper_state_enabled[]      = i_ietf_hardware_N_oper_state_enabled;
static char ietf_hardware_oper_state_testing[]      = i_ietf_hardware_N_oper_state_testing;

static char ietf_hardware_usage_state_unknown[]     = i_ietf_hardware_N_usage_state_unknown;
static char ietf_hardware_usage_state_idle[]        = i_ietf_hardware_N_usage_state_idle;
static char ietf_hardware_usage_state_active[]      = i_ietf_hardware_N_usage_state_active;
static char ietf_hardware_usage_state_busy[]        = i_ietf_hardware_N_usage_state_busy;
/********************************************************************
* FUNCTION u_ietf_hardware_hardware_last_change_get
*
* Get database object callback for leaf last-change
* Path: /hardware/last-change
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_last_change_get (
    getcb_get2_t *get2cb)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    char last_changed_str[D_UTC_STRING_NUM_MAX] = "";
    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_STATE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_STATE_GET送信 */
    res = i_ietf_hardware_state_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    /* last_changedの文字列変換 */
    /* yyyy-mm-ddThh:mm:ss.0000+00:00 */
    int rc = D_SYS_OK;
    rc = f_saa_com_utc_to_offset_string(
        cfm->msi_ietf_state_t.last_changed.year,
        cfm->msi_ietf_state_t.last_changed.month,
        cfm->msi_ietf_state_t.last_changed.day,
        cfm->msi_ietf_state_t.last_changed.hour,
        cfm->msi_ietf_state_t.last_changed.min,
        cfm->msi_ietf_state_t.last_changed.sec,
        last_changed_str);
    if(rc != D_SYS_OK)
    {
        if(LOGWARN) {
            log_warn("\n%s: f_saa_com_utc_to_offset_string() failed.", __func__);
        }
        res = ERR_NCX_OPERATION_FAILED;
        return res;
    }

    const xmlChar *v_last_change = (const xmlChar *)last_changed_str;
    if (LOGDEV1) {
        log_dev1("\n%s:v_last_change=%s", __func__, v_last_change);
    }

    /* add last_change to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_last_change,
        v_last_change,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_last_change_get */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_class_edit
*
* Edit database object callback
* Path: /hardware/component/class
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_class_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    const val_idref_t *newval_val = (newval) ? VAL_IDREF(newval) : 0;
    const val_idref_t *curval_val = (curval) ? VAL_IDREF(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)k_hardware_component_name;/* remove yumaworks warning */
    (void)curval_val;/* pgr0060 */ /* remove yumaworks warning */
    (void)newval_val;/* pgr0060 */ /* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
        case OP_EDITOP_DELETE:
            /* Edit NGのためError応答 */
            res = ERR_NCX_OPERATION_NOT_SUPPORTED;
            /* error log */
            if(LOGWARN) {
                log_warn("\n%s: operation is not supported. cbtype=%d", __func__, cbtyp);
            }
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    return res;

} /* u_ietf_hardware_hardware_component_class_edit */


#ifdef u_ietf_hardware_F_entity_mib
/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_physical_index_get
*
* Get database object callback for leaf physical-index
* Path: /hardware/component/physical-index
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_physical_index_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    int32 v_physical_index = 0;
    xmlChar *physical_index;

    /* physical-indexを取得 */
    res = i_ietf_hardware_hardware_component_physical_index_get(k_hardware_component_name, &physical_index);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: physical_index get failed. res=%d", __func__, res);
        }
        return res;
    }
    v_physical_index = atoi((const char*)physical_index);



    /* add physical_index to get2cb return_valQ */
    val_value_t *return_val = agt_make_int_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_physical_index,
        v_physical_index,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_physical_index_get */

#endif /* u_ietf_hardware_F_entity_mib */
/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_description_get
*
* Get database object callback for leaf description
* Path: /hardware/component/description
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_description_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    xmlChar *description;
    /* descriptionを取得 */
    res = i_ietf_hardware_hardware_component_description_get(k_hardware_component_name, &description);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: description get failed. res=%d", __func__, res);
        }
        return res;
    }
    const xmlChar *v_description = (const xmlChar *)description;

    /* add description to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_description,
        v_description,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_description_get */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_parent_edit
*
* Edit database object callback
* Path: /hardware/component/parent
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_parent_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_STRING(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_STRING(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)k_hardware_component_name;/* remove yumaworks warning */
    (void)newval_val;/* pgr0060 */ /* remove yumaworks warning */
    (void)curval_val;/* pgr0060 */ /* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_component_parent_edit */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_parent_rel_pos_edit
*
* Edit database object callback
* Path: /hardware/component/parent-rel-pos
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_parent_rel_pos_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    int32 newval_val = (newval) ? VAL_INT(newval) : 0;
    int32 curval_val = (curval) ? VAL_INT(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)k_hardware_component_name;/* remove yumaworks warning */
    (void)newval_val;/* remove yumaworks warning */
    (void)curval_val;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_component_parent_rel_pos_edit */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_contains_child_get
*
* Get database object callback for leaf-list contains-child
* Path: /hardware/component/contains-child
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_contains_child_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_hardware_component_name;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    (void)obj;/* remove yumaworks warning */
    status_t res = NO_ERR;

    /* get all the instances of this leaf-list  and add a val_value_t
     * for each one with the getcb_add_return_val function */

    return res;

} /* u_ietf_hardware_hardware_component_contains_child_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_hardware_rev_get
*
* Get database object callback for leaf hardware-rev
* Path: /hardware/component/hardware-rev
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_hardware_rev_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    if ((!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport0)) ||
        (!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport1)) ) {
        /* class != O-RAN-RADIOの場合error */
        if(LOGINFO) {
            log_info("\n%s: non-O-RAN-RADIO is not supported. name:%s", __func__, k_hardware_component_name);
        }
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }

    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_GET送信 */
    res = i_ietf_hardware_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n MSI is NG");
        }
        return res;
    }

    const xmlChar *v_hardware_rev = (const xmlChar *)cfm->msi_ietf_component.hardware_rev;

    /* add hardware_rev to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_hardware_rev,
        v_hardware_rev,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_hardware_rev_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_firmware_rev_get
*
* Get database object callback for leaf firmware-rev
* Path: /hardware/component/firmware-rev
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_firmware_rev_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_hardware_component_name;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    (void)obj;/* remove yumaworks warning */
    status_t res = NO_ERR;

    return res;

} /* u_ietf_hardware_hardware_component_firmware_rev_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_software_rev_get
*
* Get database object callback for leaf software-rev
* Path: /hardware/component/software-rev
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_software_rev_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    if ((!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport0)) ||
        (!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport1)) ) {
        /* class != O-RAN-RADIOの場合error */
        if(LOGINFO) {
            log_info("\n%s: non-O-RAN-RADIO is not supported. name:%s", __func__, k_hardware_component_name);
        }
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }
    const xmlChar *v_software_rev = 0;
    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_GET送信 */
    res = i_ietf_hardware_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }
    char software_rev_str[20] = "";

    /* software_revの文字列変換 */
    snprintf(software_rev_str, sizeof(software_rev_str), "%04x", cfm->msi_ietf_component.software_rev);
    v_software_rev = (const xmlChar *)software_rev_str;

    /* add software_rev to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_software_rev,
        v_software_rev,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_software_rev_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_serial_num_get
*
* Get database object callback for leaf serial-num
* Path: /hardware/component/serial-num
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_serial_num_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    if ((!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport0)) ||
        (!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport1)) ) {
        /* class != O-RAN-RADIOの場合error */
        if(LOGINFO) {
            log_info("\n%s: non-O-RAN-RADIO is not supported. name:%s", __func__, k_hardware_component_name);
        }
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }

    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_GET送信 */
    res = i_ietf_hardware_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    char serial_num_str[20] = "";
    /* serial_numの文字列変換 */
    snprintf(serial_num_str, sizeof(serial_num_str), "%02x%02x%02x%02x",
        cfm->msi_ietf_component.serial_num[0],
        cfm->msi_ietf_component.serial_num[1],
        cfm->msi_ietf_component.serial_num[2],
        cfm->msi_ietf_component.serial_num[3]);

    const xmlChar *v_serial_num = (const xmlChar *)serial_num_str;

    /* add serial_num to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_serial_num,
        v_serial_num,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_serial_num_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_mfg_name_get
*
* Get database object callback for leaf mfg-name
* Path: /hardware/component/mfg-name
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_mfg_name_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    if ((!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport0)) ||
        (!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport1)) ) {
        /* class != O-RAN-RADIOの場合error */
        if(LOGINFO) {
            log_info("\n%s: non-O-RAN-RADIO is not supported. name:%s", __func__, k_hardware_component_name);
        }
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }
    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_GET送信 */
    res = i_ietf_hardware_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    char mfg_name_str[20] = "";
    /* 終端にNULL文字を設定 */
    snprintf(mfg_name_str, sizeof(mfg_name_str), "%.16s", cfm->msi_ietf_component.mfg_name);
    const xmlChar *v_mfg_name = (const xmlChar *)mfg_name_str;

    /* add mfg_name to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_mfg_name,
        v_mfg_name,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_mfg_name_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_model_name_get
*
* Get database object callback for leaf model-name
* Path: /hardware/component/model-name
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_model_name_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    if ((!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport0)) ||
        (!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport1)) ) {
        /* class != O-RAN-RADIOの場合error */
        if(LOGINFO) {
            log_info("\n%s: non-O-RAN-RADIO is not supported. name:%s", __func__, k_hardware_component_name);
        }
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }
    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_GET送信 */
    res = i_ietf_hardware_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    char model_name_str[20] = "";
    /* 終端にNULL文字を設定 */
    snprintf(model_name_str, sizeof(model_name_str), "%.12s", cfm->msi_ietf_component.model_name);
    const xmlChar *v_model_name = (const xmlChar *)model_name_str;

    /* add model_name to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_model_name,
        v_model_name,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_model_name_get */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_alias_edit
*
* Edit database object callback
* Path: /hardware/component/alias
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_alias_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_STRING(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_STRING(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)k_hardware_component_name;/* remove yumaworks warning */
    (void)newval_val;/* pgr0060 */ /* remove yumaworks warning */
    (void)curval_val;/* pgr0060 */ /* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_component_alias_edit */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_asset_id_edit
*
* Edit database object callback
* Path: /hardware/component/asset-id
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_asset_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_STRING(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_STRING(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)k_hardware_component_name;/* remove yumaworks warning */
    (void)newval_val;/* pgr0060 */ /* remove yumaworks warning */
    (void)curval_val;/* pgr0060 */ /* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_component_asset_id_edit */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_is_fru_get
*
* Get database object callback for leaf is-fru
* Path: /hardware/component/is-fru
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_is_fru_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_hardware_component_name;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    (void)obj;/* remove yumaworks warning */
    status_t res = NO_ERR;

    return res;

} /* u_ietf_hardware_hardware_component_is_fru_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_mfg_date_get
*
* Get database object callback for leaf mfg-date
* Path: /hardware/component/mfg-date
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_mfg_date_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* get the real value from the system somehow */
    if ((!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport0)) ||
        (!xml_strcmp(k_hardware_component_name, i_ietf_hardware_N_name_fhport1)) ) {
        /* class != O-RAN-RADIOの場合error */
        if(LOGINFO) {
            log_info("\n%s: non-O-RAN-RADIO is not supported. name:%s", __func__, k_hardware_component_name);
        }
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }

    char mfg_date_str[D_UTC_STRING_NUM_MAX] = "";
    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_GET送信 */
    res = i_ietf_hardware_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    /* mfg_dataの文字列変換 */
    /* yyyy-mm-ddThh:mm:ss.0000+00:00 */
    int rc = D_SYS_OK;
    rc = f_saa_com_utc_to_offset_string(
        cfm->msi_ietf_component.mfg_date.year,
        cfm->msi_ietf_component.mfg_date.month,
        cfm->msi_ietf_component.mfg_date.day,
        cfm->msi_ietf_component.mfg_date.hour,
        cfm->msi_ietf_component.mfg_date.min,
        cfm->msi_ietf_component.mfg_date.sec,
        mfg_date_str);

    if(rc != D_SYS_OK)
    {
        if(LOGWARN) {
            log_warn("\n%s: f_saa_com_utc_to_offset_string() failed.", __func__);
        }
        res = ERR_NCX_OPERATION_FAILED;
        return res;
    }

    const xmlChar *v_mfg_date = (const xmlChar *)mfg_date_str;
    if (LOGDEV1) {
        log_dev1("\n%s:v_mfg_date=%s", __func__, v_mfg_date);
    }

    /* add mfg_date to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_mfg_date,
        v_mfg_date,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_mfg_date_get */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_uri_edit
*
* Edit database object callback
* Path: /hardware/component/uri
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_uri_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_STRING(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_STRING(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)k_hardware_component_name;/* remove yumaworks warning */
    (void)newval_val;/* pgr0060 */ /* remove yumaworks warning */
    (void)curval_val;/* pgr0060 */ /* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_component_uri_edit */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_uuid_get
*
* Get database object callback for leaf uuid
* Path: /hardware/component/uuid
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_uuid_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s", __func__);
    }
    (void)k_hardware_component_name;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    (void)obj;/* remove yumaworks warning */
    status_t res = NO_ERR;

    return res;

} /* u_ietf_hardware_hardware_component_uuid_get */


#ifdef u_ietf_hardware_F_hardware_state
/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_state_state_last_changed_get
*
* Get database object callback for leaf state-last-changed
* Path: /hardware/component/state/state-last-changed
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_state_state_last_changed_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* lock */
    pthread_mutex_lock(&mutex_for_hardware_name);

    if (xml_strcmp(k_hardware_component_name, ietf_hardware_state.hardware_name)) {
        if(LOGINFO) {
            log_info("\n%s: operation is not supported. name : %s", __func__, k_hardware_component_name);
        }
        /* unlock */
        pthread_mutex_unlock(&mutex_for_hardware_name);
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }

    /* unlock */
    pthread_mutex_unlock(&mutex_for_hardware_name);

    /* get the real value from the system somehow */
    char last_changed_str[D_UTC_STRING_NUM_MAX] = "";
    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_STATE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_STATE_GET送信 */
    res = i_ietf_hardware_state_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    /* last_changedの文字列変換 */
    /* yyyy-mm-ddThh:mm:ss.0000+00:00 */
    int rc = D_SYS_OK;
    rc = f_saa_com_utc_to_offset_string(
        cfm->msi_ietf_state_t.last_changed.year,
        cfm->msi_ietf_state_t.last_changed.month,
        cfm->msi_ietf_state_t.last_changed.day,
        cfm->msi_ietf_state_t.last_changed.hour,
        cfm->msi_ietf_state_t.last_changed.min,
        cfm->msi_ietf_state_t.last_changed.sec,
        last_changed_str);
    if(rc != D_SYS_OK)
    {
        if(LOGWARN) {
            log_warn("\n%s: f_saa_com_utc_to_offset_string() failed.", __func__);
        }
        res = ERR_NCX_OPERATION_FAILED;
        return res;
    }

    const xmlChar *v_state_last_changed = (const xmlChar *)last_changed_str;
    if (LOGDEV1) {
        log_dev1("\n%s:v_state_last_changed:%s", __func__, v_state_last_changed);
    }

    /* add state_last_changed to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_state_last_changed,
        v_state_last_changed,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_state_state_last_changed_get */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_state_admin_state_edit
*
* Edit database object callback
* Path: /hardware/component/state/admin-state
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_state_admin_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    const xmlChar *newval_val = (newval) ? VAL_ENUM_NAME(newval) : 0;
    const xmlChar *curval_val = (curval) ? VAL_ENUM_NAME(curval) : 0;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)curval_val;/* pgr0060 */ /* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    /* lock */
    pthread_mutex_lock(&mutex_for_hardware_name);

    if (xml_strcmp(k_hardware_component_name, ietf_hardware_state.hardware_name)) {
        if(LOGINFO) {
            log_info("\n%s: operation is not supported. name : %s", __func__, k_hardware_component_name);
        }
        /* unlock */
        pthread_mutex_unlock(&mutex_for_hardware_name);
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }

    /* unlock */
    pthread_mutex_unlock(&mutex_for_hardware_name);

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            res = i_ietf_hardware_admin_state_edit(newval_val);
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_component_state_admin_state_edit */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_state_oper_state_get
*
* Get database object callback for leaf oper-state
* Path: /hardware/component/state/oper-state
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_state_oper_state_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* lock */
    pthread_mutex_lock(&mutex_for_hardware_name);

    if (xml_strcmp(k_hardware_component_name, ietf_hardware_state.hardware_name)) {
        if(LOGINFO) {
            log_info("\n%s: operation is not supported. name : %s", __func__, k_hardware_component_name);
        }
        /* unlock */
        pthread_mutex_unlock(&mutex_for_hardware_name);
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }

    /* unlock */
    pthread_mutex_unlock(&mutex_for_hardware_name);

    /* get the real value from the system somehow */
    xmlChar *oper_state = 0;
    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_STATE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_STATE_GET送信 */
    res = i_ietf_hardware_state_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    /* admin_state文字列変換 */
    switch(cfm->msi_ietf_state_t.oper_state)
    {
    case E_MPSW_OPER_STATE_UNKNOWN:
        oper_state = (xmlChar *)ietf_hardware_oper_state_unknown;
        break;
    case E_MPSW_OPER_STATE_DISABLED:
        oper_state = (xmlChar *)ietf_hardware_oper_state_disabled;
        break;
    case E_MPSW_OPER_STATE_ENABLED:
        oper_state = (xmlChar *)ietf_hardware_oper_state_enabled;
        break;
    case E_MPSW_OPER_STATE_TESTING:
        oper_state = (xmlChar *)ietf_hardware_oper_state_testing;
        break;
    default:
        /* error */
        res = ERR_NCX_DATA_MISSING;
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s wrong state. oper_state=%d", __func__, cfm->msi_ietf_state_t.oper_state);
        }
        return res;
    }

    const xmlChar *v_oper_state = (const xmlChar *)oper_state;

    /* add oper_state to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_oper_state,
        v_oper_state,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_state_oper_state_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_state_usage_state_get
*
* Get database object callback for leaf usage-state
* Path: /hardware/component/state/usage-state
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_state_usage_state_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* lock */
    pthread_mutex_lock(&mutex_for_hardware_name);

    if (xml_strcmp(k_hardware_component_name, ietf_hardware_state.hardware_name)) {
        if(LOGINFO) {
            log_info("\n%s: operation is not supported. name : %s", __func__, k_hardware_component_name);
        }
        /* unlock */
        pthread_mutex_unlock(&mutex_for_hardware_name);
        res = ERR_NCX_NO_INSTANCE;
        return res;
    }

    /* unlock */
    pthread_mutex_unlock(&mutex_for_hardware_name);

    /* get the real value from the system somehow */
    xmlChar *usage_state = 0;
    char buffer[max(sizeof(T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM), sizeof(T_MPSW_MSI_IETF_HARDWARE_STATE_GET_REJ))];
    T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM *cfm = NULL;

    memset(buffer, 0, sizeof(buffer));
    cfm = (T_MPSW_MSI_IETF_HARDWARE_STATE_GET_CFM *)buffer;

    /* MSI_IETF_HARDWARE_STATE_GET送信 */
    res = i_ietf_hardware_state_send_msi(&buffer);
    if(res != NO_ERR)
    {
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s MSI failed. res=%d", __func__, res);
        }
        return res;
    }

    /* usage_state文字列変換 */
    switch(cfm->msi_ietf_state_t.usage_state)
    {
    case E_MPSW_USAGE_STATE_UNKNOWN:
        usage_state = (xmlChar *)ietf_hardware_usage_state_unknown;
        break;
    case E_MPSW_USAGE_STATE_IDLE:
        usage_state = (xmlChar *)ietf_hardware_usage_state_idle;
        break;
    case E_MPSW_USAGE_STATE_ACTIVE:
        usage_state = (xmlChar *)ietf_hardware_usage_state_active;
        break;
    case E_MPSW_USAGE_STATE_BUSY:
        usage_state = (xmlChar *)ietf_hardware_usage_state_busy;
        break;
    default:
        /* error */
        res = ERR_NCX_DATA_MISSING;
        /* error log */
        if(LOGWARN) {
            log_warn("\n%s: wrong state. usage_state=%d", __func__, cfm->msi_ietf_state_t.usage_state);
        }
        return res;
    }

    const xmlChar *v_usage_state = (const xmlChar *)usage_state;

    /* add usage_state to get2cb return_valQ */
    val_value_t *return_val = agt_make_leaf2(
        obj,
        y_ietf_hardware_M_ietf_hardware,
        y_ietf_hardware_N_usage_state,
        v_usage_state,
        &res);
    if (return_val) {
        getcb_add_return_val(get2cb, return_val);
    }

    return res;

} /* u_ietf_hardware_hardware_component_state_usage_state_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_state_alarm_state_get
*
* Get database object callback for leaf alarm-state
* Path: /hardware/component/state/alarm-state
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_state_alarm_state_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_hardware_component_name;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    (void)obj;/* remove yumaworks warning */
    status_t res = NO_ERR;

    return res;

} /* u_ietf_hardware_hardware_component_state_alarm_state_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_state_standby_state_get
*
* Get database object callback for leaf standby-state
* Path: /hardware/component/state/standby-state
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_state_standby_state_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_hardware_component_name;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* check if the requested node exists; determined by the
     * SIL or SIL-SA callback based on instances in the system  */
    boolean node_exists = TRUE;

    if (!node_exists) {
        return ERR_NCX_NO_INSTANCE;
    }

    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    (void)obj;/* remove yumaworks warning */
    status_t res = NO_ERR;

    return res;

} /* u_ietf_hardware_hardware_component_state_standby_state_get */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_state_edit
*
* Edit database object callback
* Path: /hardware/component/state
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)k_hardware_component_name;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_component_state_edit */
#endif /* u_ietf_hardware_F_hardware_state */

#ifdef u_ietf_hardware_F_hardware_sensor
/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_sensor_data_get
*
* Get database object callback for container sensor-data
* Path: /hardware/component/sensor-data
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_sensor_data_get (
    getcb_get2_t *get2cb,
    const xmlChar *k_hardware_component_name)
{
    if (LOGINFO) {
        log_info("\nEnter %s:", __func__);
    }
    (void)k_hardware_component_name;/* remove yumaworks warning */

    /* check the callback mode type */
    getcb_mode_t cbmode = GETCB_GET2_CBMODE(get2cb);
    switch (cbmode) {
    case GETCB_GET_VALUE:
        break;
    case GETCB_GETNEXT_VALUE:
        return ERR_NCX_NO_INSTANCE;
    default:
        return SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* an NP container always exists so no test for node_exists
     * by the SIL or SIL-SA callback is needed */
    obj_template_t *obj = GETCB_GET2_OBJ(get2cb);
    status_t res = NO_ERR;

    /* optional: check if any content-match nodes are present */
    boolean match_test_done = FALSE;
    val_value_t *match_val = GETCB_GET2_FIRST_MATCH(get2cb);
    for (; match_val; match_val =
        GETCB_GET2_NEXT_MATCH(get2cb, match_val)) {

        /**** CHECK CONTENT NODES AGAINST THIS ENTRY ***/

    }
    GETCB_GET2_MATCH_TEST_DONE(get2cb) = match_test_done;

    /* go through all the requested terminal child objects */
    obj_template_t *childobj =
        getcb_first_requested_child(get2cb, obj);
    for (; childobj; childobj =
        getcb_next_requested_child(get2cb, childobj)) {

        const xmlChar *name = obj_get_name(childobj);

        /* Retrieve the value of this terminal node and 
         * add with getcb_add_return_val */

        if (!xml_strcmp(name, y_ietf_hardware_N_value)) {
            /* leaf value (int32) */

        } else if (!xml_strcmp(name, y_ietf_hardware_N_value_type)) {
            /* leaf value-type (enumeration) */

        } else if (!xml_strcmp(name, y_ietf_hardware_N_value_scale)) {
            /* leaf value-scale (enumeration) */

        } else if (!xml_strcmp(name, y_ietf_hardware_N_value_precision)) {
            /* leaf value-precision (int8) */

        } else if (!xml_strcmp(name, y_ietf_hardware_N_oper_status)) {
            /* leaf oper-status (enumeration) */

        } else if (!xml_strcmp(name, y_ietf_hardware_N_units_display)) {
            /* leaf units-display (string) */

        } else if (!xml_strcmp(name, y_ietf_hardware_N_value_timestamp)) {
            /* leaf value-timestamp (string) */

        } else if (!xml_strcmp(name, y_ietf_hardware_N_value_update_rate)) {
            /* leaf value-update-rate (uint32) */

        }
    }

    return res;

} /* u_ietf_hardware_hardware_component_sensor_data_get */

#endif /* u_ietf_hardware_F_hardware_sensor */

/********************************************************************
* FUNCTION u_ietf_hardware_hardware_component_edit
*
* Edit database object callback
* Path: /hardware/component
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*     k_ parameters are ancestor list key values.
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_component_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval,
    const xmlChar *k_hardware_component_name)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)k_hardware_component_name;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_component_edit */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_edit
*
* Edit database object callback
* Path: /hardware
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_hardware_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    (void)scb;/* remove yumaworks warning */
    (void)msg;/* remove yumaworks warning */
    (void)newval;/* remove yumaworks warning */
    (void)curval;/* remove yumaworks warning */

    if (LOGINFO) {
        log_info("\nEnter %s: phase=%s", __func__, agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }
    return res;

} /* u_ietf_hardware_hardware_edit */


/********************************************************************
* FUNCTION u_ietf_hardware_hardware_state_change_send
*
* Send a u_ietf_hardware_hardware_state_change notification
* Called by your code when notification event occurs
*
********************************************************************/
void u_ietf_hardware_hardware_state_change_send (void)
{
    if (LOGINFO) {
        log_info("\nEnter u_ietf_hardware_hardware_state_change_send");
    }

    if (!agt_notifications_enabled()) {
        log_debug2("\nSkipping <hardware-state-change> notification; disabled");
        return;
    }
    
    if (LOGDEBUG) {
        log_debug("\nGenerating <hardware-state-change> notification");
    }
    
    agt_not_msg_t *notif = agt_not_new_notification(hardware_state_change_obj);
    if (notif == NULL) {
        log_error("\nError: malloc failed, cannot send "
        "<hardware-state-change> notification");
        return;
    }
    
    sil_sa_queue_notification(notif);
    
} /* u_ietf_hardware_hardware_state_change_send */


#ifdef u_ietf_hardware_F_hardware_state
/********************************************************************
* FUNCTION u_ietf_hardware_hardware_state_oper_enabled_send
*
* Send a u_ietf_hardware_hardware_state_oper_enabled notification
* Called by your code when notification event occurs
*
********************************************************************/
void u_ietf_hardware_hardware_state_oper_enabled_send (
    const xmlChar *v_name,
    const xmlChar *v_admin_state,
    const xmlChar *v_alarm_state,
    const xmlChar *o_ran_hardware_availability_state)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;
    (void)v_alarm_state/* remove yumaworks warning */;

    if (LOGINFO) {
        log_info("\nEnter u_ietf_hardware_hardware_state_oper_enabled_send");
    }

    if (ncx_feature_enabled_str(
        y_ietf_hardware_M_ietf_hardware, 
        y_ietf_hardware_R_ietf_hardware,
        (const xmlChar *)"hardware-state")) {
        if (!agt_notifications_enabled()) {
            log_debug2("\nSkipping <hardware-state-oper-enabled> notification; disabled");
            return;
        }
        
        if (LOGDEBUG) {
            log_debug("\nGenerating <hardware-state-oper-enabled> notification");
        }
        
    agt_not_msg_t *notif = agt_not_new_notification(hardware_state_oper_enabled_obj);
        if (notif == NULL) {
            log_error("\nError: malloc failed, cannot send "
            "<hardware-state-oper-enabled> notification");
            return;
        }
        
        /* add name to payload */
        parmval = agt_make_leaf2(
            hardware_state_oper_enabled_obj,
            y_ietf_hardware_M_ietf_hardware,
            y_ietf_hardware_N_name,
            v_name,
            &res);
        if (parmval == NULL) {
            log_error(
                "\nError: make leaf failed (%s), cannot send "
                "<hardware-state-oper-enabled> notification",
                get_error_string(res));
        } else {
            agt_not_add_to_payload(notif, parmval);
        }
        
        /* add admin_state to payload */
        parmval = agt_make_leaf2(
            hardware_state_oper_enabled_obj,
            y_ietf_hardware_M_ietf_hardware,
            y_ietf_hardware_N_admin_state,
            v_admin_state,
            &res);
        if (parmval == NULL) {
            log_error(
                "\nError: make leaf failed (%s), cannot send "
                "<hardware-state-oper-enabled> notification",
                get_error_string(res));
        } else {
            agt_not_add_to_payload(notif, parmval);
        }

        /* add availability_state to payload */
        parmval = agt_make_leaf2(
            hardware_state_oper_enabled_obj,
            y_o_ran_hardware_M_o_ran_hardware,
            y_o_ran_hardware_N_availability_state,
            o_ran_hardware_availability_state,
            &res);
        if (parmval == NULL) {
            log_error(
                "\nError: make leaf failed (%s), cannot send "
                "<hardware-state-oper-enabled> notification",
                get_error_string(res));
        } else {
            agt_not_add_to_payload(notif, parmval);
        }
        
        sil_sa_queue_notification(notif);
        
    } /* u_ietf_hardware_F_hardware_state */
} /* u_ietf_hardware_hardware_state_oper_enabled_send */
#endif /* u_ietf_hardware_F_hardware_state */

#ifdef u_ietf_hardware_F_hardware_state
/********************************************************************
* FUNCTION u_ietf_hardware_hardware_state_oper_disabled_send
*
* Send a u_ietf_hardware_hardware_state_oper_disabled notification
* Called by your code when notification event occurs
*
********************************************************************/
void u_ietf_hardware_hardware_state_oper_disabled_send (
    const xmlChar *v_name,
    const xmlChar *v_admin_state,
    const xmlChar *v_alarm_state,
    const xmlChar *o_ran_hardware_availability_state)
{
    val_value_t *parmval = NULL;
    status_t res = NO_ERR;
    (void)v_alarm_state/* remove yumaworks warning */;

    if (LOGINFO) {
        log_info("\nEnter u_ietf_hardware_hardware_state_oper_disabled_send");
    }

    if (ncx_feature_enabled_str(
        y_ietf_hardware_M_ietf_hardware, 
        y_ietf_hardware_R_ietf_hardware,
        (const xmlChar *)"hardware-state")) {
        if (!agt_notifications_enabled()) {
            log_debug2("\nSkipping <hardware-state-oper-disabled> notification; disabled");
            return;
        }
        
        if (LOGDEBUG) {
            log_debug("\nGenerating <hardware-state-oper-disabled> notification");
        }
        
    agt_not_msg_t *notif = agt_not_new_notification(hardware_state_oper_disabled_obj);
        if (notif == NULL) {
            log_error("\nError: malloc failed, cannot send "
            "<hardware-state-oper-disabled> notification");
            return;
        }
        
        /* add name to payload */
        parmval = agt_make_leaf2(
            hardware_state_oper_disabled_obj,
            y_ietf_hardware_M_ietf_hardware,
            y_ietf_hardware_N_name,
            v_name,
            &res);
        if (parmval == NULL) {
            log_error(
                "\nError: make leaf failed (%s), cannot send "
                "<hardware-state-oper-disabled> notification",
                get_error_string(res));
        } else {
            agt_not_add_to_payload(notif, parmval);
        }
        
        /* add admin_state to payload */
        parmval = agt_make_leaf2(
            hardware_state_oper_disabled_obj,
            y_ietf_hardware_M_ietf_hardware,
            y_ietf_hardware_N_admin_state,
            v_admin_state,
            &res);
        if (parmval == NULL) {
            log_error(
                "\nError: make leaf failed (%s), cannot send "
                "<hardware-state-oper-disabled> notification",
                get_error_string(res));
        } else {
            agt_not_add_to_payload(notif, parmval);
        }

        /* add availability_state to payload */
        parmval = agt_make_leaf2(
            hardware_state_oper_disabled_obj,
            y_o_ran_hardware_M_o_ran_hardware,
            y_o_ran_hardware_N_availability_state,
            o_ran_hardware_availability_state,
            &res);
        if (parmval == NULL) {
            log_error(
                "\nError: make leaf failed (%s), cannot send "
                "<hardware-state-oper-disabled> notification",
                get_error_string(res));
        } else {
            agt_not_add_to_payload(notif, parmval);
        }
        
        sil_sa_queue_notification(notif);
        
    } /* u_ietf_hardware_F_hardware_state */
} /* u_ietf_hardware_hardware_state_oper_disabled_send */
#endif /* u_ietf_hardware_F_hardware_state */
/********************************************************************
* FUNCTION u_ietf_hardware_init
*
* initialize the ietf-hardware server instrumentation library
*
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    ncx_module_t *ietf_hardware_mod = NULL;

    if (LOGINFO) {
        log_info("\nEnter u_ietf_hardware_init");
    }

    ietf_hardware_mod = ncx_find_module(modname, revision);
    if (ietf_hardware_mod == NULL) {
        return ERR_NCX_OPERATION_FAILED;
    }

    hardware_state_change_obj = ncx_find_object(
        ietf_hardware_mod,
        y_ietf_hardware_N_hardware_state_change);
    if (hardware_state_change_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }


#ifdef u_ietf_hardware_F_hardware_state
    if (ncx_feature_enabled_str(
        y_ietf_hardware_M_ietf_hardware, 
        y_ietf_hardware_R_ietf_hardware,
        (const xmlChar *)"hardware-state")) {
        hardware_state_oper_enabled_obj = ncx_find_object(
            ietf_hardware_mod,
            y_ietf_hardware_N_hardware_state_oper_enabled);
        if (hardware_state_oper_enabled_obj == NULL) {
            return ERR_NCX_DEF_NOT_FOUND;
        }
    } /* u_ietf_hardware_F_hardware_state */
#endif /* u_ietf_hardware_F_hardware_state */


#ifdef u_ietf_hardware_F_hardware_state
    if (ncx_feature_enabled_str(
        y_ietf_hardware_M_ietf_hardware, 
        y_ietf_hardware_R_ietf_hardware,
        (const xmlChar *)"hardware-state")) {
        hardware_state_oper_disabled_obj = ncx_find_object(
            ietf_hardware_mod,
            y_ietf_hardware_N_hardware_state_oper_disabled);
        if (hardware_state_oper_disabled_obj == NULL) {
            return ERR_NCX_DEF_NOT_FOUND;
        }
    } /* u_ietf_hardware_F_hardware_state */
#endif /* u_ietf_hardware_F_hardware_state */

    /* put your module initialization code here */
    /* 初期化 */
    i_ietf_hardware_init();
    return res;

} /* u_ietf_hardware_init */

/********************************************************************
* FUNCTION u_ietf_hardware_init2
*
* SIL init phase 2: non-config data structures
* Called after running config is loaded
*
* RETURNS:
*     error status
********************************************************************/
status_t u_ietf_hardware_init2 (void)
{
    status_t res = NO_ERR;

    if (LOGINFO) {
        log_info("\nEnter u_ietf_hardware_init2");
    }

    /* put your init2 code here */
    i_ietf_hardware_init2();

    return res;

} /* u_ietf_hardware_init2 */

/********************************************************************
* FUNCTION u_ietf_hardware_cleanup
*    cleanup the server instrumentation library
*
********************************************************************/
void u_ietf_hardware_cleanup (void)
{
    if (LOGINFO) {
        log_info("\nEnter u_ietf_hardware_cleanup");
    }

    /* put your cleanup code here */
    
} /* u_ietf_hardware_cleanup */

/* END SIL-SA u_ietf_hardware.c */
