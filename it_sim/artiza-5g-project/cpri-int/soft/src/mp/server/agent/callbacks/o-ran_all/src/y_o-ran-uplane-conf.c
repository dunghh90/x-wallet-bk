
/*
 * Copyright (c) 2008 - 2012, Andy Bierman, All Rights Reserved.
 * Copyright (c) 2012 - 2019, YumaWorks, Inc., All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump-sdk 18.10-15

    YumaPro SIL-SA module
    bundle o-ran_all
    module o-ran-uplane-conf
    revision 2019-02-04
    namespace urn:o-ran:uplane-conf:1.0
    organization O-RAN Alliance
    Created: 2019-12-20T02:20:31Z
    CLI parameters:
        defnames true
        format yc
        indent 4
        module ietf-yang-types
        module ietf-inet-types
        module ietf-interfaces
        module iana-if-type
        module ietf-ip
        module iana-hardware
        module ietf-hardware
        module ietf-netconf-acm
        module o-ran-hardware
        module o-ran-software-management
        module o-ran-interfaces
        module o-ran-transceiver
        module o-ran-mplane-int
        module o-ran-dhcp
        module o-ran-compression-factors
        module o-ran-uplane-conf
        module o-ran-module-cap
        module o-ran-processing-element
        module o-ran-performance-management
        module o-ran-fm
        module o-ran-lbm
        module o-ran-supervision
        module o-ran-beamforming
        module o-ran-operations
        module o-ran-usermgmt
        module o-ran-sync
        sil-bundle o-ran_all
        sil-get2
        sil-sa
        unified true

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_action.h"
#include "agt_cb.h"
#include "agt_not.h"
#include "agt_rpc.h"
#include "agt_sil_lib.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "agt_val.h"
#include "cfg.h"
#include "dlq.h"
#include "getcb.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "obj.h"
#include "rpc.h"
#include "ses.h"
#include "sil_sa.h"
#include "status.h"
#include "val.h"
#include "val_child.h"
#include "val_util.h"
#include "xml_util.h"
#include "xml_val.h"

/* SIL bundle: o-ran_all */
#include "y_ietf-yang-types.h"
#include "u_ietf-yang-types.h"
#include "y_ietf-inet-types.h"
#include "u_ietf-inet-types.h"
#include "y_ietf-interfaces.h"
#include "u_ietf-interfaces.h"
#include "y_iana-if-type.h"
#include "u_iana-if-type.h"
#include "y_ietf-ip.h"
#include "u_ietf-ip.h"
#include "y_iana-hardware.h"
#include "u_iana-hardware.h"
#include "y_ietf-hardware.h"
#include "u_ietf-hardware.h"
#include "y_ietf-netconf-acm.h"
#include "u_ietf-netconf-acm.h"
#include "y_o-ran-hardware.h"
#include "u_o-ran-hardware.h"
#include "y_o-ran-software-management.h"
#include "u_o-ran-software-management.h"
#include "y_o-ran-interfaces.h"
#include "u_o-ran-interfaces.h"
#include "y_o-ran-transceiver.h"
#include "u_o-ran-transceiver.h"
#include "y_o-ran-mplane-int.h"
#include "u_o-ran-mplane-int.h"
#include "y_o-ran-dhcp.h"
#include "u_o-ran-dhcp.h"
#include "y_o-ran-compression-factors.h"
#include "u_o-ran-compression-factors.h"
#include "y_o-ran-uplane-conf.h"
#include "u_o-ran-uplane-conf.h"
#include "y_o-ran-module-cap.h"
#include "u_o-ran-module-cap.h"
#include "y_o-ran-processing-element.h"
#include "u_o-ran-processing-element.h"
#include "y_o-ran-performance-management.h"
#include "u_o-ran-performance-management.h"
#include "y_o-ran-fm.h"
#include "u_o-ran-fm.h"
#include "y_o-ran-lbm.h"
#include "u_o-ran-lbm.h"
#include "y_o-ran-supervision.h"
#include "u_o-ran-supervision.h"
#include "y_o-ran-beamforming.h"
#include "u_o-ran-beamforming.h"
#include "y_o-ran-operations.h"
#include "u_o-ran-operations.h"
#include "y_o-ran-usermgmt.h"
#include "u_o-ran-usermgmt.h"
#include "y_o-ran-sync.h"
#include "u_o-ran-sync.h"

/* module static variables */
static ncx_module_t *o_ran_uplane_conf_mod;
static obj_template_t *user_plane_configuration_obj;
static val_value_t *user_plane_configuration_val;

/********************************************************************
* FUNCTION y_o_ran_uplane_conf_init_static_vars
*
* initialize module static variables
*
********************************************************************/
static void y_o_ran_uplane_conf_init_static_vars (void)
{
    o_ran_uplane_conf_mod = NULL;
    user_plane_configuration_obj = NULL;
    user_plane_configuration_val = NULL;

} /* y_o_ran_uplane_conf_init_static_vars */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_processing_element_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-links/processing-element
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_processing_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_processing_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_processing_element_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_processing_element_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_tx_array_carrier_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-links/tx-array-carrier
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_tx_array_carrier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_tx_array_carrier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_tx_array_carrier_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_tx_array_carrier_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_low_level_tx_endpoint_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-links/low-level-tx-endpoint
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_low_level_tx_endpoint_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_low_level_tx_endpoint_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_low_level_tx_endpoint_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_low_level_tx_endpoint_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-links
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_processing_element_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-links/processing-element
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_processing_element_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_processing_element_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_processing_element_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_processing_element_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_rx_array_carrier_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-links/rx-array-carrier
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_rx_array_carrier_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_rx_array_carrier_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_rx_array_carrier_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_rx_array_carrier_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_low_level_rx_endpoint_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-links/low-level-rx-endpoint
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_low_level_rx_endpoint_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_low_level_rx_endpoint_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_low_level_rx_endpoint_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_low_level_rx_endpoint_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_user_plane_uplink_marking_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-links/user-plane-uplink-marking
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_user_plane_uplink_marking_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_user_plane_uplink_marking_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_user_plane_uplink_marking_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_user_plane_uplink_marking_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-links
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_links_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_links_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_edit */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_endpoint_types_supported_section_types_get
*
* Get database object callback for list supported-section-types
* Path: /user-plane-configuration/endpoint-types/supported-section-types
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_endpoint_types_supported_section_types_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:id */
    uint16 k_user_plane_configuration_endpoint_types_id = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_id);
    if (keyval) {
        k_user_plane_configuration_endpoint_types_id = VAL_UINT16(keyval);
    }

    /* local key o-ran-uplane-conf:section-type */
    uint8 k_user_plane_configuration_endpoint_types_supported_section_types_section_type = 0;
    boolean section_type_fixed = FALSE;
    boolean section_type_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_section_type);
    if (keyval) {
        k_user_plane_configuration_endpoint_types_supported_section_types_section_type = VAL_UINT8(keyval);
        section_type_fixed = VAL_IS_FIXED_VALUE(keyval);
        section_type_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_endpoint_types_supported_section_types_get(
        get2cb,
        k_user_plane_configuration_endpoint_types_id,
        k_user_plane_configuration_endpoint_types_supported_section_types_section_type,
        section_type_fixed,
        section_type_present);

} /* o_ran_uplane_conf_user_plane_configuration_endpoint_types_supported_section_types_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_endpoint_types_get
*
* Get database object callback for list endpoint-types
* Path: /user-plane-configuration/endpoint-types
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_endpoint_types_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* local key o-ran-uplane-conf:id */
    uint16 k_user_plane_configuration_endpoint_types_id = 0;
    boolean id_fixed = FALSE;
    boolean id_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_id);
    if (keyval) {
        k_user_plane_configuration_endpoint_types_id = VAL_UINT16(keyval);
        id_fixed = VAL_IS_FIXED_VALUE(keyval);
        id_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_endpoint_types_get(
        get2cb,
        k_user_plane_configuration_endpoint_types_id,
        id_fixed,
        id_present);

} /* o_ran_uplane_conf_user_plane_configuration_endpoint_types_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_endpoint_capacity_sharing_groups_get
*
* Get database object callback for list endpoint-capacity-sharing-groups
* Path: /user-plane-configuration/endpoint-capacity-sharing-groups
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_endpoint_capacity_sharing_groups_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* local key o-ran-uplane-conf:id */
    uint16 k_user_plane_configuration_endpoint_capacity_sharing_groups_id = 0;
    boolean id_fixed = FALSE;
    boolean id_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_id);
    if (keyval) {
        k_user_plane_configuration_endpoint_capacity_sharing_groups_id = VAL_UINT16(keyval);
        id_fixed = VAL_IS_FIXED_VALUE(keyval);
        id_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_endpoint_capacity_sharing_groups_get(
        get2cb,
        k_user_plane_configuration_endpoint_capacity_sharing_groups_id,
        id_fixed,
        id_present);

} /* o_ran_uplane_conf_user_plane_configuration_endpoint_capacity_sharing_groups_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_static_low_level_tx_endpoints_get
*
* Get database object callback for list static-low-level-tx-endpoints
* Path: /user-plane-configuration/static-low-level-tx-endpoints
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_static_low_level_tx_endpoints_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_static_low_level_tx_endpoints_name = 0;
    boolean name_fixed = FALSE;
    boolean name_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_static_low_level_tx_endpoints_name = VAL_STRING(keyval);
        name_fixed = VAL_IS_FIXED_VALUE(keyval);
        name_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_static_low_level_tx_endpoints_get(
        get2cb,
        k_user_plane_configuration_static_low_level_tx_endpoints_name,
        name_fixed,
        name_present);

} /* o_ran_uplane_conf_user_plane_configuration_static_low_level_tx_endpoints_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_static_low_level_rx_endpoints_get
*
* Get database object callback for list static-low-level-rx-endpoints
* Path: /user-plane-configuration/static-low-level-rx-endpoints
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_static_low_level_rx_endpoints_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_static_low_level_rx_endpoints_name = 0;
    boolean name_fixed = FALSE;
    boolean name_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_static_low_level_rx_endpoints_name = VAL_STRING(keyval);
        name_fixed = VAL_IS_FIXED_VALUE(keyval);
        name_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_static_low_level_rx_endpoints_get(
        get2cb,
        k_user_plane_configuration_static_low_level_rx_endpoints_name,
        name_fixed,
        name_present);

} /* o_ran_uplane_conf_user_plane_configuration_static_low_level_rx_endpoints_get */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_type_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-type
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_type_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_type_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_bitwidth_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/bitwidth
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_bitwidth_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_bitwidth_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_bitwidth_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_bitwidth_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_floating_point_exponent_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-format/block-floating-point/exponent
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_floating_point_exponent_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_floating_point_exponent_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_floating_point_exponent_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_floating_point_exponent_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_scaling_block_scalar_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-format/block-scaling/block-scalar
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_scaling_block_scalar_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_scaling_block_scalar_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_scaling_block_scalar_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_scaling_block_scalar_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_bit_width_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-format/u-law/comp-bit-width
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_bit_width_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_bit_width_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_bit_width_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_bit_width_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_shift_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-format/u-law/comp-shift
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_shift_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_shift_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_shift_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_shift_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-format/beam-space-compression/active-beam-space-coeficient-mask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-format/beam-space-compression/block-scaler
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_csf_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-format/modulation-compression/csf
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_csf_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_csf_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_csf_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_csf_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression/compression-format/modulation-compression/mod-comp-scaler
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/compression
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_frame_structure_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/frame-structure
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_frame_structure_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_frame_structure_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_frame_structure_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_frame_structure_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_type_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/cp-type
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_type_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_type_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/cp-length
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_other_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/cp-length-other
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_other_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_other_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_other_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_other_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_offset_to_absolute_frequency_center_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/offset-to-absolute-frequency-center
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_offset_to_absolute_frequency_center_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_offset_to_absolute_frequency_center_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_offset_to_absolute_frequency_center_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_offset_to_absolute_frequency_center_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_number_of_prb_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/number-of-prb-per-scs/number-of-prb
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_number_of_prb_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-uplane-conf:scs */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_scs =
        VAL_ENUM_NAME(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_number_of_prb_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_number_of_prb_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name,
        k_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_scs);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_number_of_prb_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/number-of-prb-per-scs
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* local key o-ran-uplane-conf:scs */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_scs =
        VAL_ENUM_NAME(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name,
        k_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_scs);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_o_du_port_bitmask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/e-axcid/o-du-port-bitmask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_o_du_port_bitmask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_o_du_port_bitmask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_o_du_port_bitmask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_o_du_port_bitmask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_band_sector_bitmask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/e-axcid/band-sector-bitmask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_band_sector_bitmask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_band_sector_bitmask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_band_sector_bitmask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_band_sector_bitmask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ccid_bitmask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/e-axcid/ccid-bitmask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ccid_bitmask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ccid_bitmask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ccid_bitmask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ccid_bitmask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ru_port_bitmask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/e-axcid/ru-port-bitmask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ru_port_bitmask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ru_port_bitmask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ru_port_bitmask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ru_port_bitmask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_eaxc_id_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/e-axcid/eaxc-id
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_eaxc_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_eaxc_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_eaxc_id_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_eaxc_id_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints/e-axcid
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-tx-endpoints
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_tx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_tx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_type_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-type
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_type_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_type_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_bitwidth_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/bitwidth
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_bitwidth_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_bitwidth_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_bitwidth_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_bitwidth_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_floating_point_exponent_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-format/block-floating-point/exponent
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_floating_point_exponent_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_floating_point_exponent_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_floating_point_exponent_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_floating_point_exponent_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_scaling_block_scalar_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-format/block-scaling/block-scalar
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_scaling_block_scalar_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_scaling_block_scalar_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_scaling_block_scalar_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_scaling_block_scalar_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_bit_width_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-format/u-law/comp-bit-width
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_bit_width_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_bit_width_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_bit_width_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_bit_width_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_shift_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-format/u-law/comp-shift
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_shift_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_shift_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_shift_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_shift_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-format/beam-space-compression/active-beam-space-coeficient-mask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-format/beam-space-compression/block-scaler
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_csf_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-format/modulation-compression/csf
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_csf_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_csf_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_csf_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_csf_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression/compression-format/modulation-compression/mod-comp-scaler
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/compression
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_frame_structure_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/frame-structure
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_frame_structure_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_frame_structure_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_frame_structure_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_frame_structure_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_type_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/cp-type
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_type_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_type_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/cp-length
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_other_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/cp-length-other
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_other_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_other_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_other_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_other_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_offset_to_absolute_frequency_center_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/offset-to-absolute-frequency-center
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_offset_to_absolute_frequency_center_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_offset_to_absolute_frequency_center_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_offset_to_absolute_frequency_center_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_offset_to_absolute_frequency_center_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_number_of_prb_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/number-of-prb-per-scs/number-of-prb
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_number_of_prb_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-uplane-conf:scs */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_scs =
        VAL_ENUM_NAME(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_number_of_prb_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_number_of_prb_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name,
        k_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_scs);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_number_of_prb_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/number-of-prb-per-scs
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* local key o-ran-uplane-conf:scs */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_scs =
        VAL_ENUM_NAME(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name,
        k_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_scs);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_ul_fft_sampling_offset_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/ul-fft-sampling-offsets/ul-fft-sampling-offset
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_ul_fft_sampling_offset_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-uplane-conf:scs */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_scs =
        VAL_ENUM_NAME(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_ul_fft_sampling_offset_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_ul_fft_sampling_offset_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name,
        k_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_scs);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_ul_fft_sampling_offset_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/ul-fft-sampling-offsets
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* local key o-ran-uplane-conf:scs */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_scs =
        VAL_ENUM_NAME(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name,
        k_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_scs);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_o_du_port_bitmask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/e-axcid/o-du-port-bitmask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_o_du_port_bitmask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_o_du_port_bitmask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_o_du_port_bitmask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_o_du_port_bitmask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_band_sector_bitmask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/e-axcid/band-sector-bitmask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_band_sector_bitmask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_band_sector_bitmask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_band_sector_bitmask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_band_sector_bitmask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ccid_bitmask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/e-axcid/ccid-bitmask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ccid_bitmask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ccid_bitmask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ccid_bitmask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ccid_bitmask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ru_port_bitmask_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/e-axcid/ru-port-bitmask
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ru_port_bitmask_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ru_port_bitmask_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ru_port_bitmask_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ru_port_bitmask_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_eaxc_id_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/e-axcid/eaxc-id
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_eaxc_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_eaxc_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_eaxc_id_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_eaxc_id_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/e-axcid
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_non_time_managed_delay_enabled_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints/non-time-managed-delay-enabled
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_non_time_managed_delay_enabled_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_non_time_managed_delay_enabled_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_non_time_managed_delay_enabled_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_non_time_managed_delay_enabled_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_edit
*
* Edit database object callback
* Path: /user-plane-configuration/low-level-rx-endpoints
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_low_level_rx_endpoints_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_low_level_rx_endpoints_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_absolute_frequency_center_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/absolute-frequency-center
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_absolute_frequency_center_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_absolute_frequency_center_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_absolute_frequency_center_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_absolute_frequency_center_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_center_of_channel_bandwidth_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/center-of-channel-bandwidth
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_center_of_channel_bandwidth_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_center_of_channel_bandwidth_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_center_of_channel_bandwidth_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_center_of_channel_bandwidth_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_channel_bandwidth_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/channel-bandwidth
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_channel_bandwidth_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_channel_bandwidth_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_channel_bandwidth_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_channel_bandwidth_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_active_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/active
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_active_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_active_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_active_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_active_edit */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_state_get
*
* Get database object callback for leaf state
* Path: /user-plane-configuration/tx-array-carriers/state
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_state_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_tx_array_carriers_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_state_get(
        get2cb,
        k_user_plane_configuration_tx_array_carriers_name);

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_state_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_type_get
*
* Get database object callback for leaf type
* Path: /user-plane-configuration/tx-array-carriers/type
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_type_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_tx_array_carriers_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_type_get(
        get2cb,
        k_user_plane_configuration_tx_array_carriers_name);

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_type_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_duplex_scheme_get
*
* Get database object callback for leaf duplex-scheme
* Path: /user-plane-configuration/tx-array-carriers/duplex-scheme
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_duplex_scheme_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_tx_array_carriers_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_duplex_scheme_get(
        get2cb,
        k_user_plane_configuration_tx_array_carriers_name);

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_duplex_scheme_get */


#ifdef u_o_ran_module_cap_F_LAA
/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_band_number_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/band-number
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_band_number_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_band_number_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_band_number_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_band_number_edit */
#endif /* u_o_ran_module_cap_F_LAA */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_subframe_assignment_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/lte-tdd-frame/subframe-assignment
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_subframe_assignment_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_subframe_assignment_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_subframe_assignment_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_subframe_assignment_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_special_subframe_pattern_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/lte-tdd-frame/special-subframe-pattern
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_special_subframe_pattern_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_special_subframe_pattern_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_special_subframe_pattern_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_special_subframe_pattern_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/lte-tdd-frame
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_edit */


#ifdef u_o_ran_module_cap_F_LAA

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_pdsch_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/ed-threshold-pdsch
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_pdsch_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_pdsch_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_pdsch_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_pdsch_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_drs_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/ed-threshold-drs
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_drs_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_drs_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_drs_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_drs_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_tx_antenna_ports_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/tx-antenna-ports
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_tx_antenna_ports_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_tx_antenna_ports_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_tx_antenna_ports_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_tx_antenna_ports_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_transmission_power_for_drs_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/transmission-power-for-drs
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_transmission_power_for_drs_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_transmission_power_for_drs_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_transmission_power_for_drs_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_transmission_power_for_drs_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_period_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/dmtc-period
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_period_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_period_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_period_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_period_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_offset_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/dmtc-offset
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_offset_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_offset_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_offset_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_offset_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_lbt_timer_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/lbt-timer
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_lbt_timer_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_lbt_timer_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_lbt_timer_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_lbt_timer_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_counter_value_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/max-cw-usage-counter/counter-value
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_counter_value_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* ancestor key o-ran-uplane-conf:priority */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_priority =
        VAL_ENUM_NAME(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_counter_value_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_counter_value_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name,
        k_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_priority);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_counter_value_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration/max-cw-usage-counter
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    /* local key o-ran-uplane-conf:priority */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_priority =
        VAL_ENUM_NAME(sil_sa_get_key(msg, 2));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name,
        k_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_priority);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_edit */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/laa-carrier-configuration
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_edit */
#endif /* u_o_ran_module_cap_F_LAA */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_gain_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/gain
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_gain_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_gain_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_gain_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_gain_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_radio_frame_offset_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/downlink-radio-frame-offset
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_radio_frame_offset_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_radio_frame_offset_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_radio_frame_offset_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_radio_frame_offset_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_sfn_offset_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers/downlink-sfn-offset
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_sfn_offset_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_sfn_offset_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_sfn_offset_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_sfn_offset_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_edit
*
* Edit database object callback
* Path: /user-plane-configuration/tx-array-carriers
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_tx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_absolute_frequency_center_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers/absolute-frequency-center
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_absolute_frequency_center_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_absolute_frequency_center_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_absolute_frequency_center_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_absolute_frequency_center_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_center_of_channel_bandwidth_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers/center-of-channel-bandwidth
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_center_of_channel_bandwidth_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_center_of_channel_bandwidth_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_center_of_channel_bandwidth_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_center_of_channel_bandwidth_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_channel_bandwidth_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers/channel-bandwidth
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_channel_bandwidth_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_channel_bandwidth_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_channel_bandwidth_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_channel_bandwidth_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_active_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers/active
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_active_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_active_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_active_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_active_edit */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_state_get
*
* Get database object callback for leaf state
* Path: /user-plane-configuration/rx-array-carriers/state
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_state_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_rx_array_carriers_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_state_get(
        get2cb,
        k_user_plane_configuration_rx_array_carriers_name);

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_state_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_type_get
*
* Get database object callback for leaf type
* Path: /user-plane-configuration/rx-array-carriers/type
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_type_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_rx_array_carriers_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_type_get(
        get2cb,
        k_user_plane_configuration_rx_array_carriers_name);

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_type_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_duplex_scheme_get
*
* Get database object callback for leaf duplex-scheme
* Path: /user-plane-configuration/rx-array-carriers/duplex-scheme
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_duplex_scheme_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_rx_array_carriers_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_duplex_scheme_get(
        get2cb,
        k_user_plane_configuration_rx_array_carriers_name);

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_duplex_scheme_get */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_radio_frame_offset_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers/downlink-radio-frame-offset
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_radio_frame_offset_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_radio_frame_offset_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_radio_frame_offset_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_radio_frame_offset_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_sfn_offset_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers/downlink-sfn-offset
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_sfn_offset_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_sfn_offset_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_sfn_offset_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_sfn_offset_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_gain_correction_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers/gain-correction
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_gain_correction_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_gain_correction_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_gain_correction_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_gain_correction_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_n_ta_offset_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers/n-ta-offset
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_n_ta_offset_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_n_ta_offset_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_n_ta_offset_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_n_ta_offset_edit */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_edit
*
* Edit database object callback
* Path: /user-plane-configuration/rx-array-carriers
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_array_carriers_name =
        VAL_STRING(sil_sa_get_key(msg, 1));

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_edit(scb, msg, cbtyp, editop, newval, curval,
        k_user_plane_configuration_rx_array_carriers_name);

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_edit */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_arrays_normal_vector_direction_get
*
* Get database object callback for container normal-vector-direction
* Path: /user-plane-configuration/tx-arrays/normal-vector-direction
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_arrays_normal_vector_direction_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_arrays_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_tx_arrays_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_tx_arrays_normal_vector_direction_get(
        get2cb,
        k_user_plane_configuration_tx_arrays_name);

} /* o_ran_uplane_conf_user_plane_configuration_tx_arrays_normal_vector_direction_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_arrays_leftmost_bottom_array_element_position_get
*
* Get database object callback for container leftmost-bottom-array-element-position
* Path: /user-plane-configuration/tx-arrays/leftmost-bottom-array-element-position
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_arrays_leftmost_bottom_array_element_position_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_arrays_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_tx_arrays_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_tx_arrays_leftmost_bottom_array_element_position_get(
        get2cb,
        k_user_plane_configuration_tx_arrays_name);

} /* o_ran_uplane_conf_user_plane_configuration_tx_arrays_leftmost_bottom_array_element_position_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_arrays_polarisations_get
*
* Get database object callback for list polarisations
* Path: /user-plane-configuration/tx-arrays/polarisations
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_arrays_polarisations_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_arrays_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_tx_arrays_name = VAL_STRING(keyval);
    }

    /* local key o-ran-uplane-conf:p */
    uint8 k_user_plane_configuration_tx_arrays_polarisations_p = 0;
    boolean p_fixed = FALSE;
    boolean p_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_p);
    if (keyval) {
        k_user_plane_configuration_tx_arrays_polarisations_p = VAL_UINT8(keyval);
        p_fixed = VAL_IS_FIXED_VALUE(keyval);
        p_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_tx_arrays_polarisations_get(
        get2cb,
        k_user_plane_configuration_tx_arrays_name,
        k_user_plane_configuration_tx_arrays_polarisations_p,
        p_fixed,
        p_present);

} /* o_ran_uplane_conf_user_plane_configuration_tx_arrays_polarisations_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_tx_arrays_get
*
* Get database object callback for list tx-arrays
* Path: /user-plane-configuration/tx-arrays
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_tx_arrays_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_tx_arrays_name = 0;
    boolean name_fixed = FALSE;
    boolean name_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_tx_arrays_name = VAL_STRING(keyval);
        name_fixed = VAL_IS_FIXED_VALUE(keyval);
        name_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_tx_arrays_get(
        get2cb,
        k_user_plane_configuration_tx_arrays_name,
        name_fixed,
        name_present);

} /* o_ran_uplane_conf_user_plane_configuration_tx_arrays_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_arrays_normal_vector_direction_get
*
* Get database object callback for container normal-vector-direction
* Path: /user-plane-configuration/rx-arrays/normal-vector-direction
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_arrays_normal_vector_direction_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_arrays_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_rx_arrays_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_rx_arrays_normal_vector_direction_get(
        get2cb,
        k_user_plane_configuration_rx_arrays_name);

} /* o_ran_uplane_conf_user_plane_configuration_rx_arrays_normal_vector_direction_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_arrays_leftmost_bottom_array_element_position_get
*
* Get database object callback for container leftmost-bottom-array-element-position
* Path: /user-plane-configuration/rx-arrays/leftmost-bottom-array-element-position
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_arrays_leftmost_bottom_array_element_position_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_arrays_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_rx_arrays_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_rx_arrays_leftmost_bottom_array_element_position_get(
        get2cb,
        k_user_plane_configuration_rx_arrays_name);

} /* o_ran_uplane_conf_user_plane_configuration_rx_arrays_leftmost_bottom_array_element_position_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_arrays_polarisations_get
*
* Get database object callback for list polarisations
* Path: /user-plane-configuration/rx-arrays/polarisations
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_arrays_polarisations_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_arrays_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_rx_arrays_name = VAL_STRING(keyval);
    }

    /* local key o-ran-uplane-conf:p */
    uint8 k_user_plane_configuration_rx_arrays_polarisations_p = 0;
    boolean p_fixed = FALSE;
    boolean p_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_p);
    if (keyval) {
        k_user_plane_configuration_rx_arrays_polarisations_p = VAL_UINT8(keyval);
        p_fixed = VAL_IS_FIXED_VALUE(keyval);
        p_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_rx_arrays_polarisations_get(
        get2cb,
        k_user_plane_configuration_rx_arrays_name,
        k_user_plane_configuration_rx_arrays_polarisations_p,
        p_fixed,
        p_present);

} /* o_ran_uplane_conf_user_plane_configuration_rx_arrays_polarisations_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_arrays_gain_correction_range_get
*
* Get database object callback for container gain-correction-range
* Path: /user-plane-configuration/rx-arrays/gain-correction-range
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_arrays_gain_correction_range_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_arrays_name = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_rx_arrays_name = VAL_STRING(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_rx_arrays_gain_correction_range_get(
        get2cb,
        k_user_plane_configuration_rx_arrays_name);

} /* o_ran_uplane_conf_user_plane_configuration_rx_arrays_gain_correction_range_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_rx_arrays_get
*
* Get database object callback for list rx-arrays
* Path: /user-plane-configuration/rx-arrays
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_rx_arrays_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* local key o-ran-uplane-conf:name */
    const xmlChar *k_user_plane_configuration_rx_arrays_name = 0;
    boolean name_fixed = FALSE;
    boolean name_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_name);
    if (keyval) {
        k_user_plane_configuration_rx_arrays_name = VAL_STRING(keyval);
        name_fixed = VAL_IS_FIXED_VALUE(keyval);
        name_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_rx_arrays_get(
        get2cb,
        k_user_plane_configuration_rx_arrays_name,
        name_fixed,
        name_present);

} /* o_ran_uplane_conf_user_plane_configuration_rx_arrays_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_relations_array1_antenna_type_get
*
* Get database object callback for choice antenna-type
* Path: /user-plane-configuration/relations/array1/antenna-type
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_relations_array1_antenna_type_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:entity */
    uint16 k_user_plane_configuration_relations_entity = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_entity);
    if (keyval) {
        k_user_plane_configuration_relations_entity = VAL_UINT16(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_relations_array1_antenna_type_get(
        get2cb,
        k_user_plane_configuration_relations_entity);

} /* o_ran_uplane_conf_user_plane_configuration_relations_array1_antenna_type_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_relations_array1_get
*
* Get database object callback for container array1
* Path: /user-plane-configuration/relations/array1
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_relations_array1_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:entity */
    uint16 k_user_plane_configuration_relations_entity = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_entity);
    if (keyval) {
        k_user_plane_configuration_relations_entity = VAL_UINT16(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_relations_array1_get(
        get2cb,
        k_user_plane_configuration_relations_entity);

} /* o_ran_uplane_conf_user_plane_configuration_relations_array1_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_relations_array2_antenna_type_get
*
* Get database object callback for choice antenna-type
* Path: /user-plane-configuration/relations/array2/antenna-type
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_relations_array2_antenna_type_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:entity */
    uint16 k_user_plane_configuration_relations_entity = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_entity);
    if (keyval) {
        k_user_plane_configuration_relations_entity = VAL_UINT16(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_relations_array2_antenna_type_get(
        get2cb,
        k_user_plane_configuration_relations_entity);

} /* o_ran_uplane_conf_user_plane_configuration_relations_array2_antenna_type_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_relations_array2_get
*
* Get database object callback for container array2
* Path: /user-plane-configuration/relations/array2
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_relations_array2_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:entity */
    uint16 k_user_plane_configuration_relations_entity = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_entity);
    if (keyval) {
        k_user_plane_configuration_relations_entity = VAL_UINT16(keyval);
    }

    return u_o_ran_uplane_conf_user_plane_configuration_relations_array2_get(
        get2cb,
        k_user_plane_configuration_relations_entity);

} /* o_ran_uplane_conf_user_plane_configuration_relations_array2_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_relations_types_pairs_get
*
* Get database object callback for list pairs
* Path: /user-plane-configuration/relations/types/pairs
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_relations_types_pairs_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:entity */
    uint16 k_user_plane_configuration_relations_entity = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_entity);
    if (keyval) {
        k_user_plane_configuration_relations_entity = VAL_UINT16(keyval);
    }

    /* ancestor key o-ran-uplane-conf:relation-type */
    const xmlChar *k_user_plane_configuration_relations_types_relation_type = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_relation_type);
    if (keyval) {
        k_user_plane_configuration_relations_types_relation_type = VAL_ENUM_NAME(keyval);
    }

    /* local key o-ran-uplane-conf:element-array1 */
    uint16 k_user_plane_configuration_relations_types_pairs_element_array1 = 0;
    boolean element_array1_fixed = FALSE;
    boolean element_array1_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_element_array1);
    if (keyval) {
        k_user_plane_configuration_relations_types_pairs_element_array1 = VAL_UINT16(keyval);
        element_array1_fixed = VAL_IS_FIXED_VALUE(keyval);
        element_array1_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_relations_types_pairs_get(
        get2cb,
        k_user_plane_configuration_relations_entity,
        k_user_plane_configuration_relations_types_relation_type,
        k_user_plane_configuration_relations_types_pairs_element_array1,
        element_array1_fixed,
        element_array1_present);

} /* o_ran_uplane_conf_user_plane_configuration_relations_types_pairs_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_relations_types_get
*
* Get database object callback for list types
* Path: /user-plane-configuration/relations/types
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_relations_types_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* ancestor key o-ran-uplane-conf:entity */
    uint16 k_user_plane_configuration_relations_entity = 0;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_entity);
    if (keyval) {
        k_user_plane_configuration_relations_entity = VAL_UINT16(keyval);
    }

    /* local key o-ran-uplane-conf:relation-type */
    const xmlChar *k_user_plane_configuration_relations_types_relation_type = 0;
    boolean relation_type_fixed = FALSE;
    boolean relation_type_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_relation_type);
    if (keyval) {
        k_user_plane_configuration_relations_types_relation_type = VAL_ENUM_NAME(keyval);
        relation_type_fixed = VAL_IS_FIXED_VALUE(keyval);
        relation_type_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_relations_types_get(
        get2cb,
        k_user_plane_configuration_relations_entity,
        k_user_plane_configuration_relations_types_relation_type,
        relation_type_fixed,
        relation_type_present);

} /* o_ran_uplane_conf_user_plane_configuration_relations_types_get */

/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_relations_get
*
* Get database object callback for list relations
* Path: /user-plane-configuration/relations
* Fill in 'get2cb' response fields
*
* INPUTS:
*     see ncx/getcb.h for details (getcb_fn2_t)
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_relations_get (
    ses_cb_t *scb,
    xml_msg_hdr_t *msg,
    getcb_get2_t *get2cb)
{

    (void)scb;
    (void)msg;
    val_value_t *keyval = NULL;

    /* local key o-ran-uplane-conf:entity */
    uint16 k_user_plane_configuration_relations_entity = 0;
    boolean entity_fixed = FALSE;
    boolean entity_present = FALSE;
    keyval = getcb_find_key_str(get2cb,
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_N_entity);
    if (keyval) {
        k_user_plane_configuration_relations_entity = VAL_UINT16(keyval);
        entity_fixed = VAL_IS_FIXED_VALUE(keyval);
        entity_present = TRUE;
    }

    return u_o_ran_uplane_conf_user_plane_configuration_relations_get(
        get2cb,
        k_user_plane_configuration_relations_entity,
        entity_fixed,
        entity_present);

} /* o_ran_uplane_conf_user_plane_configuration_relations_get */


/********************************************************************
* FUNCTION o_ran_uplane_conf_user_plane_configuration_edit
*
* Edit database object callback
* Path: /user-plane-configuration
* Add object instrumentation in COMMIT phase.
*
* INPUTS:
*     see agt/agt_cb.h for details
*
* RETURNS:
*     error status
********************************************************************/
static status_t o_ran_uplane_conf_user_plane_configuration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    uint32 cur_errs = agt_get_error_count(msg);

    if (LOGDEBUG) {
        log_debug("\nEnter o_ran_uplane_conf_user_plane_configuration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    res = u_o_ran_uplane_conf_user_plane_configuration_edit(scb, msg, cbtyp, editop, newval, curval);

    if (res == NO_ERR && cbtyp == AGT_CB_COMMIT) {
        res = agt_check_cache(&user_plane_configuration_val, newval, curval, editop);
    }
    

    if ((res != NO_ERR) && (cur_errs == agt_get_error_count(msg))) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* o_ran_uplane_conf_user_plane_configuration_edit */

/********************************************************************
* FUNCTION y_o_ran_uplane_conf_init
*
* initialize the o-ran-uplane-conf server instrumentation library
*
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
*
* RETURNS:
*     error status
********************************************************************/
status_t y_o_ran_uplane_conf_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;

    y_o_ran_uplane_conf_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_o_ran_uplane_conf_M_o_ran_uplane_conf)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_o_ran_uplane_conf_R_o_ran_uplane_conf)) {
        return ERR_NCX_WRONG_VERSION;
    }


    res = ncxmod_load_module(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        agt_get_savedevQ(),
        &o_ran_uplane_conf_mod);
    if (res != NO_ERR) {
        return res;
    }

    user_plane_configuration_obj = ncx_find_object(
        o_ran_uplane_conf_mod,
        y_o_ran_uplane_conf_N_user_plane_configuration);
    if (user_plane_configuration_obj == NULL) {
        return ERR_NCX_DEF_NOT_FOUND;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-links",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-links/o-ran-uplane-conf:processing-element",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_processing_element_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-links/o-ran-uplane-conf:tx-array-carrier",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_tx_array_carrier_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-links/o-ran-uplane-conf:low-level-tx-endpoint",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_links_low_level_tx_endpoint_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-links",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-links/o-ran-uplane-conf:processing-element",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_processing_element_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-links/o-ran-uplane-conf:rx-array-carrier",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_rx_array_carrier_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-links/o-ran-uplane-conf:low-level-rx-endpoint",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_low_level_rx_endpoint_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-links/o-ran-uplane-conf:user-plane-uplink-marking",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_links_user_plane_uplink_marking_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:endpoint-types",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_endpoint_types_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:endpoint-types/o-ran-uplane-conf:supported-section-types",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_endpoint_types_supported_section_types_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:endpoint-capacity-sharing-groups",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_endpoint_capacity_sharing_groups_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:static-low-level-tx-endpoints",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_static_low_level_tx_endpoints_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:static-low-level-rx-endpoints",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_static_low_level_rx_endpoints_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-type",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:bitwidth",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_bitwidth_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:block-floating-point/o-ran-uplane-conf:exponent",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_floating_point_exponent_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:block-scaling/o-ran-uplane-conf:block-scalar",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_block_scaling_block_scalar_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:u-law/o-ran-uplane-conf:comp-bit-width",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_bit_width_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:u-law/o-ran-uplane-conf:comp-shift",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_u_law_comp_shift_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:beam-space-compression/o-ran-uplane-conf:active-beam-space-coeficient-mask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:beam-space-compression/o-ran-uplane-conf:block-scaler",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:modulation-compression/o-ran-uplane-conf:csf",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_csf_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:modulation-compression/o-ran-uplane-conf:mod-comp-scaler",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:frame-structure",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_frame_structure_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:cp-type",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:cp-length",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:cp-length-other",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_cp_length_other_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:offset-to-absolute-frequency-center",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_offset_to_absolute_frequency_center_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:number-of-prb-per-scs",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:number-of-prb-per-scs/o-ran-uplane-conf:number-of-prb",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_number_of_prb_per_scs_number_of_prb_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:e-axcid",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:o-du-port-bitmask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_o_du_port_bitmask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:band-sector-bitmask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_band_sector_bitmask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:ccid-bitmask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ccid_bitmask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:ru-port-bitmask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_ru_port_bitmask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:eaxc-id",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_tx_endpoints_e_axcid_eaxc_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-type",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:bitwidth",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_bitwidth_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:block-floating-point/o-ran-uplane-conf:exponent",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_floating_point_exponent_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:block-scaling/o-ran-uplane-conf:block-scalar",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_block_scaling_block_scalar_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:u-law/o-ran-uplane-conf:comp-bit-width",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_bit_width_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:u-law/o-ran-uplane-conf:comp-shift",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_u_law_comp_shift_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:beam-space-compression/o-ran-uplane-conf:active-beam-space-coeficient-mask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_active_beam_space_coeficient_mask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:beam-space-compression/o-ran-uplane-conf:block-scaler",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_beam_space_compression_block_scaler_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:modulation-compression/o-ran-uplane-conf:csf",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_csf_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression/o-ran-uplane-conf:compression-format/o-ran-uplane-conf:modulation-compression/o-ran-uplane-conf:mod-comp-scaler",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_compression_compression_format_modulation_compression_mod_comp_scaler_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:frame-structure",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_frame_structure_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:cp-type",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:cp-length",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:cp-length-other",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_cp_length_other_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:offset-to-absolute-frequency-center",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_offset_to_absolute_frequency_center_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:number-of-prb-per-scs",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:number-of-prb-per-scs/o-ran-uplane-conf:number-of-prb",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_number_of_prb_per_scs_number_of_prb_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:ul-fft-sampling-offsets",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:ul-fft-sampling-offsets/o-ran-uplane-conf:ul-fft-sampling-offset",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_ul_fft_sampling_offsets_ul_fft_sampling_offset_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:e-axcid",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:o-du-port-bitmask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_o_du_port_bitmask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:band-sector-bitmask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_band_sector_bitmask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:ccid-bitmask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ccid_bitmask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:ru-port-bitmask",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_ru_port_bitmask_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:e-axcid/o-ran-uplane-conf:eaxc-id",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_e_axcid_eaxc_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:non-time-managed-delay-enabled",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_low_level_rx_endpoints_non_time_managed_delay_enabled_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:absolute-frequency-center",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_absolute_frequency_center_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:center-of-channel-bandwidth",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_center_of_channel_bandwidth_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:channel-bandwidth",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_channel_bandwidth_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:active",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_active_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:state",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_state_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:type",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_type_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:duplex-scheme",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_duplex_scheme_get);
    if (res != NO_ERR) {
        return res;
    }


#ifdef u_o_ran_module_cap_F_LAA
    if (ncx_feature_enabled_str(
        y_o_ran_module_cap_M_o_ran_module_cap,
        y_o_ran_module_cap_R_o_ran_module_cap,
        (const xmlChar *)"LAA")) {
        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:band-number",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_band_number_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_o_ran_module_cap_F_LAA */
#endif /* u_o_ran_module_cap_F_LAA */

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:lte-tdd-frame",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:lte-tdd-frame/o-ran-uplane-conf:subframe-assignment",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_subframe_assignment_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:lte-tdd-frame/o-ran-uplane-conf:special-subframe-pattern",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_lte_tdd_frame_special_subframe_pattern_edit);
    if (res != NO_ERR) {
        return res;
    }


#ifdef u_o_ran_module_cap_F_LAA
    if (ncx_feature_enabled_str(
        y_o_ran_module_cap_M_o_ran_module_cap,
        y_o_ran_module_cap_R_o_ran_module_cap,
        (const xmlChar *)"LAA")) {
        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:ed-threshold-pdsch",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_pdsch_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:ed-threshold-drs",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_ed_threshold_drs_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:tx-antenna-ports",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_tx_antenna_ports_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:transmission-power-for-drs",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_transmission_power_for_drs_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:dmtc-period",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_period_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:dmtc-offset",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_dmtc_offset_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:lbt-timer",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_lbt_timer_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:max-cw-usage-counter",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_edit);
        if (res != NO_ERR) {
            return res;
        }

        res = agt_cb_register_callback(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:max-cw-usage-counter/o-ran-uplane-conf:counter-value",
            y_o_ran_uplane_conf_R_o_ran_uplane_conf,
            o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_laa_carrier_configuration_max_cw_usage_counter_counter_value_edit);
        if (res != NO_ERR) {
            return res;
        }
    } /* u_o_ran_module_cap_F_LAA */
#endif /* u_o_ran_module_cap_F_LAA */

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:gain",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_gain_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:downlink-radio-frame-offset",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_radio_frame_offset_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:downlink-sfn-offset",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_array_carriers_downlink_sfn_offset_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:absolute-frequency-center",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_absolute_frequency_center_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:center-of-channel-bandwidth",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_center_of_channel_bandwidth_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:channel-bandwidth",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_channel_bandwidth_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:active",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_active_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:state",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_state_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:type",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_type_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:duplex-scheme",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_duplex_scheme_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:downlink-radio-frame-offset",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_radio_frame_offset_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:downlink-sfn-offset",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_downlink_sfn_offset_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:gain-correction",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_gain_correction_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers/o-ran-uplane-conf:n-ta-offset",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_array_carriers_n_ta_offset_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-arrays",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_arrays_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-arrays/o-ran-uplane-conf:normal-vector-direction",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_arrays_normal_vector_direction_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-arrays/o-ran-uplane-conf:leftmost-bottom-array-element-position",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_arrays_leftmost_bottom_array_element_position_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-arrays/o-ran-uplane-conf:polarisations",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_tx_arrays_polarisations_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_arrays_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays/o-ran-uplane-conf:normal-vector-direction",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_arrays_normal_vector_direction_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays/o-ran-uplane-conf:leftmost-bottom-array-element-position",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_arrays_leftmost_bottom_array_element_position_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays/o-ran-uplane-conf:polarisations",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_arrays_polarisations_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays/o-ran-uplane-conf:gain-correction-range",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_rx_arrays_gain_correction_range_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_relations_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:array1",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_relations_array1_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:array1/o-ran-uplane-conf:antenna-type",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_relations_array1_antenna_type_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:array2",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_relations_array2_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:array2/o-ran-uplane-conf:antenna-type",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_relations_array2_antenna_type_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:types",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_relations_types_get);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_get_callback(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:types/o-ran-uplane-conf:pairs",
        y_o_ran_uplane_conf_R_o_ran_uplane_conf,
        o_ran_uplane_conf_user_plane_configuration_relations_types_pairs_get);
    if (res != NO_ERR) {
        return res;
    }

    res = u_o_ran_uplane_conf_init(modname, revision);
    return res;

} /* y_o_ran_uplane_conf_init */

/********************************************************************
* FUNCTION y_o_ran_uplane_conf_init2
*
* SIL init phase 2: non-config data structures
* Called after running config is loaded
*
* RETURNS:
*     error status
********************************************************************/
status_t y_o_ran_uplane_conf_init2 (void)
{
    status_t res = NO_ERR;

    res = u_o_ran_uplane_conf_init2();

    return res;

} /* y_o_ran_uplane_conf_init2 */

/********************************************************************
* FUNCTION y_o_ran_uplane_conf_cleanup
*    cleanup the server instrumentation library
*
********************************************************************/
void y_o_ran_uplane_conf_cleanup (void)
{

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-links");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-links");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:endpoint-types");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:endpoint-types/o-ran-uplane-conf:supported-section-types");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:endpoint-capacity-sharing-groups");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:static-low-level-tx-endpoints");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:static-low-level-rx-endpoints");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:compression");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:number-of-prb-per-scs");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-tx-endpoints/o-ran-uplane-conf:e-axcid");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:compression");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:number-of-prb-per-scs");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:ul-fft-sampling-offsets");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:low-level-rx-endpoints/o-ran-uplane-conf:e-axcid");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:lte-tdd-frame");


#ifdef u_o_ran_module_cap_F_LAA
    if (ncx_feature_enabled_str(
        y_o_ran_module_cap_M_o_ran_module_cap,
        y_o_ran_module_cap_R_o_ran_module_cap,
        (const xmlChar *)"LAA")) {
        agt_cb_unregister_callbacks(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration");

        agt_cb_unregister_callbacks(
            y_o_ran_uplane_conf_M_o_ran_uplane_conf,
            (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-array-carriers/o-ran-uplane-conf:laa-carrier-configuration/o-ran-uplane-conf:max-cw-usage-counter");
    } /* u_o_ran_module_cap_F_LAA */
#endif /* u_o_ran_module_cap_F_LAA */

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-array-carriers");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-arrays");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-arrays/o-ran-uplane-conf:normal-vector-direction");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-arrays/o-ran-uplane-conf:leftmost-bottom-array-element-position");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:tx-arrays/o-ran-uplane-conf:polarisations");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays/o-ran-uplane-conf:normal-vector-direction");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays/o-ran-uplane-conf:leftmost-bottom-array-element-position");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays/o-ran-uplane-conf:polarisations");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:rx-arrays/o-ran-uplane-conf:gain-correction-range");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:array1");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:array1/o-ran-uplane-conf:antenna-type");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:array2");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:array2/o-ran-uplane-conf:antenna-type");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:types");

    agt_cb_unregister_callbacks(
        y_o_ran_uplane_conf_M_o_ran_uplane_conf,
        (const xmlChar *)"/o-ran-uplane-conf:user-plane-configuration/o-ran-uplane-conf:relations/o-ran-uplane-conf:types/o-ran-uplane-conf:pairs");

    u_o_ran_uplane_conf_cleanup();

} /* y_o_ran_uplane_conf_cleanup */

/* END SIL-SA y_o_ran_uplane_conf.c */
